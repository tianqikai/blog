2020-12-24 23:17:48.645 DEBUG [main]com.tqk.blog.BlogApplication.logStarting:56 -Running with Spring Boot v2.2.2.RELEASE, Spring v5.2.2.RELEASE
2020-12-24 23:22:35.569 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlAdminMapper.getByUsername.debug:159 -==>  Preparing: select name, header, signature, username, password from bl_admin where username = ? 
2020-12-24 23:22:35.604 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlAdminMapper.getByUsername.debug:159 -==> Parameters: admin(String)
2020-12-24 23:22:35.665 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlAdminMapper.getByUsername.debug:159 -<==      Total: 1
2020-12-24 23:22:35.806 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:22:35.811 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /BlAdmin/login(String), [com.tqk.blog.pojo.BlAdmin@489ab258](String), 1(Integer), null, POST(String), 211(Long), {"code":20000,"data":{"token":"A067CEEBD740CFD9E1C029711838CC96"},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:22:35.897 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:22:36.051 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:22:36.052 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /BlAdmin/info(String), [](String), 1(Integer), null, GET(String), 1(Long), {"code":20000,"data":{"name":"田起凯","password":"","signature":"hold on","username":"admin"},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:22:36.138 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:22:36.370 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlTypeMapper.selectByExample.debug:159 -==>  Preparing: SELECT type_id,type_name,type_blog_count,enable,deleted FROM bl_type WHERE ( enable = ? and deleted = ? ) 
2020-12-24 23:22:36.371 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlTypeMapper.selectByExample.debug:159 -==> Parameters: 1(Integer), 0(Integer)
2020-12-24 23:22:36.412 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlTypeMapper.selectByExample.debug:159 -<==      Total: 7
2020-12-24 23:22:36.458 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:22:36.460 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /type/getList(String), [](String), 1(Integer), null, GET(String), 131(Long), {"code":20000,"data":[{"deleted":0,"enable":1,"typeBlogCount":105,"typeId":1,"typeName":"Java"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"Python"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":6,"typeName":"going"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":7,"typeName":"Spring"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"nginx"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Redis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":10,"typeName":"Docker"}],"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:22:36.548 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:22:40.223 DEBUG [http-nio-8899-exec-4]com.tqk.blog.mapper.BlTypeMapper.selectAll.debug:159 -==>  Preparing: SELECT type_id,type_name,type_blog_count,enable,deleted FROM bl_type 
2020-12-24 23:22:40.224 DEBUG [http-nio-8899-exec-4]com.tqk.blog.mapper.BlTypeMapper.selectAll.debug:159 -==> Parameters: 
2020-12-24 23:22:40.261 DEBUG [http-nio-8899-exec-4]com.tqk.blog.mapper.BlTypeMapper.selectAll.debug:159 -<==      Total: 7
2020-12-24 23:22:40.300 DEBUG [http-nio-8899-exec-4]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:22:40.301 DEBUG [http-nio-8899-exec-4]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /type/listBack(String), [](String), 1(Integer), null, GET(String), 78(Long), {"code":20000,"data":[{"deleted":0,"enable":1,"typeBlogCount":105,"typeId":1,"typeName":"Java"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"Python"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":6,"typeName":"going"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":7,"typeName":"Spring"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"nginx"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Redis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":10,"typeName":"Docker"}],"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:22:40.380 DEBUG [http-nio-8899-exec-4]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:22:44.900 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -==>  Preparing: select blog_id, blog_title, blog_image, blog_goods, blog_read, blog_collection, blog_remark, blog_comment, blog_source, created_time, update_time,type_name from bl_blog as b inner join bl_type as t on type_id = blog_type where t.deleted = 0 and b.deleted = 0 limit ?, ? 
2020-12-24 23:22:44.902 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -==> Parameters: 0(Integer), 10(Integer)
2020-12-24 23:22:44.940 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -<==      Total: 3
2020-12-24 23:22:44.942 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -==>  Preparing: select count(*) from bl_blog as b inner join bl_type as t on type_id = blog_type where t.deleted = 0 and b.deleted = 0 
2020-12-24 23:22:44.942 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -==> Parameters: 
2020-12-24 23:22:44.981 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -<==      Total: 1
2020-12-24 23:22:45.106 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:22:45.108 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/getByPage(String), [Page(currentPage=1, pageSize=10, totalPage=0, totalCount=0, list=[], params={}, sortColumn=null, sortMethod=asc)](String), 1(Integer), null, POST(String), 265(Long), {"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1324038097171820544","blogImage":"Java","blogRead":0,"blogRemark":"BeanUtils它提供了对java反射和自省API的包装。它里面还有很多工具类，这里我们介绍一下copyProperties。","blogSource":"百度","blogTitle":"BeanUtils.copyProperties的用法","createdTime":"2020-11-04 17:17:33","typeName":"Java","updateTime":"2020-11-22 13:04:15"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1330877080455553024","blogRead":0,"blogRemark":"MySQL","blogTitle":"面试官不讲武德问我：为什么MySQL不建议使用delete删除数据？","createdTime":"2020-11-23 14:13:16","typeName":"Java","updateTime":"2020-11-23 14:23:06"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1330879440221315072","blogRead":0,"blogRemark":"面试必备","blogTitle":"Java岗四面字节跳动成功之前，我都刷了那些面试题以及做了那些准备！","createdTime":"2020-11-23 14:22:39","typeName":"Java","updateTime":"2020-11-23 14:22:39"}],"pageSize":10,"params":{},"sortMethod":"asc","totalCount":3,"totalPage":1},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:22:45.193 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:22:48.753 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlAboutMapper.getByPage.debug:159 -==>  Preparing: select about_id, about_title, about_read, about_content, created_time, update_time, enable from bl_about where deleted = 0 limit ?, ? 
2020-12-24 23:22:48.754 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlAboutMapper.getByPage.debug:159 -==> Parameters: 0(Integer), 10(Integer)
2020-12-24 23:22:48.799 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlAboutMapper.getByPage.debug:159 -<==      Total: 2
2020-12-24 23:22:48.839 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlAboutMapper.getCountByPage.debug:159 -==>  Preparing: select count(*) from bl_about where deleted = 0 
2020-12-24 23:22:48.840 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlAboutMapper.getCountByPage.debug:159 -==> Parameters: 
2020-12-24 23:22:48.876 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlAboutMapper.getCountByPage.debug:159 -<==      Total: 1
2020-12-24 23:22:48.929 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:22:48.931 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /about/getByPage(String), [Page(currentPage=1, pageSize=10, totalPage=0, totalCount=0, list=[], params={}, sortColumn=null, sortMethod=asc)](String), 1(Integer), null, POST(String), 179(Long), {"code":20000,"data":{"currentPage":1,"index":0,"list":[{"aboutContent":"<p>最近，上海、天津等地出现个别疫情，也出现了将患者或相关人士的信息在网络上泄露，影响这些人的生活的事件。还有关于清华&ldquo;学姐&rdquo;在网络上的基于误会将一个男生的信息曝光的事件，更有一些快递公司&ldquo;内鬼&rdquo;泄露大量客户的详细信息的事件。这些其实都把个人隐私的保护上所出现的问题推到了前台。一方面确实接连出现那种个人隐私被泄露的事件，另一方面这些隐私的泄露所造成的实实在在的损害在这些例子中也都有充分的展现。</p>\n<p>个人隐私的保护，既是对于个人权利的尊重，也对于社会具有重要的意义。隐私的保护对于个体来说当然是重要的，因为个人的隐私的泄露当然会对个体由多方面的伤害，让个体的正常生活受到冲击和威胁。对于社会来说，个人的隐私的保护其实也是使社会生活更加安全的重要的保障。个人的隐私受到保护，既是在法律上十分清晰的，也是在伦理上极为必要的。这其实也是一个重要的社会底线。</p>\n<p>网络和大数据的发展使得个人的信息的搜集和处理都更加便捷和迅速。社会为了更便捷地运作和有效地运转，为了公众利益和为个体更好地服务，往往更多地搜集个人的多方面的资料，个人的资料为相关的方面所掌握在社会中也是必要的。但这当然不可能是无限度无底线的，这些其实都有法律的严格规定，也有伦理的基本的原则。实际上，这些界限其实是相当明确和清晰的。</p>\n<p>现在所出现的一些情况，就是完全违反了这些基本的限定，一些人随意地把他人的隐私信息在互联网这样的无远弗届的公共空间泄露。这种泄露造成的诸如&ldquo;网暴&rdquo;&ldquo;社交死亡&rdquo;等等现象现在在社会中已经成为的相当多的存在。个人的行为的许多不需要也不应该为公众广泛了解的一些情况，在被人们在公共空间中暴露，当然会对个人形成相当的伤害，也会让一些居心不良的人所利用，同时也会对于社会中的人们基本的安全的诉求构成冲击。</p>\n<p>有些人误解了基于&ldquo;公众利益&rdquo;的对于个人的信息的适度的披露和揭隐私、揭老底一类的恶俗行为的的关系，往往把过去小社区中的街谈巷议等等直接放到了所有人的公共空间的互联网上。也有人把&ldquo;群&rdquo;还是看成小圈子，小群体，传播有限，不知道实际上这种传播只要在网上，就可以是全社会的传播。有些接触一般人难以接触的资料的人，也并不觉得泄露这些是严重的事情。这其实和一些人缺少公共空间与私人生活的界限有关，也与当下的新的技术手段造成的便捷的传播有关。这些都构成了对于隐私的保护的冲击，这种冲击没有被有效制止，侵害隐私的行为没有得到惩戒和批评，就会产生&ldquo;示范效应&rdquo;，使得这样的情况一一发不可收拾，构成对于个人和社会的严重伤害。</p>\n<p>严格对于隐私保护的相关法律的执行，对于隐私保护的伦理要求也需要受到公众和社会的更多的维护。让人们生活在一个个人的隐私不能被随便泄露的状况中，这也需要全社会的更多的努力。</p>","aboutId":"1","aboutRead":1,"aboutTitle":"“社交死亡”现象越来越多 ，该如何保护个人隐私","createdTime":1603782451000,"enable":1,"updateTime":1606199712000},{"aboutContent":"你好(*´▽｀)ノノ","aboutId":"3","aboutRead":3,"aboutTitle":"hello","createdTime":1603780570000,"enable":0,"updateTime":1603782499000}],"pageSize":10,"params":{},"sortMethod":"asc","totalCount":2,"totalPage":1},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:22:49.019 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:22:58.436 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlAboutMapper.getByPage.debug:159 -==>  Preparing: select about_id, about_title, about_read, about_content, created_time, update_time, enable from bl_about where deleted = 0 order by about_read asc limit ?, ? 
2020-12-24 23:22:58.437 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlAboutMapper.getByPage.debug:159 -==> Parameters: 0(Integer), 10(Integer)
2020-12-24 23:22:58.475 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlAboutMapper.getByPage.debug:159 -<==      Total: 2
2020-12-24 23:22:58.517 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlAboutMapper.getCountByPage.debug:159 -==>  Preparing: select count(*) from bl_about where deleted = 0 
2020-12-24 23:22:58.518 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlAboutMapper.getCountByPage.debug:159 -==> Parameters: 
2020-12-24 23:22:58.553 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlAboutMapper.getCountByPage.debug:159 -<==      Total: 1
2020-12-24 23:22:58.599 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:22:58.603 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /about/getByPage(String), [Page(currentPage=1, pageSize=10, totalPage=1, totalCount=2, list=[BlAbout(aboutId=1, aboutTitle=“社交死亡”现象越来越多 ，该如何保护个人隐私, aboutRead=1, createdTime=Tue Oct 27 15:07:31 CST 2020, updateTime=Tue Nov 24 14:35:12 CST 2020, version=null, enable=1, deleted=null, aboutContent=<p>最近，上海、天津等地出现个别疫情，也出现了将患者或相关人士的信息在网络上泄露，影响这些人的生活的事件。还有关于清华&ldquo;学姐&rdquo;在网络上的基于误会将一个男生的信息曝光的事件，更有一些快递公司&ldquo;内鬼&rdquo;泄露大量客户的详细信息的事件。这些其实都把个人隐私的保护上所出现的问题推到了前台。一方面确实接连出现那种个人隐私被泄露的事件，另一方面这些隐私的泄露所造成的实实在在的损害在这些例子中也都有充分的展现。</p>
<p>个人隐私的保护，既是对于个人权利的尊重，也对于社会具有重要的意义。隐私的保护对于个体来说当然是重要的，因为个人的隐私的泄露当然会对个体由多方面的伤害，让个体的正常生活受到冲击和威胁。对于社会来说，个人的隐私的保护其实也是使社会生活更加安全的重要的保障。个人的隐私受到保护，既是在法律上十分清晰的，也是在伦理上极为必要的。这其实也是一个重要的社会底线。</p>
<p>网络和大数据的发展使得个人的信息的搜集和处理都更加便捷和迅速。社会为了更便捷地运作和有效地运转，为了公众利益和为个体更好地服务，往往更多地搜集个人的多方面的资料，个人的资料为相关的方面所掌握在社会中也是必要的。但这当然不可能是无限度无底线的，这些其实都有法律的严格规定，也有伦理的基本的原则。实际上，这些界限其实是相当明确和清晰的。</p>
<p>现在所出现的一些情况，就是完全违反了这些基本的限定，一些人随意地把他人的隐私信息在互联网这样的无远弗届的公共空间泄露。这种泄露造成的诸如&ldquo;网暴&rdquo;&ldquo;社交死亡&rdquo;等等现象现在在社会中已经成为的相当多的存在。个人的行为的许多不需要也不应该为公众广泛了解的一些情况，在被人们在公共空间中暴露，当然会对个人形成相当的伤害，也会让一些居心不良的人所利用，同时也会对于社会中的人们基本的安全的诉求构成冲击。</p>
<p>有些人误解了基于&ldquo;公众利益&rdquo;的对于个人的信息的适度的披露和揭隐私、揭老底一类的恶俗行为的的关系，往往把过去小社区中的街谈巷议等等直接放到了所有人的公共空间的互联网上。也有人把&ldquo;群&rdquo;还是看成小圈子，小群体，传播有限，不知道实际上这种传播只要在网上，就可以是全社会的传播。有些接触一般人难以接触的资料的人，也并不觉得泄露这些是严重的事情。这其实和一些人缺少公共空间与私人生活的界限有关，也与当下的新的技术手段造成的便捷的传播有关。这些都构成了对于隐私的保护的冲击，这种冲击没有被有效制止，侵害隐私的行为没有得到惩戒和批评，就会产生&ldquo;示范效应&rdquo;，使得这样的情况一一发不可收拾，构成对于个人和社会的严重伤害。</p>
<p>严格对于隐私保护的相关法律的执行，对于隐私保护的伦理要求也需要受到公众和社会的更多的维护。让人们生活在一个个人的隐私不能被随便泄露的状况中，这也需要全社会的更多的努力。</p>), BlAbout(aboutId=3, aboutTitle=hello, aboutRead=3, createdTime=Tue Oct 27 14:36:10 CST 2020, updateTime=Tue Oct 27 15:08:19 CST 2020, version=null, enable=0, deleted=null, aboutContent=你好(*´▽｀)ノノ)], params={}, sortColumn=about_read, sortMethod=asc)](String), 1(Integer), null, POST(String), 169(Long), {"code":20000,"data":{"currentPage":1,"index":0,"list":[{"aboutContent":"<p>最近，上海、天津等地出现个别疫情，也出现了将患者或相关人士的信息在网络上泄露，影响这些人的生活的事件。还有关于清华&ldquo;学姐&rdquo;在网络上的基于误会将一个男生的信息曝光的事件，更有一些快递公司&ldquo;内鬼&rdquo;泄露大量客户的详细信息的事件。这些其实都把个人隐私的保护上所出现的问题推到了前台。一方面确实接连出现那种个人隐私被泄露的事件，另一方面这些隐私的泄露所造成的实实在在的损害在这些例子中也都有充分的展现。</p>\n<p>个人隐私的保护，既是对于个人权利的尊重，也对于社会具有重要的意义。隐私的保护对于个体来说当然是重要的，因为个人的隐私的泄露当然会对个体由多方面的伤害，让个体的正常生活受到冲击和威胁。对于社会来说，个人的隐私的保护其实也是使社会生活更加安全的重要的保障。个人的隐私受到保护，既是在法律上十分清晰的，也是在伦理上极为必要的。这其实也是一个重要的社会底线。</p>\n<p>网络和大数据的发展使得个人的信息的搜集和处理都更加便捷和迅速。社会为了更便捷地运作和有效地运转，为了公众利益和为个体更好地服务，往往更多地搜集个人的多方面的资料，个人的资料为相关的方面所掌握在社会中也是必要的。但这当然不可能是无限度无底线的，这些其实都有法律的严格规定，也有伦理的基本的原则。实际上，这些界限其实是相当明确和清晰的。</p>\n<p>现在所出现的一些情况，就是完全违反了这些基本的限定，一些人随意地把他人的隐私信息在互联网这样的无远弗届的公共空间泄露。这种泄露造成的诸如&ldquo;网暴&rdquo;&ldquo;社交死亡&rdquo;等等现象现在在社会中已经成为的相当多的存在。个人的行为的许多不需要也不应该为公众广泛了解的一些情况，在被人们在公共空间中暴露，当然会对个人形成相当的伤害，也会让一些居心不良的人所利用，同时也会对于社会中的人们基本的安全的诉求构成冲击。</p>\n<p>有些人误解了基于&ldquo;公众利益&rdquo;的对于个人的信息的适度的披露和揭隐私、揭老底一类的恶俗行为的的关系，往往把过去小社区中的街谈巷议等等直接放到了所有人的公共空间的互联网上。也有人把&ldquo;群&rdquo;还是看成小圈子，小群体，传播有限，不知道实际上这种传播只要在网上，就可以是全社会的传播。有些接触一般人难以接触的资料的人，也并不觉得泄露这些是严重的事情。这其实和一些人缺少公共空间与私人生活的界限有关，也与当下的新的技术手段造成的便捷的传播有关。这些都构成了对于隐私的保护的冲击，这种冲击没有被有效制止，侵害隐私的行为没有得到惩戒和批评，就会产生&ldquo;示范效应&rdquo;，使得这样的情况一一发不可收拾，构成对于个人和社会的严重伤害。</p>\n<p>严格对于隐私保护的相关法律的执行，对于隐私保护的伦理要求也需要受到公众和社会的更多的维护。让人们生活在一个个人的隐私不能被随便泄露的状况中，这也需要全社会的更多的努力。</p>","aboutId":"1","aboutRead":1,"aboutTitle":"“社交死亡”现象越来越多 ，该如何保护个人隐私","createdTime":1603782451000,"enable":1,"updateTime":1606199712000},{"aboutContent":"你好(*´▽｀)ノノ","aboutId":"3","aboutRead":3,"aboutTitle":"hello","createdTime":1603780570000,"enable":0,"updateTime":1603782499000}],"pageSize":10,"params":{},"sortColumn":"about_read","sortMethod":"asc","totalCount":2,"totalPage":1},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:22:58.707 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:22:58.767 DEBUG [http-nio-8899-exec-8]com.tqk.blog.mapper.BlAboutMapper.getByPage.debug:159 -==>  Preparing: select about_id, about_title, about_read, about_content, created_time, update_time, enable from bl_about where deleted = 0 order by about_read desc limit ?, ? 
2020-12-24 23:22:58.769 DEBUG [http-nio-8899-exec-8]com.tqk.blog.mapper.BlAboutMapper.getByPage.debug:159 -==> Parameters: 0(Integer), 10(Integer)
2020-12-24 23:22:58.808 DEBUG [http-nio-8899-exec-8]com.tqk.blog.mapper.BlAboutMapper.getByPage.debug:159 -<==      Total: 2
2020-12-24 23:22:58.850 DEBUG [http-nio-8899-exec-8]com.tqk.blog.mapper.BlAboutMapper.getCountByPage.debug:159 -==>  Preparing: select count(*) from bl_about where deleted = 0 
2020-12-24 23:22:58.851 DEBUG [http-nio-8899-exec-8]com.tqk.blog.mapper.BlAboutMapper.getCountByPage.debug:159 -==> Parameters: 
2020-12-24 23:22:58.889 DEBUG [http-nio-8899-exec-8]com.tqk.blog.mapper.BlAboutMapper.getCountByPage.debug:159 -<==      Total: 1
2020-12-24 23:22:58.928 DEBUG [http-nio-8899-exec-8]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:22:58.930 DEBUG [http-nio-8899-exec-8]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /about/getByPage(String), [Page(currentPage=1, pageSize=10, totalPage=1, totalCount=2, list=[BlAbout(aboutId=1, aboutTitle=“社交死亡”现象越来越多 ，该如何保护个人隐私, aboutRead=1, createdTime=Tue Oct 27 15:07:31 CST 2020, updateTime=Tue Nov 24 14:35:12 CST 2020, version=null, enable=1, deleted=null, aboutContent=<p>最近，上海、天津等地出现个别疫情，也出现了将患者或相关人士的信息在网络上泄露，影响这些人的生活的事件。还有关于清华&ldquo;学姐&rdquo;在网络上的基于误会将一个男生的信息曝光的事件，更有一些快递公司&ldquo;内鬼&rdquo;泄露大量客户的详细信息的事件。这些其实都把个人隐私的保护上所出现的问题推到了前台。一方面确实接连出现那种个人隐私被泄露的事件，另一方面这些隐私的泄露所造成的实实在在的损害在这些例子中也都有充分的展现。</p>
<p>个人隐私的保护，既是对于个人权利的尊重，也对于社会具有重要的意义。隐私的保护对于个体来说当然是重要的，因为个人的隐私的泄露当然会对个体由多方面的伤害，让个体的正常生活受到冲击和威胁。对于社会来说，个人的隐私的保护其实也是使社会生活更加安全的重要的保障。个人的隐私受到保护，既是在法律上十分清晰的，也是在伦理上极为必要的。这其实也是一个重要的社会底线。</p>
<p>网络和大数据的发展使得个人的信息的搜集和处理都更加便捷和迅速。社会为了更便捷地运作和有效地运转，为了公众利益和为个体更好地服务，往往更多地搜集个人的多方面的资料，个人的资料为相关的方面所掌握在社会中也是必要的。但这当然不可能是无限度无底线的，这些其实都有法律的严格规定，也有伦理的基本的原则。实际上，这些界限其实是相当明确和清晰的。</p>
<p>现在所出现的一些情况，就是完全违反了这些基本的限定，一些人随意地把他人的隐私信息在互联网这样的无远弗届的公共空间泄露。这种泄露造成的诸如&ldquo;网暴&rdquo;&ldquo;社交死亡&rdquo;等等现象现在在社会中已经成为的相当多的存在。个人的行为的许多不需要也不应该为公众广泛了解的一些情况，在被人们在公共空间中暴露，当然会对个人形成相当的伤害，也会让一些居心不良的人所利用，同时也会对于社会中的人们基本的安全的诉求构成冲击。</p>
<p>有些人误解了基于&ldquo;公众利益&rdquo;的对于个人的信息的适度的披露和揭隐私、揭老底一类的恶俗行为的的关系，往往把过去小社区中的街谈巷议等等直接放到了所有人的公共空间的互联网上。也有人把&ldquo;群&rdquo;还是看成小圈子，小群体，传播有限，不知道实际上这种传播只要在网上，就可以是全社会的传播。有些接触一般人难以接触的资料的人，也并不觉得泄露这些是严重的事情。这其实和一些人缺少公共空间与私人生活的界限有关，也与当下的新的技术手段造成的便捷的传播有关。这些都构成了对于隐私的保护的冲击，这种冲击没有被有效制止，侵害隐私的行为没有得到惩戒和批评，就会产生&ldquo;示范效应&rdquo;，使得这样的情况一一发不可收拾，构成对于个人和社会的严重伤害。</p>
<p>严格对于隐私保护的相关法律的执行，对于隐私保护的伦理要求也需要受到公众和社会的更多的维护。让人们生活在一个个人的隐私不能被随便泄露的状况中，这也需要全社会的更多的努力。</p>), BlAbout(aboutId=3, aboutTitle=hello, aboutRead=3, createdTime=Tue Oct 27 14:36:10 CST 2020, updateTime=Tue Oct 27 15:08:19 CST 2020, version=null, enable=0, deleted=null, aboutContent=你好(*´▽｀)ノノ)], params={}, sortColumn=about_read, sortMethod=desc)](String), 1(Integer), null, POST(String), 164(Long), {"code":20000,"data":{"currentPage":1,"index":0,"list":[{"aboutContent":"你好(*´▽｀)ノノ","aboutId":"3","aboutRead":3,"aboutTitle":"hello","createdTime":1603780570000,"enable":0,"updateTime":1603782499000},{"aboutContent":"<p>最近，上海、天津等地出现个别疫情，也出现了将患者或相关人士的信息在网络上泄露，影响这些人的生活的事件。还有关于清华&ldquo;学姐&rdquo;在网络上的基于误会将一个男生的信息曝光的事件，更有一些快递公司&ldquo;内鬼&rdquo;泄露大量客户的详细信息的事件。这些其实都把个人隐私的保护上所出现的问题推到了前台。一方面确实接连出现那种个人隐私被泄露的事件，另一方面这些隐私的泄露所造成的实实在在的损害在这些例子中也都有充分的展现。</p>\n<p>个人隐私的保护，既是对于个人权利的尊重，也对于社会具有重要的意义。隐私的保护对于个体来说当然是重要的，因为个人的隐私的泄露当然会对个体由多方面的伤害，让个体的正常生活受到冲击和威胁。对于社会来说，个人的隐私的保护其实也是使社会生活更加安全的重要的保障。个人的隐私受到保护，既是在法律上十分清晰的，也是在伦理上极为必要的。这其实也是一个重要的社会底线。</p>\n<p>网络和大数据的发展使得个人的信息的搜集和处理都更加便捷和迅速。社会为了更便捷地运作和有效地运转，为了公众利益和为个体更好地服务，往往更多地搜集个人的多方面的资料，个人的资料为相关的方面所掌握在社会中也是必要的。但这当然不可能是无限度无底线的，这些其实都有法律的严格规定，也有伦理的基本的原则。实际上，这些界限其实是相当明确和清晰的。</p>\n<p>现在所出现的一些情况，就是完全违反了这些基本的限定，一些人随意地把他人的隐私信息在互联网这样的无远弗届的公共空间泄露。这种泄露造成的诸如&ldquo;网暴&rdquo;&ldquo;社交死亡&rdquo;等等现象现在在社会中已经成为的相当多的存在。个人的行为的许多不需要也不应该为公众广泛了解的一些情况，在被人们在公共空间中暴露，当然会对个人形成相当的伤害，也会让一些居心不良的人所利用，同时也会对于社会中的人们基本的安全的诉求构成冲击。</p>\n<p>有些人误解了基于&ldquo;公众利益&rdquo;的对于个人的信息的适度的披露和揭隐私、揭老底一类的恶俗行为的的关系，往往把过去小社区中的街谈巷议等等直接放到了所有人的公共空间的互联网上。也有人把&ldquo;群&rdquo;还是看成小圈子，小群体，传播有限，不知道实际上这种传播只要在网上，就可以是全社会的传播。有些接触一般人难以接触的资料的人，也并不觉得泄露这些是严重的事情。这其实和一些人缺少公共空间与私人生活的界限有关，也与当下的新的技术手段造成的便捷的传播有关。这些都构成了对于隐私的保护的冲击，这种冲击没有被有效制止，侵害隐私的行为没有得到惩戒和批评，就会产生&ldquo;示范效应&rdquo;，使得这样的情况一一发不可收拾，构成对于个人和社会的严重伤害。</p>\n<p>严格对于隐私保护的相关法律的执行，对于隐私保护的伦理要求也需要受到公众和社会的更多的维护。让人们生活在一个个人的隐私不能被随便泄露的状况中，这也需要全社会的更多的努力。</p>","aboutId":"1","aboutRead":1,"aboutTitle":"“社交死亡”现象越来越多 ，该如何保护个人隐私","createdTime":1603782451000,"enable":1,"updateTime":1606199712000}],"pageSize":10,"params":{},"sortColumn":"about_read","sortMethod":"desc","totalCount":2,"totalPage":1},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:22:59.009 DEBUG [http-nio-8899-exec-8]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:23:00.502 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlAboutMapper.getByPage.debug:159 -==>  Preparing: select about_id, about_title, about_read, about_content, created_time, update_time, enable from bl_about where deleted = 0 order by about_read asc limit ?, ? 
2020-12-24 23:23:00.503 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlAboutMapper.getByPage.debug:159 -==> Parameters: 0(Integer), 10(Integer)
2020-12-24 23:23:00.541 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlAboutMapper.getByPage.debug:159 -<==      Total: 2
2020-12-24 23:23:00.582 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlAboutMapper.getCountByPage.debug:159 -==>  Preparing: select count(*) from bl_about where deleted = 0 
2020-12-24 23:23:00.583 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlAboutMapper.getCountByPage.debug:159 -==> Parameters: 
2020-12-24 23:23:00.622 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlAboutMapper.getCountByPage.debug:159 -<==      Total: 1
2020-12-24 23:23:00.667 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:23:00.670 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /about/getByPage(String), [Page(currentPage=1, pageSize=10, totalPage=1, totalCount=2, list=[BlAbout(aboutId=3, aboutTitle=hello, aboutRead=3, createdTime=Tue Oct 27 14:36:10 CST 2020, updateTime=Tue Oct 27 15:08:19 CST 2020, version=null, enable=0, deleted=null, aboutContent=你好(*´▽｀)ノノ), BlAbout(aboutId=1, aboutTitle=“社交死亡”现象越来越多 ，该如何保护个人隐私, aboutRead=1, createdTime=Tue Oct 27 15:07:31 CST 2020, updateTime=Tue Nov 24 14:35:12 CST 2020, version=null, enable=1, deleted=null, aboutContent=<p>最近，上海、天津等地出现个别疫情，也出现了将患者或相关人士的信息在网络上泄露，影响这些人的生活的事件。还有关于清华&ldquo;学姐&rdquo;在网络上的基于误会将一个男生的信息曝光的事件，更有一些快递公司&ldquo;内鬼&rdquo;泄露大量客户的详细信息的事件。这些其实都把个人隐私的保护上所出现的问题推到了前台。一方面确实接连出现那种个人隐私被泄露的事件，另一方面这些隐私的泄露所造成的实实在在的损害在这些例子中也都有充分的展现。</p>
<p>个人隐私的保护，既是对于个人权利的尊重，也对于社会具有重要的意义。隐私的保护对于个体来说当然是重要的，因为个人的隐私的泄露当然会对个体由多方面的伤害，让个体的正常生活受到冲击和威胁。对于社会来说，个人的隐私的保护其实也是使社会生活更加安全的重要的保障。个人的隐私受到保护，既是在法律上十分清晰的，也是在伦理上极为必要的。这其实也是一个重要的社会底线。</p>
<p>网络和大数据的发展使得个人的信息的搜集和处理都更加便捷和迅速。社会为了更便捷地运作和有效地运转，为了公众利益和为个体更好地服务，往往更多地搜集个人的多方面的资料，个人的资料为相关的方面所掌握在社会中也是必要的。但这当然不可能是无限度无底线的，这些其实都有法律的严格规定，也有伦理的基本的原则。实际上，这些界限其实是相当明确和清晰的。</p>
<p>现在所出现的一些情况，就是完全违反了这些基本的限定，一些人随意地把他人的隐私信息在互联网这样的无远弗届的公共空间泄露。这种泄露造成的诸如&ldquo;网暴&rdquo;&ldquo;社交死亡&rdquo;等等现象现在在社会中已经成为的相当多的存在。个人的行为的许多不需要也不应该为公众广泛了解的一些情况，在被人们在公共空间中暴露，当然会对个人形成相当的伤害，也会让一些居心不良的人所利用，同时也会对于社会中的人们基本的安全的诉求构成冲击。</p>
<p>有些人误解了基于&ldquo;公众利益&rdquo;的对于个人的信息的适度的披露和揭隐私、揭老底一类的恶俗行为的的关系，往往把过去小社区中的街谈巷议等等直接放到了所有人的公共空间的互联网上。也有人把&ldquo;群&rdquo;还是看成小圈子，小群体，传播有限，不知道实际上这种传播只要在网上，就可以是全社会的传播。有些接触一般人难以接触的资料的人，也并不觉得泄露这些是严重的事情。这其实和一些人缺少公共空间与私人生活的界限有关，也与当下的新的技术手段造成的便捷的传播有关。这些都构成了对于隐私的保护的冲击，这种冲击没有被有效制止，侵害隐私的行为没有得到惩戒和批评，就会产生&ldquo;示范效应&rdquo;，使得这样的情况一一发不可收拾，构成对于个人和社会的严重伤害。</p>
<p>严格对于隐私保护的相关法律的执行，对于隐私保护的伦理要求也需要受到公众和社会的更多的维护。让人们生活在一个个人的隐私不能被随便泄露的状况中，这也需要全社会的更多的努力。</p>)], params={}, sortColumn=about_read, sortMethod=asc)](String), 1(Integer), null, POST(String), 165(Long), {"code":20000,"data":{"currentPage":1,"index":0,"list":[{"aboutContent":"<p>最近，上海、天津等地出现个别疫情，也出现了将患者或相关人士的信息在网络上泄露，影响这些人的生活的事件。还有关于清华&ldquo;学姐&rdquo;在网络上的基于误会将一个男生的信息曝光的事件，更有一些快递公司&ldquo;内鬼&rdquo;泄露大量客户的详细信息的事件。这些其实都把个人隐私的保护上所出现的问题推到了前台。一方面确实接连出现那种个人隐私被泄露的事件，另一方面这些隐私的泄露所造成的实实在在的损害在这些例子中也都有充分的展现。</p>\n<p>个人隐私的保护，既是对于个人权利的尊重，也对于社会具有重要的意义。隐私的保护对于个体来说当然是重要的，因为个人的隐私的泄露当然会对个体由多方面的伤害，让个体的正常生活受到冲击和威胁。对于社会来说，个人的隐私的保护其实也是使社会生活更加安全的重要的保障。个人的隐私受到保护，既是在法律上十分清晰的，也是在伦理上极为必要的。这其实也是一个重要的社会底线。</p>\n<p>网络和大数据的发展使得个人的信息的搜集和处理都更加便捷和迅速。社会为了更便捷地运作和有效地运转，为了公众利益和为个体更好地服务，往往更多地搜集个人的多方面的资料，个人的资料为相关的方面所掌握在社会中也是必要的。但这当然不可能是无限度无底线的，这些其实都有法律的严格规定，也有伦理的基本的原则。实际上，这些界限其实是相当明确和清晰的。</p>\n<p>现在所出现的一些情况，就是完全违反了这些基本的限定，一些人随意地把他人的隐私信息在互联网这样的无远弗届的公共空间泄露。这种泄露造成的诸如&ldquo;网暴&rdquo;&ldquo;社交死亡&rdquo;等等现象现在在社会中已经成为的相当多的存在。个人的行为的许多不需要也不应该为公众广泛了解的一些情况，在被人们在公共空间中暴露，当然会对个人形成相当的伤害，也会让一些居心不良的人所利用，同时也会对于社会中的人们基本的安全的诉求构成冲击。</p>\n<p>有些人误解了基于&ldquo;公众利益&rdquo;的对于个人的信息的适度的披露和揭隐私、揭老底一类的恶俗行为的的关系，往往把过去小社区中的街谈巷议等等直接放到了所有人的公共空间的互联网上。也有人把&ldquo;群&rdquo;还是看成小圈子，小群体，传播有限，不知道实际上这种传播只要在网上，就可以是全社会的传播。有些接触一般人难以接触的资料的人，也并不觉得泄露这些是严重的事情。这其实和一些人缺少公共空间与私人生活的界限有关，也与当下的新的技术手段造成的便捷的传播有关。这些都构成了对于隐私的保护的冲击，这种冲击没有被有效制止，侵害隐私的行为没有得到惩戒和批评，就会产生&ldquo;示范效应&rdquo;，使得这样的情况一一发不可收拾，构成对于个人和社会的严重伤害。</p>\n<p>严格对于隐私保护的相关法律的执行，对于隐私保护的伦理要求也需要受到公众和社会的更多的维护。让人们生活在一个个人的隐私不能被随便泄露的状况中，这也需要全社会的更多的努力。</p>","aboutId":"1","aboutRead":1,"aboutTitle":"“社交死亡”现象越来越多 ，该如何保护个人隐私","createdTime":1603782451000,"enable":1,"updateTime":1606199712000},{"aboutContent":"你好(*´▽｀)ノノ","aboutId":"3","aboutRead":3,"aboutTitle":"hello","createdTime":1603780570000,"enable":0,"updateTime":1603782499000}],"pageSize":10,"params":{},"sortColumn":"about_read","sortMethod":"asc","totalCount":2,"totalPage":1},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:23:00.750 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:23:20.220 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlUserMapper.getByPage.debug:159 -==>  Preparing: select user_id, username, name, sex, header, nickname, user_email, created_time, update_time from bl_user where deleted = 0 limit ?, ? 
2020-12-24 23:23:20.221 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlUserMapper.getByPage.debug:159 -==> Parameters: 0(Integer), 10(Integer)
2020-12-24 23:23:20.259 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlUserMapper.getByPage.debug:159 -<==      Total: 1
2020-12-24 23:23:20.302 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlUserMapper.getCountByPage.debug:159 -==>  Preparing: select count(*) from bl_user where deleted = 0 
2020-12-24 23:23:20.304 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlUserMapper.getCountByPage.debug:159 -==> Parameters: 
2020-12-24 23:23:20.341 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlUserMapper.getCountByPage.debug:159 -<==      Total: 1
2020-12-24 23:23:20.393 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:23:20.396 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /user/getByPage(String), [Page(currentPage=1, pageSize=10, totalPage=0, totalCount=0, list=[], params={}, sortColumn=null, sortMethod=asc)](String), 1(Integer), null, POST(String), 173(Long), {"code":20000,"data":{"currentPage":1,"index":0,"list":[{"createdTime":1603955993000,"header":"哈哈哈","name":"天气开","nickname":"一切皆文件","sex":1,"updateTime":1603955993000,"userEmail":"953811508@qq.com","userId":4,"username":"田起凯"}],"pageSize":10,"params":{},"sortMethod":"asc","totalCount":1,"totalPage":1},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:23:20.475 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:23:24.193 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlLogMapper.getByPage.debug:159 -==>  Preparing: select log_id, log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip, created_time from bl_log limit ?, ? 
2020-12-24 23:23:24.193 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlLogMapper.getByPage.debug:159 -==> Parameters: 0(Integer), 10(Integer)
2020-12-24 23:23:24.233 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlLogMapper.getByPage.debug:159 -<==      Total: 10
2020-12-24 23:23:24.272 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlLogMapper.getCountByPage.debug:159 -==>  Preparing: select count(*) from bl_log 
2020-12-24 23:23:24.273 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlLogMapper.getCountByPage.debug:159 -==> Parameters: 
2020-12-24 23:23:24.309 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlLogMapper.getCountByPage.debug:159 -<==      Total: 1
2020-12-24 23:23:24.360 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:23:24.363 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /log/getByPage(String), [Page(currentPage=1, pageSize=10, totalPage=0, totalCount=0, list=[], params={}, sortColumn=null, sortMethod=asc)](String), 1(Integer), null, POST(String), 159(Long), {"code":20000,"data":{"currentPage":1,"index":0,"list":[{"createdTime":1603177676000,"logId":22,"logIp":"0:0:0:0:0:0:0:1","logMethod":"GET","logParams":"[]","logResult":"\"hhhhhhhhhhhhh\"","logStatus":1,"logTime":14,"logUrl":"/BlAdmin/welcome"},{"createdTime":1603179396000,"logId":23,"logIp":"0:0:0:0:0:0:0:1","logMethod":"GET","logParams":"[]","logResult":"\"hhhhhhhhhhhhh\"","logStatus":1,"logTime":14,"logUrl":"/BlAdmin/welcome"},{"createdTime":1603179406000,"logId":24,"logIp":"0:0:0:0:0:0:0:1","logMethod":"GET","logParams":"[]","logResult":"\"hhhhhhhhhhhhh\"","logStatus":1,"logTime":6,"logUrl":"/BlAdmin/welcome"},{"createdTime":1603179407000,"logId":25,"logIp":"0:0:0:0:0:0:0:1","logMethod":"GET","logParams":"[]","logResult":"\"hhhhhhhhhhhhh\"","logStatus":1,"logTime":3,"logUrl":"/BlAdmin/welcome"},{"createdTime":1603179408000,"logId":26,"logIp":"0:0:0:0:0:0:0:1","logMethod":"GET","logParams":"[]","logResult":"\"hhhhhhhhhhhhh\"","logStatus":1,"logTime":4,"logUrl":"/BlAdmin/welcome"},{"createdTime":1603179411000,"logId":27,"logIp":"0:0:0:0:0:0:0:1","logMethod":"GET","logParams":"[]","logResult":"\"hhhhhhhhhhhhh\"","logStatus":1,"logTime":2,"logUrl":"/BlAdmin/welcome"},{"createdTime":1603179644000,"logId":28,"logIp":"0:0:0:0:0:0:0:1","logMethod":"GET","logParams":"[]","logResult":"\"hhhhhhhhhhhhh\"","logStatus":1,"logTime":14,"logUrl":"/BlAdmin/welcome"},{"createdTime":1603179649000,"logId":29,"logIp":"0:0:0:0:0:0:0:1","logMethod":"GET","logParams":"[]","logResult":"\"hhhhhhhhhhhhh\"","logStatus":1,"logTime":2,"logUrl":"/BlAdmin/welcome"},{"createdTime":1603179705000,"logId":30,"logIp":"0:0:0:0:0:0:0:1","logMethod":"GET","logParams":"[]","logResult":"\"hhhhhhhhhhhhh\"","logStatus":1,"logTime":16,"logUrl":"/BlAdmin/welcome"},{"createdTime":1603179730000,"logId":31,"logIp":"0:0:0:0:0:0:0:1","logMethod":"GET","logParams":"[]","logResult":"\"欢迎登陆莫兰迪酒店！\"","logStatus":1,"logTime":9,"logUrl":"/hotel/welcome"}],"pageSize":10,"params":{},"sortMethod":"asc","totalCount":648,"totalPage":65},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:23:24.446 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:23:27.229 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlMusicMapper.getByPage.debug:159 -==>  Preparing: select id, name, artist, url, cover, created_time, enable from bl_music where deleted = 0 limit ?, ? 
2020-12-24 23:23:27.230 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlMusicMapper.getByPage.debug:159 -==> Parameters: 0(Integer), 10(Integer)
2020-12-24 23:23:27.266 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlMusicMapper.getByPage.debug:159 -<==      Total: 2
2020-12-24 23:23:27.306 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlMusicMapper.getCountByPage.debug:159 -==>  Preparing: select count(*) from bl_music where deleted = 0 
2020-12-24 23:23:27.308 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlMusicMapper.getCountByPage.debug:159 -==> Parameters: 
2020-12-24 23:23:27.344 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlMusicMapper.getCountByPage.debug:159 -<==      Total: 1
2020-12-24 23:23:27.397 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:23:27.399 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /music/getByPage(String), [Page(currentPage=1, pageSize=10, totalPage=0, totalCount=0, list=[], params={}, sortColumn=null, sortMethod=asc)](String), 1(Integer), null, POST(String), 161(Long), {"code":20000,"data":{"currentPage":1,"index":0,"list":[{"artist":"乔伊·汉森","cover":"XXXX","createdTime":20201026231000,"enable":1,"id":2,"name":"Traveling Light","url":"I found my freedom now"},{"artist":"Music genius","cover":"词不达意","createdTime":20201026231000,"enable":0,"id":3,"name":"没有撤退可言","url":"I found my freedom now"}],"pageSize":10,"params":{},"sortMethod":"asc","totalCount":2,"totalPage":1},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:23:27.481 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:23:29.850 DEBUG [http-nio-8899-exec-4]com.tqk.blog.mapper.BlLinkMapper.getAll.debug:159 -==>  Preparing: select link_id, link_name, link_url, version from bl_link where deleted='0' 
2020-12-24 23:23:29.851 DEBUG [http-nio-8899-exec-4]com.tqk.blog.mapper.BlLinkMapper.getAll.debug:159 -==> Parameters: 
2020-12-24 23:23:29.886 DEBUG [http-nio-8899-exec-4]com.tqk.blog.mapper.BlLinkMapper.getAll.debug:159 -<==      Total: 1
2020-12-24 23:23:29.929 DEBUG [http-nio-8899-exec-4]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:23:29.930 DEBUG [http-nio-8899-exec-4]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /link/list(String), [](String), 1(Integer), null, GET(String), 238(Long), {"code":20000,"data":[{"linkId":1,"linkName":"百度一下","linkUrl":"https://baidu.com/","version":2}],"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:23:30.008 DEBUG [http-nio-8899-exec-4]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:26:46.301 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -==>  Preparing: select blog_id, blog_title, blog_image, blog_goods, blog_read, blog_collection, blog_remark, blog_comment, blog_source, created_time, update_time,type_name from bl_blog as b inner join bl_type as t on type_id = blog_type where t.deleted = 0 and b.deleted = 0 limit ?, ? 
2020-12-24 23:26:46.303 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -==> Parameters: 0(Integer), 10(Integer)
2020-12-24 23:26:46.342 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -<==      Total: 3
2020-12-24 23:26:46.343 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -==>  Preparing: select count(*) from bl_blog as b inner join bl_type as t on type_id = blog_type where t.deleted = 0 and b.deleted = 0 
2020-12-24 23:26:46.343 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -==> Parameters: 
2020-12-24 23:26:46.385 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -<==      Total: 1
2020-12-24 23:26:46.500 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:26:46.501 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/getByPage(String), [Page(currentPage=1, pageSize=10, totalPage=0, totalCount=0, list=[], params={}, sortColumn=null, sortMethod=asc)](String), 1(Integer), null, POST(String), 236(Long), {"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1324038097171820544","blogImage":"Java","blogRead":0,"blogRemark":"BeanUtils它提供了对java反射和自省API的包装。它里面还有很多工具类，这里我们介绍一下copyProperties。","blogSource":"百度","blogTitle":"BeanUtils.copyProperties的用法","createdTime":"2020-11-04 17:17:33","typeName":"Java","updateTime":"2020-11-22 13:04:15"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1330877080455553024","blogRead":0,"blogRemark":"MySQL","blogTitle":"面试官不讲武德问我：为什么MySQL不建议使用delete删除数据？","createdTime":"2020-11-23 14:13:16","typeName":"Java","updateTime":"2020-11-23 14:23:06"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1330879440221315072","blogRead":0,"blogRemark":"面试必备","blogTitle":"Java岗四面字节跳动成功之前，我都刷了那些面试题以及做了那些准备！","createdTime":"2020-11-23 14:22:39","typeName":"Java","updateTime":"2020-11-23 14:22:39"}],"pageSize":10,"params":{},"sortMethod":"asc","totalCount":3,"totalPage":1},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:26:46.583 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:26:57.981 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -==>  Preparing: select blog_id, blog_title, blog_image, blog_goods, blog_read, blog_collection, blog_remark, blog_comment, blog_source, created_time, update_time,type_name from bl_blog as b inner join bl_type as t on type_id = blog_type where t.deleted = 0 and b.deleted = 0 limit ?, ? 
2020-12-24 23:26:57.983 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -==> Parameters: 0(Integer), 10(Integer)
2020-12-24 23:26:58.024 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -<==      Total: 3
2020-12-24 23:26:58.026 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -==>  Preparing: select count(*) from bl_blog as b inner join bl_type as t on type_id = blog_type where t.deleted = 0 and b.deleted = 0 
2020-12-24 23:26:58.027 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -==> Parameters: 
2020-12-24 23:26:58.160 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -<==      Total: 1
2020-12-24 23:26:58.989 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:26:58.991 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/getByPage(String), [Page(currentPage=1, pageSize=10, totalPage=1, totalCount=3, list=[BlogVo(blogId=1324038097171820544, blogTitle=BeanUtils.copyProperties的用法, blogImage=Java, blogContent=null, blogGoods=0, blogRead=0, blogCollection=0, typeName=Java, blogSource=百度, blogRemark=BeanUtils它提供了对java反射和自省API的包装。它里面还有很多工具类，这里我们介绍一下copyProperties。, blogComment=0, blogMonth=null, createdTime=2020-11-04 17:17:33, updateTime=2020-11-22 13:04:15), BlogVo(blogId=1330877080455553024, blogTitle=面试官不讲武德问我：为什么MySQL不建议使用delete删除数据？, blogImage=null, blogContent=null, blogGoods=0, blogRead=0, blogCollection=0, typeName=Java, blogSource=null, blogRemark=MySQL, blogComment=0, blogMonth=null, createdTime=2020-11-23 14:13:16, updateTime=2020-11-23 14:23:06), BlogVo(blogId=1330879440221315072, blogTitle=Java岗四面字节跳动成功之前，我都刷了那些面试题以及做了那些准备！, blogImage=null, blogContent=null, blogGoods=0, blogRead=0, blogCollection=0, typeName=Java, blogSource=null, blogRemark=面试必备, blogComment=0, blogMonth=null, createdTime=2020-11-23 14:22:39, updateTime=2020-11-23 14:22:39)], params={}, sortColumn=null, sortMethod=asc)](String), 1(Integer), null, POST(String), 1544(Long), {"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1324038097171820544","blogImage":"Java","blogRead":0,"blogRemark":"BeanUtils它提供了对java反射和自省API的包装。它里面还有很多工具类，这里我们介绍一下copyProperties。","blogSource":"百度","blogTitle":"BeanUtils.copyProperties的用法","createdTime":"2020-11-04 17:17:33","typeName":"Java","updateTime":"2020-11-22 13:04:15"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1330877080455553024","blogRead":0,"blogRemark":"MySQL","blogTitle":"面试官不讲武德问我：为什么MySQL不建议使用delete删除数据？","createdTime":"2020-11-23 14:13:16","typeName":"Java","updateTime":"2020-11-23 14:23:06"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1330879440221315072","blogRead":0,"blogRemark":"面试必备","blogTitle":"Java岗四面字节跳动成功之前，我都刷了那些面试题以及做了那些准备！","createdTime":"2020-11-23 14:22:39","typeName":"Java","updateTime":"2020-11-23 14:22:39"}],"pageSize":10,"params":{},"sortMethod":"asc","totalCount":3,"totalPage":1},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:26:59.730 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:27:04.964 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==>  Preparing: select blog_id, blog_title, blog_content, blog_goods, blog_image, blog_read, blog_collection, blog_type, blog_remark, blog_comment, blog_source, created_time, version from bl_blog where blog_id = ? and deleted = 0 
2020-12-24 23:27:04.965 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==> Parameters: 1324038097171820544(String)
2020-12-24 23:27:05.007 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -<==      Total: 1
2020-12-24 23:27:05.063 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:27:05.066 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/get/1324038097171820544(String), [1324038097171820544](String), 1(Integer), null, GET(String), 91(Long), {"code":20000,"data":{"blogCollection":0,"blogComment":0,"blogContent":"BeanUtils.copyProperties(a, b);b中的存在的属性，a中一定要有，但是a中可以有多余的属性；a中与b中相同的属性都会被替换，不管是否有值；a、 b中的属性要名字相同，才能被赋值，不然的话需要手动赋值；Spring的BeanUtils的CopyProperties方法需要对应的属性有getter和setter方法；如果存在属性完全相同的内部类，但是不是同一个内部类，即分别属于各自的内部类，则spring会认为属性不同，不会copy；spring和apache的copy属性的方法源和目的参数的位置正好相反，所以导包和调用的时候都要注意一下。","blogGoods":0,"blogId":"1324038097171820544","blogImage":"Java","blogRead":0,"blogRemark":"BeanUtils它提供了对java反射和自省API的包装。它里面还有很多工具类，这里我们介绍一下copyProperties。","blogSource":"百度","blogTitle":"BeanUtils.copyProperties的用法","blogType":1,"createdTime":1604481453000,"version":2},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:27:05.146 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:27:15.718 DEBUG [http-nio-8899-exec-8]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==>  Preparing: select blog_id, blog_title, blog_content, blog_goods, blog_image, blog_read, blog_collection, blog_type, blog_remark, blog_comment, blog_source, created_time, version from bl_blog where blog_id = ? and deleted = 0 
2020-12-24 23:27:15.720 DEBUG [http-nio-8899-exec-8]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==> Parameters: 1324038097171820544(String)
2020-12-24 23:27:15.775 DEBUG [http-nio-8899-exec-8]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -<==      Total: 1
2020-12-24 23:27:15.823 DEBUG [http-nio-8899-exec-8]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:27:15.827 DEBUG [http-nio-8899-exec-8]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/get/1324038097171820544(String), [1324038097171820544](String), 1(Integer), null, GET(String), 174(Long), {"code":20000,"data":{"blogCollection":0,"blogComment":0,"blogContent":"BeanUtils.copyProperties(a, b);b中的存在的属性，a中一定要有，但是a中可以有多余的属性；a中与b中相同的属性都会被替换，不管是否有值；a、 b中的属性要名字相同，才能被赋值，不然的话需要手动赋值；Spring的BeanUtils的CopyProperties方法需要对应的属性有getter和setter方法；如果存在属性完全相同的内部类，但是不是同一个内部类，即分别属于各自的内部类，则spring会认为属性不同，不会copy；spring和apache的copy属性的方法源和目的参数的位置正好相反，所以导包和调用的时候都要注意一下。","blogGoods":0,"blogId":"1324038097171820544","blogImage":"Java","blogRead":0,"blogRemark":"BeanUtils它提供了对java反射和自省API的包装。它里面还有很多工具类，这里我们介绍一下copyProperties。","blogSource":"百度","blogTitle":"BeanUtils.copyProperties的用法","blogType":1,"createdTime":1604481453000,"version":2},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:27:15.910 DEBUG [http-nio-8899-exec-8]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:27:20.777 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==>  Preparing: select blog_id, blog_title, blog_content, blog_goods, blog_image, blog_read, blog_collection, blog_type, blog_remark, blog_comment, blog_source, created_time, version from bl_blog where blog_id = ? and deleted = 0 
2020-12-24 23:27:20.778 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==> Parameters: 1330877080455553024(String)
2020-12-24 23:27:21.284 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -<==      Total: 1
2020-12-24 23:27:21.457 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:27:21.466 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/get/1330877080455553024(String), [1330877080455553024](String), 1(Integer), null, GET(String), 612(Long), {"code":20000,"data":{"blogCollection":0,"blogComment":0,"blogContent":"<h2>前言</h2>\n<p>我负责的有几个系统随着业务量的增长，存储在MySQL中的数据日益剧增，我当时就想现在的业务方不讲武德，搞偷袭，趁我没反应过来把很多表，很快，很快啊都打到了亿级别，我大意了，没有闪，这就导致跟其Join的表的SQL变得很慢，对的应用接口的response time也变长了，影响了用户体验。</p>\n<p>事后我找到业务方，我批评了他们跟他们说要讲武德，连忙跟我道歉，这个事情才就此作罢，走的时候我对他们说下次不要这样了，耗子尾汁，好好反思。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/3c93aececcb9e763f5476362c4e88710.png\" alt=\"\" /></p>\n<p>骂归骂，事情还是得解决，时候我分析原因发现，发现有些表的数据量增长很快，对应SQL扫描了很多无效数据，导致SQL慢了下来，通过确认之后，这些大表都是一些流水、记录、日志类型数据，只需要保留1到3个月，此时需要对表做数据清理实现瘦身，一般都会想到用insert + delete的方式去清理。</p>\n<p>这篇文章我会从InnoDB存储空间分布，delete对性能的影响，以及优化建议方面解释为什么不建议delete删除数据。</p>\n<h2><a name=\"t1\"></a><a name=\"t1\"></a><a id=\"InnoDB_16\"></a>InnoDB存储架构</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/5c66ffe9749c58e1613d2519f7ea7211.png\" alt=\"\" /></p>\n<p>从这张图可以看到，InnoDB存储结构主要包括两部分：逻辑存储结构和物理存储结构。</p>\n<p>逻辑上是由表空间tablespace &mdash;&gt; 段segment或者inode &mdash;&gt; 区Extent &mdash;&mdash;&gt;数据页Page构成，Innodb逻辑管理单位是segment，空间分配的最小单位是extent，每个segment都会从表空间FREE_PAGE中分配32个page，当这32个page不够用时，会按照以下原则进行扩展：如果当前小于1个extent，则扩展到1个extent；当表空间小于32MB时，每次扩展一个extent；表空间大于32MB，每次扩展4个extent。</p>\n<p>物理上主要由系统用户数据文件，日志文件组成，数据文件主要存储MySQL字典数据和用户数据，日志文件记录的是data page的变更记录，用于MySQL Crash时的恢复。</p>\n<h2><a name=\"t2\"></a><a name=\"t2\"></a><a id=\"Innodb_26\"></a>Innodb表空间</h2>\n<p>InnoDB存储包括三类表空间：系统表空间，用户表空间，Undo表空间。</p>\n<p><strong>系统表空间：</strong>&nbsp;主要存储MySQL内部的数据字典数据，如information_schema下的数据。</p>\n<p><strong>用户表空间：</strong>&nbsp;当开启innodb_file_per_table=1时，数据表从系统表空间独立出来存储在以table_name.ibd命令的数据文件中，结构信息存储在table_name.frm文件中。</p>\n<p><strong>Undo表空间：</strong>&nbsp;存储Undo信息，如快照一致读和flashback都是利用undo信息。</p>\n<p>从MySQL 8.0开始允许用户自定义表空间，具体语法如下：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">CREATE TABLESPACE tablespace_name\n    ADD DATAFILE 'file_name'               #数据文件名\n    USE LOGFILE GROUP logfile_group        #自定义日志文件组，一般每组2个logfile。\n    [EXTENT_SIZE [=] extent_size]          #区大小\n    [INITIAL_SIZE [=] initial_size]        #初始化大小 \n    [AUTOEXTEND_SIZE [=] autoextend_size]  #自动扩宽尺寸\n    [MAX_SIZE [=] max_size]                #单个文件最大size，最大是32G。\n    [NODEGROUP [=] nodegroup_id]           #节点组\n    [WAIT]\n    [COMMENT [=] comment_text]\n    ENGINE [=] engine_name\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n</ul>\n<p>这样的好处是可以做到数据的冷热分离，分别用HDD和SSD来存储，既能实现数据的高效访问，又能节约成本，比如可以添加两块500G硬盘，经过创建卷组vg，划分逻辑卷lv，创建数据目录并mount相应的lv，假设划分的两个目录分别是/hot_data 和 /cold_data。</p>\n<p>这样就可以将核心的业务表如用户表，订单表存储在高性能SSD盘上，一些日志，流水表存储在普通的HDD上，主要的操作步骤如下：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#创建热数据表空间\ncreate tablespace tbs_data_hot add datafile '/hot_data/tbs_data_hot01.dbf' max_size 20G;\n#创建核心业务表存储在热数据表空间\ncreate table booking(id bigint not null primary key auto_increment, &hellip;&hellip; ) tablespace tbs_data_hot;\n#创建冷数据表空间\ncreate tablespace tbs_data_cold add datafile '/hot_data/tbs_data_cold01.dbf' max_size 20G;\n#创建日志，流水，备份类的表存储在冷数据表空间\ncreate table payment_log(id bigint not null primary key auto_increment, &hellip;&hellip; ) tablespace tbs_data_cold;\n#可以移动表到另一个表空间\nalter table payment_log tablespace tbs_data_hot;\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n</ul>\n<h2><a name=\"t3\"></a><a name=\"t3\"></a><a id=\"Inndob_69\"></a>Inndob存储分布</h2>\n<h3><a name=\"t4\"></a><a name=\"t4\"></a><a id=\"_71\"></a>创建空表查看空间变化</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; create table user(id bigint not null primary key auto_increment, \n    -&gt; name varchar(20) not null default '' comment '姓名', \n    -&gt; age tinyint not null default 0 comment 'age', \n    -&gt; gender char(1) not null default 'M'  comment '性别',\n    -&gt; phone varchar(16) not null default '' comment '手机号',\n    -&gt; create_time datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n    -&gt; update_time datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间'\n    -&gt; ) engine = InnoDB DEFAULT CHARSET=utf8mb4 COMMENT '用户信息表';\nQuery OK, 0 rows affected (0.26 sec)\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n</ul>\n<pre class=\"prettyprint\"><code class=\"prism language-bash has-numbering\"><span class=\"token comment\"># ls -lh user1.ibd </span>\n-rw-r----- 1 mysql mysql 96K Nov  6 12:48 user.ibd\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n</ul>\n<p>设置参数innodb_file_per_table=1时，创建表时会自动创建一个segment，同时分配一个extent，包含32个data page的来存储数据，这样创建的空表默认大小就是96KB，extent使用完之后会申请64个连接页，这样对于一些小表，或者undo segment，可以在开始时申请较少的空间，节省磁盘容量的开销。</p>\n<pre class=\"prettyprint\"><code class=\"prism language-shell has-numbering\"><span class=\"token comment\"># python2 py_innodb_page_info.py -v /data2/mysql/test/user.ibd</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>File Space Header<span class=\"token operator\">&gt;</span>\npage offset 00000001, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Insert Buffer Bitmap<span class=\"token operator\">&gt;</span>\npage offset 00000002, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>File Segment inode<span class=\"token operator\">&gt;</span>\npage offset 00000003, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>B-tree Node<span class=\"token operator\">&gt;</span>, page level <span class=\"token operator\">&lt;</span>0000<span class=\"token operator\">&gt;</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Freshly Allocated Page<span class=\"token operator\">&gt;</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Freshly Allocated Page<span class=\"token operator\">&gt;</span>\nTotal number of page: 6:      <span class=\"token comment\">#总共分配的页数</span>\nFreshly Allocated Page: 2     <span class=\"token comment\">#可用的数据页</span>\nInsert Buffer Bitmap: 1       <span class=\"token comment\">#插入缓冲页</span>\nFile Space Header: 1          <span class=\"token comment\">#文件空间头</span>\nB-tree Node: 1                <span class=\"token comment\">#数据页</span>\nFile Segment inode: 1         <span class=\"token comment\">#文件端inonde，如果是在ibdata1.ibd上会有多个inode。</span>\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n</ul>\n<h3><a name=\"t5\"></a><a name=\"t5\"></a><a id=\"_108\"></a>插入数据后的空间变化</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; DELIMITER $$\nmysql&gt; CREATE PROCEDURE insert_user_data(num INTEGER) \n    -&gt; BEGIN\n    -&gt;     DECLARE v_i int unsigned DEFAULT 0;\n    -&gt; set autocommit= 0;\n    -&gt; WHILE v_i &lt; num DO\n    -&gt;    insert into user(`name`, age, gender, phone) values (CONCAT('lyn',v_i), mod(v_i,120), 'M', CONCAT('152',ROUND(RAND(1)*100000000)));\n    -&gt;  SET v_i = v_i+1;\n    -&gt; END WHILE;\n    -&gt; commit;\n    -&gt; END $$\nQuery OK, 0 rows affected (0.01 sec)\nmysql&gt; DELIMITER ;\n\n#插入10w数据\nmysql&gt; call insert_user_data(100000);\nQuery OK, 0 rows affected (6.69 sec)\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n</ul>\n<pre class=\"prettyprint\"><code class=\"prism language-shell has-numbering\"><span class=\"token comment\"># ls -lh user.ibd</span>\n-rw-r----- 1 mysql mysql 14M Nov 6 10:58 /data2/mysql/test/user.ibd\n\n<span class=\"token comment\"># python2 py_innodb_page_info.py -v /data2/mysql/test/user.ibd</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>File Space Header<span class=\"token operator\">&gt;</span>\npage offset 00000001, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Insert Buffer Bitmap<span class=\"token operator\">&gt;</span>\npage offset 00000002, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>File Segment inode<span class=\"token operator\">&gt;</span>\npage offset 00000003, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>B-tree Node<span class=\"token operator\">&gt;</span>, page level <span class=\"token operator\">&lt;</span>0001<span class=\"token operator\">&gt;</span>   <span class=\"token comment\">#增加了一个非叶子节点，树的高度从1变为2.</span>\n<span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Freshly Allocated Page<span class=\"token operator\">&gt;</span>\nTotal number of page: 896:\nFreshly Allocated Page: 493\nInsert Buffer Bitmap: 1\nFile Space Header: 1\nB-tree Node: 400\nFile Segment inode: 1\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n</ul>\n<h3><a name=\"t6\"></a><a name=\"t6\"></a><a id=\"delete_149\"></a>delete数据后的空间变化</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; select min(id),max(id),count(*) from user;\n+---------+---------+----------+\n| min(id) | max(id) | count(*) |\n+---------+---------+----------+\n|       1 |  100000 |   100000 |\n+---------+---------+----------+\n1 row in set (0.05 sec)\n#删除50000条数据，理论上空间应该从14MB变长7MB左右。\nmysql&gt; delete from user limit 50000;\nQuery OK, 50000 rows affected (0.25 sec)\n\n#数据文件大小依然是14MB，没有缩小。\n# ls -lh /data2/mysql/test/user1.ibd \n-rw-r----- 1 mysql mysql 14M Nov  6 13:22 /data2/mysql/test/user.ibd\n\n#数据页没有被回收。\n# python2 py_innodb_page_info.py -v /data2/mysql/test/user.ibd\npage offset 00000000, page type &lt;File Space Header&gt;\npage offset 00000001, page type &lt;Insert Buffer Bitmap&gt;\npage offset 00000002, page type &lt;File Segment inode&gt;\npage offset 00000003, page type &lt;B-tree Node&gt;, page level &lt;0001&gt;\n........................................................\npage offset 00000000, page type &lt;Freshly Allocated Page&gt;\nTotal number of page: 896:\nFreshly Allocated Page: 493\nInsert Buffer Bitmap: 1\nFile Space Header: 1\nB-tree Node: 400\nFile Segment inode: 1\n#在MySQL内部是标记删除，\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n</ul>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; use information_schema;\n\nDatabase changed\nmysql&gt; SELECT A.SPACE AS TBL_SPACEID, A.TABLE_ID, A.NAME AS TABLE_NAME, FILE_FORMAT, ROW_FORMAT, SPACE_TYPE,  B.INDEX_ID , B.NAME AS INDEX_NAME, PAGE_NO, B.TYPE AS INDEX_TYPE FROM INNODB_SYS_TABLES A LEFT JOIN INNODB_SYS_INDEXES B ON A.TABLE_ID =B.TABLE_ID WHERE A.NAME = 'test/user1';\n+-------------+----------+------------+-------------+------------+------------+----------+------------+---------+------------+\n| TBL_SPACEID | TABLE_ID | TABLE_NAME | FILE_FORMAT | ROW_FORMAT | SPACE_TYPE | INDEX_ID | INDEX_NAME | PAGE_NO | INDEX_TYPE |\n+-------------+----------+------------+-------------+------------+------------+----------+------------+---------+------------+\n|        1283 |     1207 | test/user | Barracuda   | Dynamic    | Single     |     2236 | PRIMARY    |       3 |          3 |\n+-------------+----------+------------+-------------+------------+------------+----------+------------+---------+------------+\n1 row in set (0.01 sec)\n\nPAGE_NO = 3 标识B-tree的root page是3号页，INDEX_TYPE = 3是聚集索引。 INDEX_TYPE取值如下：\n0 = nonunique secondary index; \n1 = automatically generated clustered index (GEN_CLUST_INDEX); \n2 = unique nonclustered index; \n3 = clustered index; \n32 = full-text index;\n#收缩空间再后进行观察\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n</ul>\n<p>MySQL内部不会真正删除空间，而且做标记删除，即将delflag:N修改为delflag:Y，commit之后会会被purge进入删除链表，如果下一次insert更大的记录，delete之后的空间不会被重用，如果插入的记录小于等于delete的记录空会被重用，这块内容可以通过知数堂的innblock工具进行分析。</p>\n<h2><a name=\"t7\"></a><a name=\"t7\"></a><a id=\"Innodb_207\"></a>Innodb中的碎片</h2>\n<h3><a name=\"t8\"></a><a name=\"t8\"></a><a id=\"_209\"></a>碎片的产生</h3>\n<p>我们知道数据存储在文件系统上的，总是不能100%利用分配给它的物理空间，删除数据会在页面上留下一些&rdquo;空洞&rdquo;，或者随机写入（聚集索引非线性增加）会导致页分裂，页分裂导致页面的利用空间少于50%，另外对表进行增删改会引起对应的二级索引值的随机的增删改，也会导致索引结构中的数据页面上留下一些\"空洞\"，虽然这些空洞有可能会被重复利用，但终究会导致部分物理空间未被使用，也就是碎片。</p>\n<p>同时，即便是设置了填充因子为100%，Innodb也会主动留下page页面1/16的空间作为预留使用（An innodb_fill_factor setting of 100 leaves 1/16 of the space in clustered index pages free for future index growth）防止update带来的行溢出。</p>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; select table_schema,\n    -&gt;        table_name,ENGINE,\n    -&gt;        round(DATA_LENGTH/1024/1024+ INDEX_LENGTH/1024/1024) total_mb,TABLE_ROWS,\n    -&gt;        round(DATA_LENGTH/1024/1024) data_mb, round(INDEX_LENGTH/1024/1024) index_mb, round(DATA_FREE/1024/1024) free_mb, round(DATA_FREE/DATA_LENGTH*100,2) free_ratio\n    -&gt; from information_schema.TABLES where  TABLE_SCHEMA= 'test'\n    -&gt; and TABLE_NAME= 'user';\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n| table_schema | table_name | ENGINE | total_mb | TABLE_ROWS | data_mb | index_mb | free_mb | free_ratio |\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n| test         | user      | InnoDB |        4 |      50000 |       4 |        0 |       6 |     149.42 |\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n1 row in set (0.00 sec)\n\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n</ul>\n<p>其中data_free是分配了未使用的字节数，并不能说明完全是碎片空间。</p>\n<h3><a name=\"t9\"></a><a name=\"t9\"></a><a id=\"_233\"></a>碎片的回收</h3>\n<p>对于InnoDB的表，可以通过以下命令来回收碎片，释放空间，这个是随机读IO操作，会比较耗时，也会阻塞表上正常的DML运行，同时需要占用额外更多的磁盘空间，对于RDS来说，可能会导致磁盘空间瞬间爆满，实例瞬间被锁定，应用无法做DML操作，所以禁止在线上环境去执行。</p>\n<pre class=\"prettyprint\"><code class=\"prism language-shell has-numbering\"><span class=\"token comment\">#执行InnoDB的碎片回收</span>\nmysql<span class=\"token operator\">&gt;</span> alter table user engine<span class=\"token operator\">=</span>InnoDB<span class=\"token punctuation\">;</span>\nQuery OK, 0 rows affected <span class=\"token punctuation\">(</span>9.00 sec<span class=\"token punctuation\">)</span>\nRecords: 0  Duplicates: 0  Warnings: 0\n\n<span class=\"token comment\">##执行完之后，数据文件大小从14MB降低到10M。</span>\n<span class=\"token comment\"># ls -lh /data2/mysql/test/user1.ibd </span>\n-rw-r----- 1 mysql mysql 10M Nov 6 16:18 /data2/mysql/test/user.ibd\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n</ul>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; select table_schema,        table_name,ENGINE,        round(DATA_LENGTH/1024/1024+ INDEX_LENGTH/1024/1024) total_mb,TABLE_ROWS,        round(DATA_LENGTH/1024/1024) data_mb, round(INDEX_LENGTH/1024/1024) index_mb, round(DATA_FREE/1024/1024) free_mb, round(DATA_FREE/DATA_LENGTH*100,2) free_ratio from information_schema.TABLES where  TABLE_SCHEMA= 'test' and TABLE_NAME= 'user';\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n| table_schema | table_name | ENGINE | total_mb | TABLE_ROWS | data_mb | index_mb | free_mb | free_ratio |\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n| test         | user      | InnoDB |        5 |      50000 |       5 |        0 |       2 |      44.29 |\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n1 row in set (0.00 sec)\n\n\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n</ul>\n<h2><a name=\"t10\"></a><a name=\"t10\"></a><a id=\"deleteSQL_260\"></a>delete对SQL的影响</h2>\n<h3><a name=\"t11\"></a><a name=\"t11\"></a><a id=\"SQL_262\"></a>未删除前的SQL执行情况</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#插入100W数据\nmysql&gt; call insert_user_data(1000000);\nQuery OK, 0 rows affected (35.99 sec)\n\n#添加相关索引\nmysql&gt; alter table user add index idx_name(name), add index idx_phone(phone);\nQuery OK, 0 rows affected (6.00 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\n#表上索引统计信息\nmysql&gt; show index from user;\n+-------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+\n| Table | Non_unique | Key_name  | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |\n+-------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+\n| user  |          0 | PRIMARY   |            1 | id          | A         |      996757 |     NULL | NULL   |      | BTREE      |         |               |\n| user  |          1 | idx_name  |            1 | name        | A         |      996757 |     NULL | NULL   |      | BTREE      |         |               |\n| user  |          1 | idx_phone |            1 | phone       | A         |           2 |     NULL | NULL   |      | BTREE      |         |               |\n+-------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+\n3 rows in set (0.00 sec)\n\n#重置状态变量计数\nmysql&gt; flush status;\nQuery OK, 0 rows affected (0.00 sec)\n\n#执行SQL语句\nmysql&gt; select id, age ,phone from user where name like 'lyn12%';\n+--------+-----+-------------+\n| id     | age | phone       |\n+--------+-----+-------------+\n|    124 |   3 | 15240540354 |\n|   1231 |  30 | 15240540354 |\n|  12301 |  60 | 15240540354 |\n.............................\n| 129998 |  37 | 15240540354 |\n| 129999 |  38 | 15240540354 |\n| 130000 |  39 | 15240540354 |\n+--------+-----+-------------+\n11111 rows in set (0.03 sec)\n\nmysql&gt; explain select id, age ,phone from user where name like 'lyn12%';\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n| id | select_type | table | type  | possible_keys | key      | key_len | ref  | rows  | Extra                 |\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n|  1 | SIMPLE      | user  | range | idx_name      | idx_name | 82      | NULL | 22226 | Using index condition |\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n1 row in set (0.00 sec)\n\n#查看相关状态呢变量\nmysql&gt; select * from information_schema.session_status where variable_name in('Last_query_cost','Handler_read_next','Innodb_pages_read','Innodb_data_reads','Innodb_pages_read');\n+-------------------+----------------+\n| VARIABLE_NAME     | VARIABLE_VALUE |\n+-------------------+----------------+\n| HANDLER_READ_NEXT | 11111          |    #请求读的行数\n| INNODB_DATA_READS | 7868409        |    #数据物理读的总数\n| INNODB_PAGES_READ | 7855239        |    #逻辑读的总数\n| LAST_QUERY_COST   | 10.499000      |    #SQL语句的成本COST，主要包括IO_COST和CPU_COST。\n+-------------------+----------------+\n4 rows in set (0.00 sec)\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n<li>31</li>\n<li>32</li>\n<li>33</li>\n<li>34</li>\n<li>35</li>\n<li>36</li>\n<li>37</li>\n<li>38</li>\n<li>39</li>\n<li>40</li>\n<li>41</li>\n<li>42</li>\n<li>43</li>\n<li>44</li>\n<li>45</li>\n<li>46</li>\n<li>47</li>\n<li>48</li>\n<li>49</li>\n<li>50</li>\n<li>51</li>\n<li>52</li>\n<li>53</li>\n<li>54</li>\n<li>55</li>\n<li>56</li>\n<li>57</li>\n<li>58</li>\n</ul>\n<h3><a name=\"t12\"></a><a name=\"t12\"></a><a id=\"SQL_325\"></a>删除后的SQL执行情况</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#删除50w数据\nmysql&gt; delete from user limit 500000;\nQuery OK, 500000 rows affected (3.70 sec)\n\n#分析表统计信息\nmysql&gt; analyze table user;\n+-----------+---------+----------+----------+\n| Table     | Op      | Msg_type | Msg_text |\n+-----------+---------+----------+----------+\n| test.user | analyze | status   | OK       |\n+-----------+---------+----------+----------+\n1 row in set (0.01 sec)\n\n#重置状态变量计数\nmysql&gt; flush status;\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql&gt; select id, age ,phone from user where name like 'lyn12%';\nEmpty set (0.05 sec)\n\nmysql&gt; explain select id, age ,phone from user where name like 'lyn12%';\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n| id | select_type | table | type  | possible_keys | key      | key_len | ref  | rows  | Extra                 |\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n|  1 | SIMPLE      | user  | range | idx_name      | idx_name | 82      | NULL | 22226 | Using index condition |\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n1 row in set (0.00 sec)\n\nmysql&gt; select * from information_schema.session_status where variable_name in('Last_query_cost','Handler_read_next','Innodb_pages_read','Innodb_data_reads','Innodb_pages_read');\n+-------------------+----------------+\n| VARIABLE_NAME     | VARIABLE_VALUE |\n+-------------------+----------------+\n| HANDLER_READ_NEXT | 0              |\n| INNODB_DATA_READS | 7868409        |\n| INNODB_PAGES_READ | 7855239        |\n| LAST_QUERY_COST   | 10.499000      |\n+-------------------+----------------+\n4 rows in set (0.00 sec)\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n<li>31</li>\n<li>32</li>\n<li>33</li>\n<li>34</li>\n<li>35</li>\n<li>36</li>\n<li>37</li>\n<li>38</li>\n</ul>\n<h3><a name=\"t13\"></a><a name=\"t13\"></a><a id=\"_368\"></a>结果统计分析</h3>\n<div class=\"table-box\">\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>COST</th>\n<th>物理读次数</th>\n<th>逻辑读次数</th>\n<th>扫描行数</th>\n<th>返回行数</th>\n<th>执行时间</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>初始化插入100W</td>\n<td>10.499000</td>\n<td>7868409</td>\n<td>7855239</td>\n<td>22226</td>\n<td>11111</td>\n<td>30ms</td>\n</tr>\n<tr>\n<td>100W随机删除50W</td>\n<td>10.499000</td>\n<td>7868409</td>\n<td>7855239</td>\n<td>22226</td>\n<td>0</td>\n<td>50ms</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>这也说明对普通的大表，想要通过delete数据来对表进行瘦身是不现实的，所以在任何时候不要用delete去删除数据，应该使用优雅的标记删除。</p>\n<h2><a name=\"t14\"></a><a name=\"t14\"></a><a id=\"delete_377\"></a>delete优化建议</h2>\n<h3><a name=\"t15\"></a><a name=\"t15\"></a><a id=\"_379\"></a>控制业务账号权限</h3>\n<p>对于一个大的系统来说，需要根据业务特点去拆分子系统，每个子系统可以看做是一个service，例如美团APP，上面有很多服务，核心的服务有用户服务user-service，搜索服务search-service，商品product-service，位置服务location-service，价格服务price-service等。每个服务对应一个数据库，为该数据库创建单独账号，同时只授予DML权限且没有delete权限，同时禁止跨库访问。</p>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#创建用户数据库并授权\ncreate database mt_user charset utf8mb4;\ngrant USAGE, SELECT, INSERT, UPDATE ON mt_user.*  to 'w_user'@'%' identified by 't$W*g@gaHTGi123456';\nflush privileges;\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n</ul>\n<h3><a name=\"t16\"></a><a name=\"t16\"></a><a id=\"delete_390\"></a>delete改为标记删除</h3>\n<p>在MySQL数据库建模规范中有4个公共字段，基本上每个表必须有的，同时在create_time列要创建索引，有两方面的好处：</p>\n<ol>\n<li>一些查询业务场景都会有一个默认的时间段，比如7天或者一个月，都是通过create_time去过滤，走索引扫描更快。</li>\n<li>一些核心的业务表需要以T +1的方式抽取数据仓库中，比如每天晚上00:30抽取前一天的数据，都是通过create_time过滤的。</li>\n</ol>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">`id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键id',\n`is_deleted` tinyint(4) NOT NULL DEFAULT '0' COMMENT '是否逻辑删除：0：未删除，1：已删除',\n`create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n`update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间'\n\n#有了删除标记，业务接口的delete操作就可以转换为update\nupdate user set is_deleted = 1 where user_id = 1213;\n\n#查询的时候需要带上is_deleted过滤\nselect id, age ,phone from user where is_deleted = 0 and name like 'lyn12%';\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n</ul>\n<h2><a name=\"t17\"></a><a name=\"t17\"></a><a id=\"_410\"></a>数据归档方式</h2>\n<h3><a name=\"t18\"></a><a name=\"t18\"></a><a id=\"_412\"></a>通用数据归档方法</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#1. 创建归档表，一般在原表名后面添加_bak。\nCREATE TABLE `ota_order_bak` (\n  `id` bigint(11) NOT NULL AUTO_INCREMENT COMMENT '主键',\n  `order_id` varchar(255) DEFAULT NULL COMMENT '订单id',\n  `ota_id` varchar(255) DEFAULT NULL COMMENT 'ota',\n  `check_in_date` varchar(255) DEFAULT NULL COMMENT '入住日期',\n  `check_out_date` varchar(255) DEFAULT NULL COMMENT '离店日期',\n  `hotel_id` varchar(255) DEFAULT NULL COMMENT '酒店ID',\n  `guest_name` varchar(255) DEFAULT NULL COMMENT '顾客',\n  `purcharse_time` timestamp NULL DEFAULT NULL COMMENT '购买时间',\n  `create_time` datetime DEFAULT NULL,\n  `update_time` datetime DEFAULT NULL,\n  `create_user` varchar(255) DEFAULT NULL,\n  `update_user` varchar(255) DEFAULT NULL,\n  `status` int(4) DEFAULT '1' COMMENT '状态 ： 1 正常 ， 0 删除',\n  `hotel_name` varchar(255) DEFAULT NULL,\n  `price` decimal(10,0) DEFAULT NULL,\n  `remark` longtext,\n  PRIMARY KEY (`id`),\n  KEY `IDX_order_id` (`order_id`) USING BTREE,\n  KEY `hotel_name` (`hotel_name`) USING BTREE,\n  KEY `ota_id` (`ota_id`) USING BTREE,\n  KEY `IDX_purcharse_time` (`purcharse_time`) USING BTREE,\n  KEY `IDX_create_time` (`create_time`) USING BTREE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8\nPARTITION BY RANGE (to_days(create_time)) ( \nPARTITION p201808 VALUES LESS THAN (to_days('2018-09-01')), \nPARTITION p201809 VALUES LESS THAN (to_days('2018-10-01')), \nPARTITION p201810 VALUES LESS THAN (to_days('2018-11-01')), \nPARTITION p201811 VALUES LESS THAN (to_days('2018-12-01')), \nPARTITION p201812 VALUES LESS THAN (to_days('2019-01-01')), \nPARTITION p201901 VALUES LESS THAN (to_days('2019-02-01')), \nPARTITION p201902 VALUES LESS THAN (to_days('2019-03-01')), \nPARTITION p201903 VALUES LESS THAN (to_days('2019-04-01')), \nPARTITION p201904 VALUES LESS THAN (to_days('2019-05-01')), \nPARTITION p201905 VALUES LESS THAN (to_days('2019-06-01')), \nPARTITION p201906 VALUES LESS THAN (to_days('2019-07-01')), \nPARTITION p201907 VALUES LESS THAN (to_days('2019-08-01')), \nPARTITION p201908 VALUES LESS THAN (to_days('2019-09-01')), \nPARTITION p201909 VALUES LESS THAN (to_days('2019-10-01')), \nPARTITION p201910 VALUES LESS THAN (to_days('2019-11-01')), \nPARTITION p201911 VALUES LESS THAN (to_days('2019-12-01')), \nPARTITION p201912 VALUES LESS THAN (to_days('2020-01-01')));\n\n#2. 插入原表中无效的数据（需要跟开发同学确认数据保留范围）\ncreate table tbl_p201808 as select * from ota_order where create_time between '2018-08-01 00:00:00' and '2018-08-31 23:59:59';\n\n#3. 跟归档表分区做分区交换\nalter table ota_order_bak exchange partition p201808 with table tbl_p201808; \n\n#4. 删除原表中已经规范的数据\ndelete from ota_order where create_time between '2018-08-01 00:00:00' and '2018-08-31 23:59:59' limit 3000;\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n<li>31</li>\n<li>32</li>\n<li>33</li>\n<li>34</li>\n<li>35</li>\n<li>36</li>\n<li>37</li>\n<li>38</li>\n<li>39</li>\n<li>40</li>\n<li>41</li>\n<li>42</li>\n<li>43</li>\n<li>44</li>\n<li>45</li>\n<li>46</li>\n<li>47</li>\n<li>48</li>\n<li>49</li>\n<li>50</li>\n<li>51</li>\n<li>52</li>\n</ul>\n<h3><a name=\"t19\"></a><a name=\"t19\"></a><a id=\"_469\"></a>优化后的归档方式</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#1. 创建中间表\nCREATE TABLE `ota_order_2020` (........) ENGINE=InnoDB DEFAULT CHARSET=utf8\nPARTITION BY RANGE (to_days(create_time)) ( \nPARTITION p201808 VALUES LESS THAN (to_days('2018-09-01')), \nPARTITION p201809 VALUES LESS THAN (to_days('2018-10-01')), \nPARTITION p201810 VALUES LESS THAN (to_days('2018-11-01')), \nPARTITION p201811 VALUES LESS THAN (to_days('2018-12-01')), \nPARTITION p201812 VALUES LESS THAN (to_days('2019-01-01')), \nPARTITION p201901 VALUES LESS THAN (to_days('2019-02-01')), \nPARTITION p201902 VALUES LESS THAN (to_days('2019-03-01')), \nPARTITION p201903 VALUES LESS THAN (to_days('2019-04-01')), \nPARTITION p201904 VALUES LESS THAN (to_days('2019-05-01')), \nPARTITION p201905 VALUES LESS THAN (to_days('2019-06-01')), \nPARTITION p201906 VALUES LESS THAN (to_days('2019-07-01')), \nPARTITION p201907 VALUES LESS THAN (to_days('2019-08-01')), \nPARTITION p201908 VALUES LESS THAN (to_days('2019-09-01')), \nPARTITION p201909 VALUES LESS THAN (to_days('2019-10-01')), \nPARTITION p201910 VALUES LESS THAN (to_days('2019-11-01')), \nPARTITION p201911 VALUES LESS THAN (to_days('2019-12-01')), \nPARTITION p201912 VALUES LESS THAN (to_days('2020-01-01')));\n\n#2. 插入原表中有效的数据，如果数据量在100W左右可以在业务低峰期直接插入，如果比较大，建议采用dataX来做，可以控制频率和大小，之前我这边用Go封装了dataX可以实现自动生成json文件，自定义大小去执行。\ninsert into ota_order_2020 select * from ota_order where create_time between '2020-08-01 00:00:00' and '2020-08-31 23:59:59';\n\n#3. 表重命名\nalter table ota_order rename to ota_order_bak;  \nalter table ota_order_2020 rename to ota_order;\n#4. 插入差异数据\ninsert into ota_order select * from ota_order_bak a where not exists (select 1 from ota_order b where a.id = b.id);\n#5. ota_order_bak改造成分区表，如果表比较大不建议直接改造，可以先创建好分区表，通过dataX把导入进去即可。\n\n#6. 后续的归档方法\n#创建中间普遍表\ncreate table ota_order_mid like ota_order;\n#交换原表无效数据分区到普通表\nalter table ota_order exchange partition p201808 with table ota_order_mid; \n##交换普通表数据到归档表的相应分区\nalter table ota_order_bak exchange partition p201808 with table ota_order_mid; \n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n<li>31</li>\n<li>32</li>\n<li>33</li>\n<li>34</li>\n<li>35</li>\n<li>36</li>\n<li>37</li>\n<li>38</li>\n</ul>\n<p>这样原表和归档表都是按月的分区表，只需要创建一个中间普通表，在业务低峰期做两次分区交换，既可以删除无效数据，又能回收空，而且没有空间碎片，不会影响表上的索引及SQL的执行计划。</p>\n<h2><a name=\"t20\"></a><a name=\"t20\"></a><a id=\"_514\"></a>总结</h2>\n<p>通过从InnoDB存储空间分布，delete对性能的影响可以看到，delete物理删除既不能释放磁盘空间，而且会产生大量的碎片，导致索引频繁分裂，影响SQL执行计划的稳定性；</p>\n<p>同时在碎片回收时，会耗用大量的CPU，磁盘空间，影响表上正常的DML操作。</p>\n<p>在业务代码层面，应该做逻辑标记删除，避免物理删除；为了实现数据归档需求，可以用采用MySQL分区表特性来实现，都是DDL操作，没有碎片产生。</p>\n<p>另外一个比较好的方案采用Clickhouse，对有生命周期的数据表可以使用Clickhouse存储，利用其TTL特性实现无效数据自动清理。</p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1330877080455553024","blogRead":0,"blogRemark":"MySQL","blogTitle":"面试官不讲武德问我：为什么MySQL不建议使用delete删除数据？","blogType":1,"createdTime":1606111996000,"version":3},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:27:21.931 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:27:25.045 DEBUG [http-nio-8899-exec-10]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==>  Preparing: select blog_id, blog_title, blog_content, blog_goods, blog_image, blog_read, blog_collection, blog_type, blog_remark, blog_comment, blog_source, created_time, version from bl_blog where blog_id = ? and deleted = 0 
2020-12-24 23:27:25.046 DEBUG [http-nio-8899-exec-10]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==> Parameters: 1330877080455553024(String)
2020-12-24 23:27:25.721 DEBUG [http-nio-8899-exec-10]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -<==      Total: 1
2020-12-24 23:27:25.770 DEBUG [http-nio-8899-exec-10]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:27:25.779 DEBUG [http-nio-8899-exec-10]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/get/1330877080455553024(String), [1330877080455553024](String), 1(Integer), null, GET(String), 880(Long), {"code":20000,"data":{"blogCollection":0,"blogComment":0,"blogContent":"<h2>前言</h2>\n<p>我负责的有几个系统随着业务量的增长，存储在MySQL中的数据日益剧增，我当时就想现在的业务方不讲武德，搞偷袭，趁我没反应过来把很多表，很快，很快啊都打到了亿级别，我大意了，没有闪，这就导致跟其Join的表的SQL变得很慢，对的应用接口的response time也变长了，影响了用户体验。</p>\n<p>事后我找到业务方，我批评了他们跟他们说要讲武德，连忙跟我道歉，这个事情才就此作罢，走的时候我对他们说下次不要这样了，耗子尾汁，好好反思。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/3c93aececcb9e763f5476362c4e88710.png\" alt=\"\" /></p>\n<p>骂归骂，事情还是得解决，时候我分析原因发现，发现有些表的数据量增长很快，对应SQL扫描了很多无效数据，导致SQL慢了下来，通过确认之后，这些大表都是一些流水、记录、日志类型数据，只需要保留1到3个月，此时需要对表做数据清理实现瘦身，一般都会想到用insert + delete的方式去清理。</p>\n<p>这篇文章我会从InnoDB存储空间分布，delete对性能的影响，以及优化建议方面解释为什么不建议delete删除数据。</p>\n<h2><a name=\"t1\"></a><a name=\"t1\"></a><a id=\"InnoDB_16\"></a>InnoDB存储架构</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/5c66ffe9749c58e1613d2519f7ea7211.png\" alt=\"\" /></p>\n<p>从这张图可以看到，InnoDB存储结构主要包括两部分：逻辑存储结构和物理存储结构。</p>\n<p>逻辑上是由表空间tablespace &mdash;&gt; 段segment或者inode &mdash;&gt; 区Extent &mdash;&mdash;&gt;数据页Page构成，Innodb逻辑管理单位是segment，空间分配的最小单位是extent，每个segment都会从表空间FREE_PAGE中分配32个page，当这32个page不够用时，会按照以下原则进行扩展：如果当前小于1个extent，则扩展到1个extent；当表空间小于32MB时，每次扩展一个extent；表空间大于32MB，每次扩展4个extent。</p>\n<p>物理上主要由系统用户数据文件，日志文件组成，数据文件主要存储MySQL字典数据和用户数据，日志文件记录的是data page的变更记录，用于MySQL Crash时的恢复。</p>\n<h2><a name=\"t2\"></a><a name=\"t2\"></a><a id=\"Innodb_26\"></a>Innodb表空间</h2>\n<p>InnoDB存储包括三类表空间：系统表空间，用户表空间，Undo表空间。</p>\n<p><strong>系统表空间：</strong>&nbsp;主要存储MySQL内部的数据字典数据，如information_schema下的数据。</p>\n<p><strong>用户表空间：</strong>&nbsp;当开启innodb_file_per_table=1时，数据表从系统表空间独立出来存储在以table_name.ibd命令的数据文件中，结构信息存储在table_name.frm文件中。</p>\n<p><strong>Undo表空间：</strong>&nbsp;存储Undo信息，如快照一致读和flashback都是利用undo信息。</p>\n<p>从MySQL 8.0开始允许用户自定义表空间，具体语法如下：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">CREATE TABLESPACE tablespace_name\n    ADD DATAFILE 'file_name'               #数据文件名\n    USE LOGFILE GROUP logfile_group        #自定义日志文件组，一般每组2个logfile。\n    [EXTENT_SIZE [=] extent_size]          #区大小\n    [INITIAL_SIZE [=] initial_size]        #初始化大小 \n    [AUTOEXTEND_SIZE [=] autoextend_size]  #自动扩宽尺寸\n    [MAX_SIZE [=] max_size]                #单个文件最大size，最大是32G。\n    [NODEGROUP [=] nodegroup_id]           #节点组\n    [WAIT]\n    [COMMENT [=] comment_text]\n    ENGINE [=] engine_name\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n</ul>\n<p>这样的好处是可以做到数据的冷热分离，分别用HDD和SSD来存储，既能实现数据的高效访问，又能节约成本，比如可以添加两块500G硬盘，经过创建卷组vg，划分逻辑卷lv，创建数据目录并mount相应的lv，假设划分的两个目录分别是/hot_data 和 /cold_data。</p>\n<p>这样就可以将核心的业务表如用户表，订单表存储在高性能SSD盘上，一些日志，流水表存储在普通的HDD上，主要的操作步骤如下：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#创建热数据表空间\ncreate tablespace tbs_data_hot add datafile '/hot_data/tbs_data_hot01.dbf' max_size 20G;\n#创建核心业务表存储在热数据表空间\ncreate table booking(id bigint not null primary key auto_increment, &hellip;&hellip; ) tablespace tbs_data_hot;\n#创建冷数据表空间\ncreate tablespace tbs_data_cold add datafile '/hot_data/tbs_data_cold01.dbf' max_size 20G;\n#创建日志，流水，备份类的表存储在冷数据表空间\ncreate table payment_log(id bigint not null primary key auto_increment, &hellip;&hellip; ) tablespace tbs_data_cold;\n#可以移动表到另一个表空间\nalter table payment_log tablespace tbs_data_hot;\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n</ul>\n<h2><a name=\"t3\"></a><a name=\"t3\"></a><a id=\"Inndob_69\"></a>Inndob存储分布</h2>\n<h3><a name=\"t4\"></a><a name=\"t4\"></a><a id=\"_71\"></a>创建空表查看空间变化</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; create table user(id bigint not null primary key auto_increment, \n    -&gt; name varchar(20) not null default '' comment '姓名', \n    -&gt; age tinyint not null default 0 comment 'age', \n    -&gt; gender char(1) not null default 'M'  comment '性别',\n    -&gt; phone varchar(16) not null default '' comment '手机号',\n    -&gt; create_time datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n    -&gt; update_time datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间'\n    -&gt; ) engine = InnoDB DEFAULT CHARSET=utf8mb4 COMMENT '用户信息表';\nQuery OK, 0 rows affected (0.26 sec)\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n</ul>\n<pre class=\"prettyprint\"><code class=\"prism language-bash has-numbering\"><span class=\"token comment\"># ls -lh user1.ibd </span>\n-rw-r----- 1 mysql mysql 96K Nov  6 12:48 user.ibd\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n</ul>\n<p>设置参数innodb_file_per_table=1时，创建表时会自动创建一个segment，同时分配一个extent，包含32个data page的来存储数据，这样创建的空表默认大小就是96KB，extent使用完之后会申请64个连接页，这样对于一些小表，或者undo segment，可以在开始时申请较少的空间，节省磁盘容量的开销。</p>\n<pre class=\"prettyprint\"><code class=\"prism language-shell has-numbering\"><span class=\"token comment\"># python2 py_innodb_page_info.py -v /data2/mysql/test/user.ibd</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>File Space Header<span class=\"token operator\">&gt;</span>\npage offset 00000001, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Insert Buffer Bitmap<span class=\"token operator\">&gt;</span>\npage offset 00000002, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>File Segment inode<span class=\"token operator\">&gt;</span>\npage offset 00000003, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>B-tree Node<span class=\"token operator\">&gt;</span>, page level <span class=\"token operator\">&lt;</span>0000<span class=\"token operator\">&gt;</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Freshly Allocated Page<span class=\"token operator\">&gt;</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Freshly Allocated Page<span class=\"token operator\">&gt;</span>\nTotal number of page: 6:      <span class=\"token comment\">#总共分配的页数</span>\nFreshly Allocated Page: 2     <span class=\"token comment\">#可用的数据页</span>\nInsert Buffer Bitmap: 1       <span class=\"token comment\">#插入缓冲页</span>\nFile Space Header: 1          <span class=\"token comment\">#文件空间头</span>\nB-tree Node: 1                <span class=\"token comment\">#数据页</span>\nFile Segment inode: 1         <span class=\"token comment\">#文件端inonde，如果是在ibdata1.ibd上会有多个inode。</span>\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n</ul>\n<h3><a name=\"t5\"></a><a name=\"t5\"></a><a id=\"_108\"></a>插入数据后的空间变化</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; DELIMITER $$\nmysql&gt; CREATE PROCEDURE insert_user_data(num INTEGER) \n    -&gt; BEGIN\n    -&gt;     DECLARE v_i int unsigned DEFAULT 0;\n    -&gt; set autocommit= 0;\n    -&gt; WHILE v_i &lt; num DO\n    -&gt;    insert into user(`name`, age, gender, phone) values (CONCAT('lyn',v_i), mod(v_i,120), 'M', CONCAT('152',ROUND(RAND(1)*100000000)));\n    -&gt;  SET v_i = v_i+1;\n    -&gt; END WHILE;\n    -&gt; commit;\n    -&gt; END $$\nQuery OK, 0 rows affected (0.01 sec)\nmysql&gt; DELIMITER ;\n\n#插入10w数据\nmysql&gt; call insert_user_data(100000);\nQuery OK, 0 rows affected (6.69 sec)\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n</ul>\n<pre class=\"prettyprint\"><code class=\"prism language-shell has-numbering\"><span class=\"token comment\"># ls -lh user.ibd</span>\n-rw-r----- 1 mysql mysql 14M Nov 6 10:58 /data2/mysql/test/user.ibd\n\n<span class=\"token comment\"># python2 py_innodb_page_info.py -v /data2/mysql/test/user.ibd</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>File Space Header<span class=\"token operator\">&gt;</span>\npage offset 00000001, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Insert Buffer Bitmap<span class=\"token operator\">&gt;</span>\npage offset 00000002, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>File Segment inode<span class=\"token operator\">&gt;</span>\npage offset 00000003, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>B-tree Node<span class=\"token operator\">&gt;</span>, page level <span class=\"token operator\">&lt;</span>0001<span class=\"token operator\">&gt;</span>   <span class=\"token comment\">#增加了一个非叶子节点，树的高度从1变为2.</span>\n<span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Freshly Allocated Page<span class=\"token operator\">&gt;</span>\nTotal number of page: 896:\nFreshly Allocated Page: 493\nInsert Buffer Bitmap: 1\nFile Space Header: 1\nB-tree Node: 400\nFile Segment inode: 1\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n</ul>\n<h3><a name=\"t6\"></a><a name=\"t6\"></a><a id=\"delete_149\"></a>delete数据后的空间变化</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; select min(id),max(id),count(*) from user;\n+---------+---------+----------+\n| min(id) | max(id) | count(*) |\n+---------+---------+----------+\n|       1 |  100000 |   100000 |\n+---------+---------+----------+\n1 row in set (0.05 sec)\n#删除50000条数据，理论上空间应该从14MB变长7MB左右。\nmysql&gt; delete from user limit 50000;\nQuery OK, 50000 rows affected (0.25 sec)\n\n#数据文件大小依然是14MB，没有缩小。\n# ls -lh /data2/mysql/test/user1.ibd \n-rw-r----- 1 mysql mysql 14M Nov  6 13:22 /data2/mysql/test/user.ibd\n\n#数据页没有被回收。\n# python2 py_innodb_page_info.py -v /data2/mysql/test/user.ibd\npage offset 00000000, page type &lt;File Space Header&gt;\npage offset 00000001, page type &lt;Insert Buffer Bitmap&gt;\npage offset 00000002, page type &lt;File Segment inode&gt;\npage offset 00000003, page type &lt;B-tree Node&gt;, page level &lt;0001&gt;\n........................................................\npage offset 00000000, page type &lt;Freshly Allocated Page&gt;\nTotal number of page: 896:\nFreshly Allocated Page: 493\nInsert Buffer Bitmap: 1\nFile Space Header: 1\nB-tree Node: 400\nFile Segment inode: 1\n#在MySQL内部是标记删除，\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n</ul>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; use information_schema;\n\nDatabase changed\nmysql&gt; SELECT A.SPACE AS TBL_SPACEID, A.TABLE_ID, A.NAME AS TABLE_NAME, FILE_FORMAT, ROW_FORMAT, SPACE_TYPE,  B.INDEX_ID , B.NAME AS INDEX_NAME, PAGE_NO, B.TYPE AS INDEX_TYPE FROM INNODB_SYS_TABLES A LEFT JOIN INNODB_SYS_INDEXES B ON A.TABLE_ID =B.TABLE_ID WHERE A.NAME = 'test/user1';\n+-------------+----------+------------+-------------+------------+------------+----------+------------+---------+------------+\n| TBL_SPACEID | TABLE_ID | TABLE_NAME | FILE_FORMAT | ROW_FORMAT | SPACE_TYPE | INDEX_ID | INDEX_NAME | PAGE_NO | INDEX_TYPE |\n+-------------+----------+------------+-------------+------------+------------+----------+------------+---------+------------+\n|        1283 |     1207 | test/user | Barracuda   | Dynamic    | Single     |     2236 | PRIMARY    |       3 |          3 |\n+-------------+----------+------------+-------------+------------+------------+----------+------------+---------+------------+\n1 row in set (0.01 sec)\n\nPAGE_NO = 3 标识B-tree的root page是3号页，INDEX_TYPE = 3是聚集索引。 INDEX_TYPE取值如下：\n0 = nonunique secondary index; \n1 = automatically generated clustered index (GEN_CLUST_INDEX); \n2 = unique nonclustered index; \n3 = clustered index; \n32 = full-text index;\n#收缩空间再后进行观察\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n</ul>\n<p>MySQL内部不会真正删除空间，而且做标记删除，即将delflag:N修改为delflag:Y，commit之后会会被purge进入删除链表，如果下一次insert更大的记录，delete之后的空间不会被重用，如果插入的记录小于等于delete的记录空会被重用，这块内容可以通过知数堂的innblock工具进行分析。</p>\n<h2><a name=\"t7\"></a><a name=\"t7\"></a><a id=\"Innodb_207\"></a>Innodb中的碎片</h2>\n<h3><a name=\"t8\"></a><a name=\"t8\"></a><a id=\"_209\"></a>碎片的产生</h3>\n<p>我们知道数据存储在文件系统上的，总是不能100%利用分配给它的物理空间，删除数据会在页面上留下一些&rdquo;空洞&rdquo;，或者随机写入（聚集索引非线性增加）会导致页分裂，页分裂导致页面的利用空间少于50%，另外对表进行增删改会引起对应的二级索引值的随机的增删改，也会导致索引结构中的数据页面上留下一些\"空洞\"，虽然这些空洞有可能会被重复利用，但终究会导致部分物理空间未被使用，也就是碎片。</p>\n<p>同时，即便是设置了填充因子为100%，Innodb也会主动留下page页面1/16的空间作为预留使用（An innodb_fill_factor setting of 100 leaves 1/16 of the space in clustered index pages free for future index growth）防止update带来的行溢出。</p>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; select table_schema,\n    -&gt;        table_name,ENGINE,\n    -&gt;        round(DATA_LENGTH/1024/1024+ INDEX_LENGTH/1024/1024) total_mb,TABLE_ROWS,\n    -&gt;        round(DATA_LENGTH/1024/1024) data_mb, round(INDEX_LENGTH/1024/1024) index_mb, round(DATA_FREE/1024/1024) free_mb, round(DATA_FREE/DATA_LENGTH*100,2) free_ratio\n    -&gt; from information_schema.TABLES where  TABLE_SCHEMA= 'test'\n    -&gt; and TABLE_NAME= 'user';\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n| table_schema | table_name | ENGINE | total_mb | TABLE_ROWS | data_mb | index_mb | free_mb | free_ratio |\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n| test         | user      | InnoDB |        4 |      50000 |       4 |        0 |       6 |     149.42 |\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n1 row in set (0.00 sec)\n\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n</ul>\n<p>其中data_free是分配了未使用的字节数，并不能说明完全是碎片空间。</p>\n<h3><a name=\"t9\"></a><a name=\"t9\"></a><a id=\"_233\"></a>碎片的回收</h3>\n<p>对于InnoDB的表，可以通过以下命令来回收碎片，释放空间，这个是随机读IO操作，会比较耗时，也会阻塞表上正常的DML运行，同时需要占用额外更多的磁盘空间，对于RDS来说，可能会导致磁盘空间瞬间爆满，实例瞬间被锁定，应用无法做DML操作，所以禁止在线上环境去执行。</p>\n<pre class=\"prettyprint\"><code class=\"prism language-shell has-numbering\"><span class=\"token comment\">#执行InnoDB的碎片回收</span>\nmysql<span class=\"token operator\">&gt;</span> alter table user engine<span class=\"token operator\">=</span>InnoDB<span class=\"token punctuation\">;</span>\nQuery OK, 0 rows affected <span class=\"token punctuation\">(</span>9.00 sec<span class=\"token punctuation\">)</span>\nRecords: 0  Duplicates: 0  Warnings: 0\n\n<span class=\"token comment\">##执行完之后，数据文件大小从14MB降低到10M。</span>\n<span class=\"token comment\"># ls -lh /data2/mysql/test/user1.ibd </span>\n-rw-r----- 1 mysql mysql 10M Nov 6 16:18 /data2/mysql/test/user.ibd\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n</ul>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; select table_schema,        table_name,ENGINE,        round(DATA_LENGTH/1024/1024+ INDEX_LENGTH/1024/1024) total_mb,TABLE_ROWS,        round(DATA_LENGTH/1024/1024) data_mb, round(INDEX_LENGTH/1024/1024) index_mb, round(DATA_FREE/1024/1024) free_mb, round(DATA_FREE/DATA_LENGTH*100,2) free_ratio from information_schema.TABLES where  TABLE_SCHEMA= 'test' and TABLE_NAME= 'user';\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n| table_schema | table_name | ENGINE | total_mb | TABLE_ROWS | data_mb | index_mb | free_mb | free_ratio |\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n| test         | user      | InnoDB |        5 |      50000 |       5 |        0 |       2 |      44.29 |\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n1 row in set (0.00 sec)\n\n\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n</ul>\n<h2><a name=\"t10\"></a><a name=\"t10\"></a><a id=\"deleteSQL_260\"></a>delete对SQL的影响</h2>\n<h3><a name=\"t11\"></a><a name=\"t11\"></a><a id=\"SQL_262\"></a>未删除前的SQL执行情况</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#插入100W数据\nmysql&gt; call insert_user_data(1000000);\nQuery OK, 0 rows affected (35.99 sec)\n\n#添加相关索引\nmysql&gt; alter table user add index idx_name(name), add index idx_phone(phone);\nQuery OK, 0 rows affected (6.00 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\n#表上索引统计信息\nmysql&gt; show index from user;\n+-------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+\n| Table | Non_unique | Key_name  | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |\n+-------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+\n| user  |          0 | PRIMARY   |            1 | id          | A         |      996757 |     NULL | NULL   |      | BTREE      |         |               |\n| user  |          1 | idx_name  |            1 | name        | A         |      996757 |     NULL | NULL   |      | BTREE      |         |               |\n| user  |          1 | idx_phone |            1 | phone       | A         |           2 |     NULL | NULL   |      | BTREE      |         |               |\n+-------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+\n3 rows in set (0.00 sec)\n\n#重置状态变量计数\nmysql&gt; flush status;\nQuery OK, 0 rows affected (0.00 sec)\n\n#执行SQL语句\nmysql&gt; select id, age ,phone from user where name like 'lyn12%';\n+--------+-----+-------------+\n| id     | age | phone       |\n+--------+-----+-------------+\n|    124 |   3 | 15240540354 |\n|   1231 |  30 | 15240540354 |\n|  12301 |  60 | 15240540354 |\n.............................\n| 129998 |  37 | 15240540354 |\n| 129999 |  38 | 15240540354 |\n| 130000 |  39 | 15240540354 |\n+--------+-----+-------------+\n11111 rows in set (0.03 sec)\n\nmysql&gt; explain select id, age ,phone from user where name like 'lyn12%';\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n| id | select_type | table | type  | possible_keys | key      | key_len | ref  | rows  | Extra                 |\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n|  1 | SIMPLE      | user  | range | idx_name      | idx_name | 82      | NULL | 22226 | Using index condition |\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n1 row in set (0.00 sec)\n\n#查看相关状态呢变量\nmysql&gt; select * from information_schema.session_status where variable_name in('Last_query_cost','Handler_read_next','Innodb_pages_read','Innodb_data_reads','Innodb_pages_read');\n+-------------------+----------------+\n| VARIABLE_NAME     | VARIABLE_VALUE |\n+-------------------+----------------+\n| HANDLER_READ_NEXT | 11111          |    #请求读的行数\n| INNODB_DATA_READS | 7868409        |    #数据物理读的总数\n| INNODB_PAGES_READ | 7855239        |    #逻辑读的总数\n| LAST_QUERY_COST   | 10.499000      |    #SQL语句的成本COST，主要包括IO_COST和CPU_COST。\n+-------------------+----------------+\n4 rows in set (0.00 sec)\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n<li>31</li>\n<li>32</li>\n<li>33</li>\n<li>34</li>\n<li>35</li>\n<li>36</li>\n<li>37</li>\n<li>38</li>\n<li>39</li>\n<li>40</li>\n<li>41</li>\n<li>42</li>\n<li>43</li>\n<li>44</li>\n<li>45</li>\n<li>46</li>\n<li>47</li>\n<li>48</li>\n<li>49</li>\n<li>50</li>\n<li>51</li>\n<li>52</li>\n<li>53</li>\n<li>54</li>\n<li>55</li>\n<li>56</li>\n<li>57</li>\n<li>58</li>\n</ul>\n<h3><a name=\"t12\"></a><a name=\"t12\"></a><a id=\"SQL_325\"></a>删除后的SQL执行情况</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#删除50w数据\nmysql&gt; delete from user limit 500000;\nQuery OK, 500000 rows affected (3.70 sec)\n\n#分析表统计信息\nmysql&gt; analyze table user;\n+-----------+---------+----------+----------+\n| Table     | Op      | Msg_type | Msg_text |\n+-----------+---------+----------+----------+\n| test.user | analyze | status   | OK       |\n+-----------+---------+----------+----------+\n1 row in set (0.01 sec)\n\n#重置状态变量计数\nmysql&gt; flush status;\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql&gt; select id, age ,phone from user where name like 'lyn12%';\nEmpty set (0.05 sec)\n\nmysql&gt; explain select id, age ,phone from user where name like 'lyn12%';\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n| id | select_type | table | type  | possible_keys | key      | key_len | ref  | rows  | Extra                 |\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n|  1 | SIMPLE      | user  | range | idx_name      | idx_name | 82      | NULL | 22226 | Using index condition |\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n1 row in set (0.00 sec)\n\nmysql&gt; select * from information_schema.session_status where variable_name in('Last_query_cost','Handler_read_next','Innodb_pages_read','Innodb_data_reads','Innodb_pages_read');\n+-------------------+----------------+\n| VARIABLE_NAME     | VARIABLE_VALUE |\n+-------------------+----------------+\n| HANDLER_READ_NEXT | 0              |\n| INNODB_DATA_READS | 7868409        |\n| INNODB_PAGES_READ | 7855239        |\n| LAST_QUERY_COST   | 10.499000      |\n+-------------------+----------------+\n4 rows in set (0.00 sec)\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n<li>31</li>\n<li>32</li>\n<li>33</li>\n<li>34</li>\n<li>35</li>\n<li>36</li>\n<li>37</li>\n<li>38</li>\n</ul>\n<h3><a name=\"t13\"></a><a name=\"t13\"></a><a id=\"_368\"></a>结果统计分析</h3>\n<div class=\"table-box\">\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>COST</th>\n<th>物理读次数</th>\n<th>逻辑读次数</th>\n<th>扫描行数</th>\n<th>返回行数</th>\n<th>执行时间</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>初始化插入100W</td>\n<td>10.499000</td>\n<td>7868409</td>\n<td>7855239</td>\n<td>22226</td>\n<td>11111</td>\n<td>30ms</td>\n</tr>\n<tr>\n<td>100W随机删除50W</td>\n<td>10.499000</td>\n<td>7868409</td>\n<td>7855239</td>\n<td>22226</td>\n<td>0</td>\n<td>50ms</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>这也说明对普通的大表，想要通过delete数据来对表进行瘦身是不现实的，所以在任何时候不要用delete去删除数据，应该使用优雅的标记删除。</p>\n<h2><a name=\"t14\"></a><a name=\"t14\"></a><a id=\"delete_377\"></a>delete优化建议</h2>\n<h3><a name=\"t15\"></a><a name=\"t15\"></a><a id=\"_379\"></a>控制业务账号权限</h3>\n<p>对于一个大的系统来说，需要根据业务特点去拆分子系统，每个子系统可以看做是一个service，例如美团APP，上面有很多服务，核心的服务有用户服务user-service，搜索服务search-service，商品product-service，位置服务location-service，价格服务price-service等。每个服务对应一个数据库，为该数据库创建单独账号，同时只授予DML权限且没有delete权限，同时禁止跨库访问。</p>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#创建用户数据库并授权\ncreate database mt_user charset utf8mb4;\ngrant USAGE, SELECT, INSERT, UPDATE ON mt_user.*  to 'w_user'@'%' identified by 't$W*g@gaHTGi123456';\nflush privileges;\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n</ul>\n<h3><a name=\"t16\"></a><a name=\"t16\"></a><a id=\"delete_390\"></a>delete改为标记删除</h3>\n<p>在MySQL数据库建模规范中有4个公共字段，基本上每个表必须有的，同时在create_time列要创建索引，有两方面的好处：</p>\n<ol>\n<li>一些查询业务场景都会有一个默认的时间段，比如7天或者一个月，都是通过create_time去过滤，走索引扫描更快。</li>\n<li>一些核心的业务表需要以T +1的方式抽取数据仓库中，比如每天晚上00:30抽取前一天的数据，都是通过create_time过滤的。</li>\n</ol>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">`id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键id',\n`is_deleted` tinyint(4) NOT NULL DEFAULT '0' COMMENT '是否逻辑删除：0：未删除，1：已删除',\n`create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n`update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间'\n\n#有了删除标记，业务接口的delete操作就可以转换为update\nupdate user set is_deleted = 1 where user_id = 1213;\n\n#查询的时候需要带上is_deleted过滤\nselect id, age ,phone from user where is_deleted = 0 and name like 'lyn12%';\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n</ul>\n<h2><a name=\"t17\"></a><a name=\"t17\"></a><a id=\"_410\"></a>数据归档方式</h2>\n<h3><a name=\"t18\"></a><a name=\"t18\"></a><a id=\"_412\"></a>通用数据归档方法</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#1. 创建归档表，一般在原表名后面添加_bak。\nCREATE TABLE `ota_order_bak` (\n  `id` bigint(11) NOT NULL AUTO_INCREMENT COMMENT '主键',\n  `order_id` varchar(255) DEFAULT NULL COMMENT '订单id',\n  `ota_id` varchar(255) DEFAULT NULL COMMENT 'ota',\n  `check_in_date` varchar(255) DEFAULT NULL COMMENT '入住日期',\n  `check_out_date` varchar(255) DEFAULT NULL COMMENT '离店日期',\n  `hotel_id` varchar(255) DEFAULT NULL COMMENT '酒店ID',\n  `guest_name` varchar(255) DEFAULT NULL COMMENT '顾客',\n  `purcharse_time` timestamp NULL DEFAULT NULL COMMENT '购买时间',\n  `create_time` datetime DEFAULT NULL,\n  `update_time` datetime DEFAULT NULL,\n  `create_user` varchar(255) DEFAULT NULL,\n  `update_user` varchar(255) DEFAULT NULL,\n  `status` int(4) DEFAULT '1' COMMENT '状态 ： 1 正常 ， 0 删除',\n  `hotel_name` varchar(255) DEFAULT NULL,\n  `price` decimal(10,0) DEFAULT NULL,\n  `remark` longtext,\n  PRIMARY KEY (`id`),\n  KEY `IDX_order_id` (`order_id`) USING BTREE,\n  KEY `hotel_name` (`hotel_name`) USING BTREE,\n  KEY `ota_id` (`ota_id`) USING BTREE,\n  KEY `IDX_purcharse_time` (`purcharse_time`) USING BTREE,\n  KEY `IDX_create_time` (`create_time`) USING BTREE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8\nPARTITION BY RANGE (to_days(create_time)) ( \nPARTITION p201808 VALUES LESS THAN (to_days('2018-09-01')), \nPARTITION p201809 VALUES LESS THAN (to_days('2018-10-01')), \nPARTITION p201810 VALUES LESS THAN (to_days('2018-11-01')), \nPARTITION p201811 VALUES LESS THAN (to_days('2018-12-01')), \nPARTITION p201812 VALUES LESS THAN (to_days('2019-01-01')), \nPARTITION p201901 VALUES LESS THAN (to_days('2019-02-01')), \nPARTITION p201902 VALUES LESS THAN (to_days('2019-03-01')), \nPARTITION p201903 VALUES LESS THAN (to_days('2019-04-01')), \nPARTITION p201904 VALUES LESS THAN (to_days('2019-05-01')), \nPARTITION p201905 VALUES LESS THAN (to_days('2019-06-01')), \nPARTITION p201906 VALUES LESS THAN (to_days('2019-07-01')), \nPARTITION p201907 VALUES LESS THAN (to_days('2019-08-01')), \nPARTITION p201908 VALUES LESS THAN (to_days('2019-09-01')), \nPARTITION p201909 VALUES LESS THAN (to_days('2019-10-01')), \nPARTITION p201910 VALUES LESS THAN (to_days('2019-11-01')), \nPARTITION p201911 VALUES LESS THAN (to_days('2019-12-01')), \nPARTITION p201912 VALUES LESS THAN (to_days('2020-01-01')));\n\n#2. 插入原表中无效的数据（需要跟开发同学确认数据保留范围）\ncreate table tbl_p201808 as select * from ota_order where create_time between '2018-08-01 00:00:00' and '2018-08-31 23:59:59';\n\n#3. 跟归档表分区做分区交换\nalter table ota_order_bak exchange partition p201808 with table tbl_p201808; \n\n#4. 删除原表中已经规范的数据\ndelete from ota_order where create_time between '2018-08-01 00:00:00' and '2018-08-31 23:59:59' limit 3000;\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n<li>31</li>\n<li>32</li>\n<li>33</li>\n<li>34</li>\n<li>35</li>\n<li>36</li>\n<li>37</li>\n<li>38</li>\n<li>39</li>\n<li>40</li>\n<li>41</li>\n<li>42</li>\n<li>43</li>\n<li>44</li>\n<li>45</li>\n<li>46</li>\n<li>47</li>\n<li>48</li>\n<li>49</li>\n<li>50</li>\n<li>51</li>\n<li>52</li>\n</ul>\n<h3><a name=\"t19\"></a><a name=\"t19\"></a><a id=\"_469\"></a>优化后的归档方式</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#1. 创建中间表\nCREATE TABLE `ota_order_2020` (........) ENGINE=InnoDB DEFAULT CHARSET=utf8\nPARTITION BY RANGE (to_days(create_time)) ( \nPARTITION p201808 VALUES LESS THAN (to_days('2018-09-01')), \nPARTITION p201809 VALUES LESS THAN (to_days('2018-10-01')), \nPARTITION p201810 VALUES LESS THAN (to_days('2018-11-01')), \nPARTITION p201811 VALUES LESS THAN (to_days('2018-12-01')), \nPARTITION p201812 VALUES LESS THAN (to_days('2019-01-01')), \nPARTITION p201901 VALUES LESS THAN (to_days('2019-02-01')), \nPARTITION p201902 VALUES LESS THAN (to_days('2019-03-01')), \nPARTITION p201903 VALUES LESS THAN (to_days('2019-04-01')), \nPARTITION p201904 VALUES LESS THAN (to_days('2019-05-01')), \nPARTITION p201905 VALUES LESS THAN (to_days('2019-06-01')), \nPARTITION p201906 VALUES LESS THAN (to_days('2019-07-01')), \nPARTITION p201907 VALUES LESS THAN (to_days('2019-08-01')), \nPARTITION p201908 VALUES LESS THAN (to_days('2019-09-01')), \nPARTITION p201909 VALUES LESS THAN (to_days('2019-10-01')), \nPARTITION p201910 VALUES LESS THAN (to_days('2019-11-01')), \nPARTITION p201911 VALUES LESS THAN (to_days('2019-12-01')), \nPARTITION p201912 VALUES LESS THAN (to_days('2020-01-01')));\n\n#2. 插入原表中有效的数据，如果数据量在100W左右可以在业务低峰期直接插入，如果比较大，建议采用dataX来做，可以控制频率和大小，之前我这边用Go封装了dataX可以实现自动生成json文件，自定义大小去执行。\ninsert into ota_order_2020 select * from ota_order where create_time between '2020-08-01 00:00:00' and '2020-08-31 23:59:59';\n\n#3. 表重命名\nalter table ota_order rename to ota_order_bak;  \nalter table ota_order_2020 rename to ota_order;\n#4. 插入差异数据\ninsert into ota_order select * from ota_order_bak a where not exists (select 1 from ota_order b where a.id = b.id);\n#5. ota_order_bak改造成分区表，如果表比较大不建议直接改造，可以先创建好分区表，通过dataX把导入进去即可。\n\n#6. 后续的归档方法\n#创建中间普遍表\ncreate table ota_order_mid like ota_order;\n#交换原表无效数据分区到普通表\nalter table ota_order exchange partition p201808 with table ota_order_mid; \n##交换普通表数据到归档表的相应分区\nalter table ota_order_bak exchange partition p201808 with table ota_order_mid; \n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n<li>31</li>\n<li>32</li>\n<li>33</li>\n<li>34</li>\n<li>35</li>\n<li>36</li>\n<li>37</li>\n<li>38</li>\n</ul>\n<p>这样原表和归档表都是按月的分区表，只需要创建一个中间普通表，在业务低峰期做两次分区交换，既可以删除无效数据，又能回收空，而且没有空间碎片，不会影响表上的索引及SQL的执行计划。</p>\n<h2><a name=\"t20\"></a><a name=\"t20\"></a><a id=\"_514\"></a>总结</h2>\n<p>通过从InnoDB存储空间分布，delete对性能的影响可以看到，delete物理删除既不能释放磁盘空间，而且会产生大量的碎片，导致索引频繁分裂，影响SQL执行计划的稳定性；</p>\n<p>同时在碎片回收时，会耗用大量的CPU，磁盘空间，影响表上正常的DML操作。</p>\n<p>在业务代码层面，应该做逻辑标记删除，避免物理删除；为了实现数据归档需求，可以用采用MySQL分区表特性来实现，都是DDL操作，没有碎片产生。</p>\n<p>另外一个比较好的方案采用Clickhouse，对有生命周期的数据表可以使用Clickhouse存储，利用其TTL特性实现无效数据自动清理。</p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1330877080455553024","blogRead":0,"blogRemark":"MySQL","blogTitle":"面试官不讲武德问我：为什么MySQL不建议使用delete删除数据？","blogType":1,"createdTime":1606111996000,"version":3},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:27:26.079 DEBUG [http-nio-8899-exec-10]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:27:41.596 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==>  Preparing: select blog_id, blog_title, blog_content, blog_goods, blog_image, blog_read, blog_collection, blog_type, blog_remark, blog_comment, blog_source, created_time, version from bl_blog where blog_id = ? and deleted = 0 
2020-12-24 23:27:41.597 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==> Parameters: 1330877080455553024(String)
2020-12-24 23:27:41.759 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -<==      Total: 1
2020-12-24 23:27:41.803 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:27:41.806 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/get/1330877080455553024(String), [1330877080455553024](String), 1(Integer), null, GET(String), 205(Long), {"code":20000,"data":{"blogCollection":0,"blogComment":0,"blogContent":"<h2>前言</h2>\n<p>我负责的有几个系统随着业务量的增长，存储在MySQL中的数据日益剧增，我当时就想现在的业务方不讲武德，搞偷袭，趁我没反应过来把很多表，很快，很快啊都打到了亿级别，我大意了，没有闪，这就导致跟其Join的表的SQL变得很慢，对的应用接口的response time也变长了，影响了用户体验。</p>\n<p>事后我找到业务方，我批评了他们跟他们说要讲武德，连忙跟我道歉，这个事情才就此作罢，走的时候我对他们说下次不要这样了，耗子尾汁，好好反思。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/3c93aececcb9e763f5476362c4e88710.png\" alt=\"\" /></p>\n<p>骂归骂，事情还是得解决，时候我分析原因发现，发现有些表的数据量增长很快，对应SQL扫描了很多无效数据，导致SQL慢了下来，通过确认之后，这些大表都是一些流水、记录、日志类型数据，只需要保留1到3个月，此时需要对表做数据清理实现瘦身，一般都会想到用insert + delete的方式去清理。</p>\n<p>这篇文章我会从InnoDB存储空间分布，delete对性能的影响，以及优化建议方面解释为什么不建议delete删除数据。</p>\n<h2><a name=\"t1\"></a><a name=\"t1\"></a><a id=\"InnoDB_16\"></a>InnoDB存储架构</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/5c66ffe9749c58e1613d2519f7ea7211.png\" alt=\"\" /></p>\n<p>从这张图可以看到，InnoDB存储结构主要包括两部分：逻辑存储结构和物理存储结构。</p>\n<p>逻辑上是由表空间tablespace &mdash;&gt; 段segment或者inode &mdash;&gt; 区Extent &mdash;&mdash;&gt;数据页Page构成，Innodb逻辑管理单位是segment，空间分配的最小单位是extent，每个segment都会从表空间FREE_PAGE中分配32个page，当这32个page不够用时，会按照以下原则进行扩展：如果当前小于1个extent，则扩展到1个extent；当表空间小于32MB时，每次扩展一个extent；表空间大于32MB，每次扩展4个extent。</p>\n<p>物理上主要由系统用户数据文件，日志文件组成，数据文件主要存储MySQL字典数据和用户数据，日志文件记录的是data page的变更记录，用于MySQL Crash时的恢复。</p>\n<h2><a name=\"t2\"></a><a name=\"t2\"></a><a id=\"Innodb_26\"></a>Innodb表空间</h2>\n<p>InnoDB存储包括三类表空间：系统表空间，用户表空间，Undo表空间。</p>\n<p><strong>系统表空间：</strong>&nbsp;主要存储MySQL内部的数据字典数据，如information_schema下的数据。</p>\n<p><strong>用户表空间：</strong>&nbsp;当开启innodb_file_per_table=1时，数据表从系统表空间独立出来存储在以table_name.ibd命令的数据文件中，结构信息存储在table_name.frm文件中。</p>\n<p><strong>Undo表空间：</strong>&nbsp;存储Undo信息，如快照一致读和flashback都是利用undo信息。</p>\n<p>从MySQL 8.0开始允许用户自定义表空间，具体语法如下：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">CREATE TABLESPACE tablespace_name\n    ADD DATAFILE 'file_name'               #数据文件名\n    USE LOGFILE GROUP logfile_group        #自定义日志文件组，一般每组2个logfile。\n    [EXTENT_SIZE [=] extent_size]          #区大小\n    [INITIAL_SIZE [=] initial_size]        #初始化大小 \n    [AUTOEXTEND_SIZE [=] autoextend_size]  #自动扩宽尺寸\n    [MAX_SIZE [=] max_size]                #单个文件最大size，最大是32G。\n    [NODEGROUP [=] nodegroup_id]           #节点组\n    [WAIT]\n    [COMMENT [=] comment_text]\n    ENGINE [=] engine_name\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n</ul>\n<p>这样的好处是可以做到数据的冷热分离，分别用HDD和SSD来存储，既能实现数据的高效访问，又能节约成本，比如可以添加两块500G硬盘，经过创建卷组vg，划分逻辑卷lv，创建数据目录并mount相应的lv，假设划分的两个目录分别是/hot_data 和 /cold_data。</p>\n<p>这样就可以将核心的业务表如用户表，订单表存储在高性能SSD盘上，一些日志，流水表存储在普通的HDD上，主要的操作步骤如下：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#创建热数据表空间\ncreate tablespace tbs_data_hot add datafile '/hot_data/tbs_data_hot01.dbf' max_size 20G;\n#创建核心业务表存储在热数据表空间\ncreate table booking(id bigint not null primary key auto_increment, &hellip;&hellip; ) tablespace tbs_data_hot;\n#创建冷数据表空间\ncreate tablespace tbs_data_cold add datafile '/hot_data/tbs_data_cold01.dbf' max_size 20G;\n#创建日志，流水，备份类的表存储在冷数据表空间\ncreate table payment_log(id bigint not null primary key auto_increment, &hellip;&hellip; ) tablespace tbs_data_cold;\n#可以移动表到另一个表空间\nalter table payment_log tablespace tbs_data_hot;\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n</ul>\n<h2><a name=\"t3\"></a><a name=\"t3\"></a><a id=\"Inndob_69\"></a>Inndob存储分布</h2>\n<h3><a name=\"t4\"></a><a name=\"t4\"></a><a id=\"_71\"></a>创建空表查看空间变化</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; create table user(id bigint not null primary key auto_increment, \n    -&gt; name varchar(20) not null default '' comment '姓名', \n    -&gt; age tinyint not null default 0 comment 'age', \n    -&gt; gender char(1) not null default 'M'  comment '性别',\n    -&gt; phone varchar(16) not null default '' comment '手机号',\n    -&gt; create_time datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n    -&gt; update_time datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间'\n    -&gt; ) engine = InnoDB DEFAULT CHARSET=utf8mb4 COMMENT '用户信息表';\nQuery OK, 0 rows affected (0.26 sec)\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n</ul>\n<pre class=\"prettyprint\"><code class=\"prism language-bash has-numbering\"><span class=\"token comment\"># ls -lh user1.ibd </span>\n-rw-r----- 1 mysql mysql 96K Nov  6 12:48 user.ibd\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n</ul>\n<p>设置参数innodb_file_per_table=1时，创建表时会自动创建一个segment，同时分配一个extent，包含32个data page的来存储数据，这样创建的空表默认大小就是96KB，extent使用完之后会申请64个连接页，这样对于一些小表，或者undo segment，可以在开始时申请较少的空间，节省磁盘容量的开销。</p>\n<pre class=\"prettyprint\"><code class=\"prism language-shell has-numbering\"><span class=\"token comment\"># python2 py_innodb_page_info.py -v /data2/mysql/test/user.ibd</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>File Space Header<span class=\"token operator\">&gt;</span>\npage offset 00000001, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Insert Buffer Bitmap<span class=\"token operator\">&gt;</span>\npage offset 00000002, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>File Segment inode<span class=\"token operator\">&gt;</span>\npage offset 00000003, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>B-tree Node<span class=\"token operator\">&gt;</span>, page level <span class=\"token operator\">&lt;</span>0000<span class=\"token operator\">&gt;</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Freshly Allocated Page<span class=\"token operator\">&gt;</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Freshly Allocated Page<span class=\"token operator\">&gt;</span>\nTotal number of page: 6:      <span class=\"token comment\">#总共分配的页数</span>\nFreshly Allocated Page: 2     <span class=\"token comment\">#可用的数据页</span>\nInsert Buffer Bitmap: 1       <span class=\"token comment\">#插入缓冲页</span>\nFile Space Header: 1          <span class=\"token comment\">#文件空间头</span>\nB-tree Node: 1                <span class=\"token comment\">#数据页</span>\nFile Segment inode: 1         <span class=\"token comment\">#文件端inonde，如果是在ibdata1.ibd上会有多个inode。</span>\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n</ul>\n<h3><a name=\"t5\"></a><a name=\"t5\"></a><a id=\"_108\"></a>插入数据后的空间变化</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; DELIMITER $$\nmysql&gt; CREATE PROCEDURE insert_user_data(num INTEGER) \n    -&gt; BEGIN\n    -&gt;     DECLARE v_i int unsigned DEFAULT 0;\n    -&gt; set autocommit= 0;\n    -&gt; WHILE v_i &lt; num DO\n    -&gt;    insert into user(`name`, age, gender, phone) values (CONCAT('lyn',v_i), mod(v_i,120), 'M', CONCAT('152',ROUND(RAND(1)*100000000)));\n    -&gt;  SET v_i = v_i+1;\n    -&gt; END WHILE;\n    -&gt; commit;\n    -&gt; END $$\nQuery OK, 0 rows affected (0.01 sec)\nmysql&gt; DELIMITER ;\n\n#插入10w数据\nmysql&gt; call insert_user_data(100000);\nQuery OK, 0 rows affected (6.69 sec)\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n</ul>\n<pre class=\"prettyprint\"><code class=\"prism language-shell has-numbering\"><span class=\"token comment\"># ls -lh user.ibd</span>\n-rw-r----- 1 mysql mysql 14M Nov 6 10:58 /data2/mysql/test/user.ibd\n\n<span class=\"token comment\"># python2 py_innodb_page_info.py -v /data2/mysql/test/user.ibd</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>File Space Header<span class=\"token operator\">&gt;</span>\npage offset 00000001, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Insert Buffer Bitmap<span class=\"token operator\">&gt;</span>\npage offset 00000002, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>File Segment inode<span class=\"token operator\">&gt;</span>\npage offset 00000003, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>B-tree Node<span class=\"token operator\">&gt;</span>, page level <span class=\"token operator\">&lt;</span>0001<span class=\"token operator\">&gt;</span>   <span class=\"token comment\">#增加了一个非叶子节点，树的高度从1变为2.</span>\n<span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Freshly Allocated Page<span class=\"token operator\">&gt;</span>\nTotal number of page: 896:\nFreshly Allocated Page: 493\nInsert Buffer Bitmap: 1\nFile Space Header: 1\nB-tree Node: 400\nFile Segment inode: 1\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n</ul>\n<h3><a name=\"t6\"></a><a name=\"t6\"></a><a id=\"delete_149\"></a>delete数据后的空间变化</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; select min(id),max(id),count(*) from user;\n+---------+---------+----------+\n| min(id) | max(id) | count(*) |\n+---------+---------+----------+\n|       1 |  100000 |   100000 |\n+---------+---------+----------+\n1 row in set (0.05 sec)\n#删除50000条数据，理论上空间应该从14MB变长7MB左右。\nmysql&gt; delete from user limit 50000;\nQuery OK, 50000 rows affected (0.25 sec)\n\n#数据文件大小依然是14MB，没有缩小。\n# ls -lh /data2/mysql/test/user1.ibd \n-rw-r----- 1 mysql mysql 14M Nov  6 13:22 /data2/mysql/test/user.ibd\n\n#数据页没有被回收。\n# python2 py_innodb_page_info.py -v /data2/mysql/test/user.ibd\npage offset 00000000, page type &lt;File Space Header&gt;\npage offset 00000001, page type &lt;Insert Buffer Bitmap&gt;\npage offset 00000002, page type &lt;File Segment inode&gt;\npage offset 00000003, page type &lt;B-tree Node&gt;, page level &lt;0001&gt;\n........................................................\npage offset 00000000, page type &lt;Freshly Allocated Page&gt;\nTotal number of page: 896:\nFreshly Allocated Page: 493\nInsert Buffer Bitmap: 1\nFile Space Header: 1\nB-tree Node: 400\nFile Segment inode: 1\n#在MySQL内部是标记删除，\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n</ul>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; use information_schema;\n\nDatabase changed\nmysql&gt; SELECT A.SPACE AS TBL_SPACEID, A.TABLE_ID, A.NAME AS TABLE_NAME, FILE_FORMAT, ROW_FORMAT, SPACE_TYPE,  B.INDEX_ID , B.NAME AS INDEX_NAME, PAGE_NO, B.TYPE AS INDEX_TYPE FROM INNODB_SYS_TABLES A LEFT JOIN INNODB_SYS_INDEXES B ON A.TABLE_ID =B.TABLE_ID WHERE A.NAME = 'test/user1';\n+-------------+----------+------------+-------------+------------+------------+----------+------------+---------+------------+\n| TBL_SPACEID | TABLE_ID | TABLE_NAME | FILE_FORMAT | ROW_FORMAT | SPACE_TYPE | INDEX_ID | INDEX_NAME | PAGE_NO | INDEX_TYPE |\n+-------------+----------+------------+-------------+------------+------------+----------+------------+---------+------------+\n|        1283 |     1207 | test/user | Barracuda   | Dynamic    | Single     |     2236 | PRIMARY    |       3 |          3 |\n+-------------+----------+------------+-------------+------------+------------+----------+------------+---------+------------+\n1 row in set (0.01 sec)\n\nPAGE_NO = 3 标识B-tree的root page是3号页，INDEX_TYPE = 3是聚集索引。 INDEX_TYPE取值如下：\n0 = nonunique secondary index; \n1 = automatically generated clustered index (GEN_CLUST_INDEX); \n2 = unique nonclustered index; \n3 = clustered index; \n32 = full-text index;\n#收缩空间再后进行观察\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n</ul>\n<p>MySQL内部不会真正删除空间，而且做标记删除，即将delflag:N修改为delflag:Y，commit之后会会被purge进入删除链表，如果下一次insert更大的记录，delete之后的空间不会被重用，如果插入的记录小于等于delete的记录空会被重用，这块内容可以通过知数堂的innblock工具进行分析。</p>\n<h2><a name=\"t7\"></a><a name=\"t7\"></a><a id=\"Innodb_207\"></a>Innodb中的碎片</h2>\n<h3><a name=\"t8\"></a><a name=\"t8\"></a><a id=\"_209\"></a>碎片的产生</h3>\n<p>我们知道数据存储在文件系统上的，总是不能100%利用分配给它的物理空间，删除数据会在页面上留下一些&rdquo;空洞&rdquo;，或者随机写入（聚集索引非线性增加）会导致页分裂，页分裂导致页面的利用空间少于50%，另外对表进行增删改会引起对应的二级索引值的随机的增删改，也会导致索引结构中的数据页面上留下一些\"空洞\"，虽然这些空洞有可能会被重复利用，但终究会导致部分物理空间未被使用，也就是碎片。</p>\n<p>同时，即便是设置了填充因子为100%，Innodb也会主动留下page页面1/16的空间作为预留使用（An innodb_fill_factor setting of 100 leaves 1/16 of the space in clustered index pages free for future index growth）防止update带来的行溢出。</p>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; select table_schema,\n    -&gt;        table_name,ENGINE,\n    -&gt;        round(DATA_LENGTH/1024/1024+ INDEX_LENGTH/1024/1024) total_mb,TABLE_ROWS,\n    -&gt;        round(DATA_LENGTH/1024/1024) data_mb, round(INDEX_LENGTH/1024/1024) index_mb, round(DATA_FREE/1024/1024) free_mb, round(DATA_FREE/DATA_LENGTH*100,2) free_ratio\n    -&gt; from information_schema.TABLES where  TABLE_SCHEMA= 'test'\n    -&gt; and TABLE_NAME= 'user';\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n| table_schema | table_name | ENGINE | total_mb | TABLE_ROWS | data_mb | index_mb | free_mb | free_ratio |\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n| test         | user      | InnoDB |        4 |      50000 |       4 |        0 |       6 |     149.42 |\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n1 row in set (0.00 sec)\n\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n</ul>\n<p>其中data_free是分配了未使用的字节数，并不能说明完全是碎片空间。</p>\n<h3><a name=\"t9\"></a><a name=\"t9\"></a><a id=\"_233\"></a>碎片的回收</h3>\n<p>对于InnoDB的表，可以通过以下命令来回收碎片，释放空间，这个是随机读IO操作，会比较耗时，也会阻塞表上正常的DML运行，同时需要占用额外更多的磁盘空间，对于RDS来说，可能会导致磁盘空间瞬间爆满，实例瞬间被锁定，应用无法做DML操作，所以禁止在线上环境去执行。</p>\n<pre class=\"prettyprint\"><code class=\"prism language-shell has-numbering\"><span class=\"token comment\">#执行InnoDB的碎片回收</span>\nmysql<span class=\"token operator\">&gt;</span> alter table user engine<span class=\"token operator\">=</span>InnoDB<span class=\"token punctuation\">;</span>\nQuery OK, 0 rows affected <span class=\"token punctuation\">(</span>9.00 sec<span class=\"token punctuation\">)</span>\nRecords: 0  Duplicates: 0  Warnings: 0\n\n<span class=\"token comment\">##执行完之后，数据文件大小从14MB降低到10M。</span>\n<span class=\"token comment\"># ls -lh /data2/mysql/test/user1.ibd </span>\n-rw-r----- 1 mysql mysql 10M Nov 6 16:18 /data2/mysql/test/user.ibd\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n</ul>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; select table_schema,        table_name,ENGINE,        round(DATA_LENGTH/1024/1024+ INDEX_LENGTH/1024/1024) total_mb,TABLE_ROWS,        round(DATA_LENGTH/1024/1024) data_mb, round(INDEX_LENGTH/1024/1024) index_mb, round(DATA_FREE/1024/1024) free_mb, round(DATA_FREE/DATA_LENGTH*100,2) free_ratio from information_schema.TABLES where  TABLE_SCHEMA= 'test' and TABLE_NAME= 'user';\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n| table_schema | table_name | ENGINE | total_mb | TABLE_ROWS | data_mb | index_mb | free_mb | free_ratio |\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n| test         | user      | InnoDB |        5 |      50000 |       5 |        0 |       2 |      44.29 |\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n1 row in set (0.00 sec)\n\n\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n</ul>\n<h2><a name=\"t10\"></a><a name=\"t10\"></a><a id=\"deleteSQL_260\"></a>delete对SQL的影响</h2>\n<h3><a name=\"t11\"></a><a name=\"t11\"></a><a id=\"SQL_262\"></a>未删除前的SQL执行情况</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#插入100W数据\nmysql&gt; call insert_user_data(1000000);\nQuery OK, 0 rows affected (35.99 sec)\n\n#添加相关索引\nmysql&gt; alter table user add index idx_name(name), add index idx_phone(phone);\nQuery OK, 0 rows affected (6.00 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\n#表上索引统计信息\nmysql&gt; show index from user;\n+-------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+\n| Table | Non_unique | Key_name  | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |\n+-------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+\n| user  |          0 | PRIMARY   |            1 | id          | A         |      996757 |     NULL | NULL   |      | BTREE      |         |               |\n| user  |          1 | idx_name  |            1 | name        | A         |      996757 |     NULL | NULL   |      | BTREE      |         |               |\n| user  |          1 | idx_phone |            1 | phone       | A         |           2 |     NULL | NULL   |      | BTREE      |         |               |\n+-------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+\n3 rows in set (0.00 sec)\n\n#重置状态变量计数\nmysql&gt; flush status;\nQuery OK, 0 rows affected (0.00 sec)\n\n#执行SQL语句\nmysql&gt; select id, age ,phone from user where name like 'lyn12%';\n+--------+-----+-------------+\n| id     | age | phone       |\n+--------+-----+-------------+\n|    124 |   3 | 15240540354 |\n|   1231 |  30 | 15240540354 |\n|  12301 |  60 | 15240540354 |\n.............................\n| 129998 |  37 | 15240540354 |\n| 129999 |  38 | 15240540354 |\n| 130000 |  39 | 15240540354 |\n+--------+-----+-------------+\n11111 rows in set (0.03 sec)\n\nmysql&gt; explain select id, age ,phone from user where name like 'lyn12%';\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n| id | select_type | table | type  | possible_keys | key      | key_len | ref  | rows  | Extra                 |\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n|  1 | SIMPLE      | user  | range | idx_name      | idx_name | 82      | NULL | 22226 | Using index condition |\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n1 row in set (0.00 sec)\n\n#查看相关状态呢变量\nmysql&gt; select * from information_schema.session_status where variable_name in('Last_query_cost','Handler_read_next','Innodb_pages_read','Innodb_data_reads','Innodb_pages_read');\n+-------------------+----------------+\n| VARIABLE_NAME     | VARIABLE_VALUE |\n+-------------------+----------------+\n| HANDLER_READ_NEXT | 11111          |    #请求读的行数\n| INNODB_DATA_READS | 7868409        |    #数据物理读的总数\n| INNODB_PAGES_READ | 7855239        |    #逻辑读的总数\n| LAST_QUERY_COST   | 10.499000      |    #SQL语句的成本COST，主要包括IO_COST和CPU_COST。\n+-------------------+----------------+\n4 rows in set (0.00 sec)\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n<li>31</li>\n<li>32</li>\n<li>33</li>\n<li>34</li>\n<li>35</li>\n<li>36</li>\n<li>37</li>\n<li>38</li>\n<li>39</li>\n<li>40</li>\n<li>41</li>\n<li>42</li>\n<li>43</li>\n<li>44</li>\n<li>45</li>\n<li>46</li>\n<li>47</li>\n<li>48</li>\n<li>49</li>\n<li>50</li>\n<li>51</li>\n<li>52</li>\n<li>53</li>\n<li>54</li>\n<li>55</li>\n<li>56</li>\n<li>57</li>\n<li>58</li>\n</ul>\n<h3><a name=\"t12\"></a><a name=\"t12\"></a><a id=\"SQL_325\"></a>删除后的SQL执行情况</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#删除50w数据\nmysql&gt; delete from user limit 500000;\nQuery OK, 500000 rows affected (3.70 sec)\n\n#分析表统计信息\nmysql&gt; analyze table user;\n+-----------+---------+----------+----------+\n| Table     | Op      | Msg_type | Msg_text |\n+-----------+---------+----------+----------+\n| test.user | analyze | status   | OK       |\n+-----------+---------+----------+----------+\n1 row in set (0.01 sec)\n\n#重置状态变量计数\nmysql&gt; flush status;\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql&gt; select id, age ,phone from user where name like 'lyn12%';\nEmpty set (0.05 sec)\n\nmysql&gt; explain select id, age ,phone from user where name like 'lyn12%';\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n| id | select_type | table | type  | possible_keys | key      | key_len | ref  | rows  | Extra                 |\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n|  1 | SIMPLE      | user  | range | idx_name      | idx_name | 82      | NULL | 22226 | Using index condition |\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n1 row in set (0.00 sec)\n\nmysql&gt; select * from information_schema.session_status where variable_name in('Last_query_cost','Handler_read_next','Innodb_pages_read','Innodb_data_reads','Innodb_pages_read');\n+-------------------+----------------+\n| VARIABLE_NAME     | VARIABLE_VALUE |\n+-------------------+----------------+\n| HANDLER_READ_NEXT | 0              |\n| INNODB_DATA_READS | 7868409        |\n| INNODB_PAGES_READ | 7855239        |\n| LAST_QUERY_COST   | 10.499000      |\n+-------------------+----------------+\n4 rows in set (0.00 sec)\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n<li>31</li>\n<li>32</li>\n<li>33</li>\n<li>34</li>\n<li>35</li>\n<li>36</li>\n<li>37</li>\n<li>38</li>\n</ul>\n<h3><a name=\"t13\"></a><a name=\"t13\"></a><a id=\"_368\"></a>结果统计分析</h3>\n<div class=\"table-box\">\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>COST</th>\n<th>物理读次数</th>\n<th>逻辑读次数</th>\n<th>扫描行数</th>\n<th>返回行数</th>\n<th>执行时间</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>初始化插入100W</td>\n<td>10.499000</td>\n<td>7868409</td>\n<td>7855239</td>\n<td>22226</td>\n<td>11111</td>\n<td>30ms</td>\n</tr>\n<tr>\n<td>100W随机删除50W</td>\n<td>10.499000</td>\n<td>7868409</td>\n<td>7855239</td>\n<td>22226</td>\n<td>0</td>\n<td>50ms</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>这也说明对普通的大表，想要通过delete数据来对表进行瘦身是不现实的，所以在任何时候不要用delete去删除数据，应该使用优雅的标记删除。</p>\n<h2><a name=\"t14\"></a><a name=\"t14\"></a><a id=\"delete_377\"></a>delete优化建议</h2>\n<h3><a name=\"t15\"></a><a name=\"t15\"></a><a id=\"_379\"></a>控制业务账号权限</h3>\n<p>对于一个大的系统来说，需要根据业务特点去拆分子系统，每个子系统可以看做是一个service，例如美团APP，上面有很多服务，核心的服务有用户服务user-service，搜索服务search-service，商品product-service，位置服务location-service，价格服务price-service等。每个服务对应一个数据库，为该数据库创建单独账号，同时只授予DML权限且没有delete权限，同时禁止跨库访问。</p>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#创建用户数据库并授权\ncreate database mt_user charset utf8mb4;\ngrant USAGE, SELECT, INSERT, UPDATE ON mt_user.*  to 'w_user'@'%' identified by 't$W*g@gaHTGi123456';\nflush privileges;\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n</ul>\n<h3><a name=\"t16\"></a><a name=\"t16\"></a><a id=\"delete_390\"></a>delete改为标记删除</h3>\n<p>在MySQL数据库建模规范中有4个公共字段，基本上每个表必须有的，同时在create_time列要创建索引，有两方面的好处：</p>\n<ol>\n<li>一些查询业务场景都会有一个默认的时间段，比如7天或者一个月，都是通过create_time去过滤，走索引扫描更快。</li>\n<li>一些核心的业务表需要以T +1的方式抽取数据仓库中，比如每天晚上00:30抽取前一天的数据，都是通过create_time过滤的。</li>\n</ol>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">`id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键id',\n`is_deleted` tinyint(4) NOT NULL DEFAULT '0' COMMENT '是否逻辑删除：0：未删除，1：已删除',\n`create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n`update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间'\n\n#有了删除标记，业务接口的delete操作就可以转换为update\nupdate user set is_deleted = 1 where user_id = 1213;\n\n#查询的时候需要带上is_deleted过滤\nselect id, age ,phone from user where is_deleted = 0 and name like 'lyn12%';\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n</ul>\n<h2><a name=\"t17\"></a><a name=\"t17\"></a><a id=\"_410\"></a>数据归档方式</h2>\n<h3><a name=\"t18\"></a><a name=\"t18\"></a><a id=\"_412\"></a>通用数据归档方法</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#1. 创建归档表，一般在原表名后面添加_bak。\nCREATE TABLE `ota_order_bak` (\n  `id` bigint(11) NOT NULL AUTO_INCREMENT COMMENT '主键',\n  `order_id` varchar(255) DEFAULT NULL COMMENT '订单id',\n  `ota_id` varchar(255) DEFAULT NULL COMMENT 'ota',\n  `check_in_date` varchar(255) DEFAULT NULL COMMENT '入住日期',\n  `check_out_date` varchar(255) DEFAULT NULL COMMENT '离店日期',\n  `hotel_id` varchar(255) DEFAULT NULL COMMENT '酒店ID',\n  `guest_name` varchar(255) DEFAULT NULL COMMENT '顾客',\n  `purcharse_time` timestamp NULL DEFAULT NULL COMMENT '购买时间',\n  `create_time` datetime DEFAULT NULL,\n  `update_time` datetime DEFAULT NULL,\n  `create_user` varchar(255) DEFAULT NULL,\n  `update_user` varchar(255) DEFAULT NULL,\n  `status` int(4) DEFAULT '1' COMMENT '状态 ： 1 正常 ， 0 删除',\n  `hotel_name` varchar(255) DEFAULT NULL,\n  `price` decimal(10,0) DEFAULT NULL,\n  `remark` longtext,\n  PRIMARY KEY (`id`),\n  KEY `IDX_order_id` (`order_id`) USING BTREE,\n  KEY `hotel_name` (`hotel_name`) USING BTREE,\n  KEY `ota_id` (`ota_id`) USING BTREE,\n  KEY `IDX_purcharse_time` (`purcharse_time`) USING BTREE,\n  KEY `IDX_create_time` (`create_time`) USING BTREE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8\nPARTITION BY RANGE (to_days(create_time)) ( \nPARTITION p201808 VALUES LESS THAN (to_days('2018-09-01')), \nPARTITION p201809 VALUES LESS THAN (to_days('2018-10-01')), \nPARTITION p201810 VALUES LESS THAN (to_days('2018-11-01')), \nPARTITION p201811 VALUES LESS THAN (to_days('2018-12-01')), \nPARTITION p201812 VALUES LESS THAN (to_days('2019-01-01')), \nPARTITION p201901 VALUES LESS THAN (to_days('2019-02-01')), \nPARTITION p201902 VALUES LESS THAN (to_days('2019-03-01')), \nPARTITION p201903 VALUES LESS THAN (to_days('2019-04-01')), \nPARTITION p201904 VALUES LESS THAN (to_days('2019-05-01')), \nPARTITION p201905 VALUES LESS THAN (to_days('2019-06-01')), \nPARTITION p201906 VALUES LESS THAN (to_days('2019-07-01')), \nPARTITION p201907 VALUES LESS THAN (to_days('2019-08-01')), \nPARTITION p201908 VALUES LESS THAN (to_days('2019-09-01')), \nPARTITION p201909 VALUES LESS THAN (to_days('2019-10-01')), \nPARTITION p201910 VALUES LESS THAN (to_days('2019-11-01')), \nPARTITION p201911 VALUES LESS THAN (to_days('2019-12-01')), \nPARTITION p201912 VALUES LESS THAN (to_days('2020-01-01')));\n\n#2. 插入原表中无效的数据（需要跟开发同学确认数据保留范围）\ncreate table tbl_p201808 as select * from ota_order where create_time between '2018-08-01 00:00:00' and '2018-08-31 23:59:59';\n\n#3. 跟归档表分区做分区交换\nalter table ota_order_bak exchange partition p201808 with table tbl_p201808; \n\n#4. 删除原表中已经规范的数据\ndelete from ota_order where create_time between '2018-08-01 00:00:00' and '2018-08-31 23:59:59' limit 3000;\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n<li>31</li>\n<li>32</li>\n<li>33</li>\n<li>34</li>\n<li>35</li>\n<li>36</li>\n<li>37</li>\n<li>38</li>\n<li>39</li>\n<li>40</li>\n<li>41</li>\n<li>42</li>\n<li>43</li>\n<li>44</li>\n<li>45</li>\n<li>46</li>\n<li>47</li>\n<li>48</li>\n<li>49</li>\n<li>50</li>\n<li>51</li>\n<li>52</li>\n</ul>\n<h3><a name=\"t19\"></a><a name=\"t19\"></a><a id=\"_469\"></a>优化后的归档方式</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#1. 创建中间表\nCREATE TABLE `ota_order_2020` (........) ENGINE=InnoDB DEFAULT CHARSET=utf8\nPARTITION BY RANGE (to_days(create_time)) ( \nPARTITION p201808 VALUES LESS THAN (to_days('2018-09-01')), \nPARTITION p201809 VALUES LESS THAN (to_days('2018-10-01')), \nPARTITION p201810 VALUES LESS THAN (to_days('2018-11-01')), \nPARTITION p201811 VALUES LESS THAN (to_days('2018-12-01')), \nPARTITION p201812 VALUES LESS THAN (to_days('2019-01-01')), \nPARTITION p201901 VALUES LESS THAN (to_days('2019-02-01')), \nPARTITION p201902 VALUES LESS THAN (to_days('2019-03-01')), \nPARTITION p201903 VALUES LESS THAN (to_days('2019-04-01')), \nPARTITION p201904 VALUES LESS THAN (to_days('2019-05-01')), \nPARTITION p201905 VALUES LESS THAN (to_days('2019-06-01')), \nPARTITION p201906 VALUES LESS THAN (to_days('2019-07-01')), \nPARTITION p201907 VALUES LESS THAN (to_days('2019-08-01')), \nPARTITION p201908 VALUES LESS THAN (to_days('2019-09-01')), \nPARTITION p201909 VALUES LESS THAN (to_days('2019-10-01')), \nPARTITION p201910 VALUES LESS THAN (to_days('2019-11-01')), \nPARTITION p201911 VALUES LESS THAN (to_days('2019-12-01')), \nPARTITION p201912 VALUES LESS THAN (to_days('2020-01-01')));\n\n#2. 插入原表中有效的数据，如果数据量在100W左右可以在业务低峰期直接插入，如果比较大，建议采用dataX来做，可以控制频率和大小，之前我这边用Go封装了dataX可以实现自动生成json文件，自定义大小去执行。\ninsert into ota_order_2020 select * from ota_order where create_time between '2020-08-01 00:00:00' and '2020-08-31 23:59:59';\n\n#3. 表重命名\nalter table ota_order rename to ota_order_bak;  \nalter table ota_order_2020 rename to ota_order;\n#4. 插入差异数据\ninsert into ota_order select * from ota_order_bak a where not exists (select 1 from ota_order b where a.id = b.id);\n#5. ota_order_bak改造成分区表，如果表比较大不建议直接改造，可以先创建好分区表，通过dataX把导入进去即可。\n\n#6. 后续的归档方法\n#创建中间普遍表\ncreate table ota_order_mid like ota_order;\n#交换原表无效数据分区到普通表\nalter table ota_order exchange partition p201808 with table ota_order_mid; \n##交换普通表数据到归档表的相应分区\nalter table ota_order_bak exchange partition p201808 with table ota_order_mid; \n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n<li>31</li>\n<li>32</li>\n<li>33</li>\n<li>34</li>\n<li>35</li>\n<li>36</li>\n<li>37</li>\n<li>38</li>\n</ul>\n<p>这样原表和归档表都是按月的分区表，只需要创建一个中间普通表，在业务低峰期做两次分区交换，既可以删除无效数据，又能回收空，而且没有空间碎片，不会影响表上的索引及SQL的执行计划。</p>\n<h2><a name=\"t20\"></a><a name=\"t20\"></a><a id=\"_514\"></a>总结</h2>\n<p>通过从InnoDB存储空间分布，delete对性能的影响可以看到，delete物理删除既不能释放磁盘空间，而且会产生大量的碎片，导致索引频繁分裂，影响SQL执行计划的稳定性；</p>\n<p>同时在碎片回收时，会耗用大量的CPU，磁盘空间，影响表上正常的DML操作。</p>\n<p>在业务代码层面，应该做逻辑标记删除，避免物理删除；为了实现数据归档需求，可以用采用MySQL分区表特性来实现，都是DDL操作，没有碎片产生。</p>\n<p>另外一个比较好的方案采用Clickhouse，对有生命周期的数据表可以使用Clickhouse存储，利用其TTL特性实现无效数据自动清理。</p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1330877080455553024","blogRead":0,"blogRemark":"MySQL","blogTitle":"面试官不讲武德问我：为什么MySQL不建议使用delete删除数据？","blogType":1,"createdTime":1606111996000,"version":3},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:27:42.051 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:27:49.348 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==>  Preparing: select blog_id, blog_title, blog_content, blog_goods, blog_image, blog_read, blog_collection, blog_type, blog_remark, blog_comment, blog_source, created_time, version from bl_blog where blog_id = ? and deleted = 0 
2020-12-24 23:27:49.349 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==> Parameters: 1330877080455553024(String)
2020-12-24 23:27:49.459 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -<==      Total: 1
2020-12-24 23:27:49.515 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:27:49.519 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/get/1330877080455553024(String), [1330877080455553024](String), 1(Integer), null, GET(String), 164(Long), {"code":20000,"data":{"blogCollection":0,"blogComment":0,"blogContent":"<h2>前言</h2>\n<p>我负责的有几个系统随着业务量的增长，存储在MySQL中的数据日益剧增，我当时就想现在的业务方不讲武德，搞偷袭，趁我没反应过来把很多表，很快，很快啊都打到了亿级别，我大意了，没有闪，这就导致跟其Join的表的SQL变得很慢，对的应用接口的response time也变长了，影响了用户体验。</p>\n<p>事后我找到业务方，我批评了他们跟他们说要讲武德，连忙跟我道歉，这个事情才就此作罢，走的时候我对他们说下次不要这样了，耗子尾汁，好好反思。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/3c93aececcb9e763f5476362c4e88710.png\" alt=\"\" /></p>\n<p>骂归骂，事情还是得解决，时候我分析原因发现，发现有些表的数据量增长很快，对应SQL扫描了很多无效数据，导致SQL慢了下来，通过确认之后，这些大表都是一些流水、记录、日志类型数据，只需要保留1到3个月，此时需要对表做数据清理实现瘦身，一般都会想到用insert + delete的方式去清理。</p>\n<p>这篇文章我会从InnoDB存储空间分布，delete对性能的影响，以及优化建议方面解释为什么不建议delete删除数据。</p>\n<h2><a name=\"t1\"></a><a name=\"t1\"></a><a id=\"InnoDB_16\"></a>InnoDB存储架构</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/5c66ffe9749c58e1613d2519f7ea7211.png\" alt=\"\" /></p>\n<p>从这张图可以看到，InnoDB存储结构主要包括两部分：逻辑存储结构和物理存储结构。</p>\n<p>逻辑上是由表空间tablespace &mdash;&gt; 段segment或者inode &mdash;&gt; 区Extent &mdash;&mdash;&gt;数据页Page构成，Innodb逻辑管理单位是segment，空间分配的最小单位是extent，每个segment都会从表空间FREE_PAGE中分配32个page，当这32个page不够用时，会按照以下原则进行扩展：如果当前小于1个extent，则扩展到1个extent；当表空间小于32MB时，每次扩展一个extent；表空间大于32MB，每次扩展4个extent。</p>\n<p>物理上主要由系统用户数据文件，日志文件组成，数据文件主要存储MySQL字典数据和用户数据，日志文件记录的是data page的变更记录，用于MySQL Crash时的恢复。</p>\n<h2><a name=\"t2\"></a><a name=\"t2\"></a><a id=\"Innodb_26\"></a>Innodb表空间</h2>\n<p>InnoDB存储包括三类表空间：系统表空间，用户表空间，Undo表空间。</p>\n<p><strong>系统表空间：</strong>&nbsp;主要存储MySQL内部的数据字典数据，如information_schema下的数据。</p>\n<p><strong>用户表空间：</strong>&nbsp;当开启innodb_file_per_table=1时，数据表从系统表空间独立出来存储在以table_name.ibd命令的数据文件中，结构信息存储在table_name.frm文件中。</p>\n<p><strong>Undo表空间：</strong>&nbsp;存储Undo信息，如快照一致读和flashback都是利用undo信息。</p>\n<p>从MySQL 8.0开始允许用户自定义表空间，具体语法如下：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">CREATE TABLESPACE tablespace_name\n    ADD DATAFILE 'file_name'               #数据文件名\n    USE LOGFILE GROUP logfile_group        #自定义日志文件组，一般每组2个logfile。\n    [EXTENT_SIZE [=] extent_size]          #区大小\n    [INITIAL_SIZE [=] initial_size]        #初始化大小 \n    [AUTOEXTEND_SIZE [=] autoextend_size]  #自动扩宽尺寸\n    [MAX_SIZE [=] max_size]                #单个文件最大size，最大是32G。\n    [NODEGROUP [=] nodegroup_id]           #节点组\n    [WAIT]\n    [COMMENT [=] comment_text]\n    ENGINE [=] engine_name\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n</ul>\n<p>这样的好处是可以做到数据的冷热分离，分别用HDD和SSD来存储，既能实现数据的高效访问，又能节约成本，比如可以添加两块500G硬盘，经过创建卷组vg，划分逻辑卷lv，创建数据目录并mount相应的lv，假设划分的两个目录分别是/hot_data 和 /cold_data。</p>\n<p>这样就可以将核心的业务表如用户表，订单表存储在高性能SSD盘上，一些日志，流水表存储在普通的HDD上，主要的操作步骤如下：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#创建热数据表空间\ncreate tablespace tbs_data_hot add datafile '/hot_data/tbs_data_hot01.dbf' max_size 20G;\n#创建核心业务表存储在热数据表空间\ncreate table booking(id bigint not null primary key auto_increment, &hellip;&hellip; ) tablespace tbs_data_hot;\n#创建冷数据表空间\ncreate tablespace tbs_data_cold add datafile '/hot_data/tbs_data_cold01.dbf' max_size 20G;\n#创建日志，流水，备份类的表存储在冷数据表空间\ncreate table payment_log(id bigint not null primary key auto_increment, &hellip;&hellip; ) tablespace tbs_data_cold;\n#可以移动表到另一个表空间\nalter table payment_log tablespace tbs_data_hot;\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n</ul>\n<h2><a name=\"t3\"></a><a name=\"t3\"></a><a id=\"Inndob_69\"></a>Inndob存储分布</h2>\n<h3><a name=\"t4\"></a><a name=\"t4\"></a><a id=\"_71\"></a>创建空表查看空间变化</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; create table user(id bigint not null primary key auto_increment, \n    -&gt; name varchar(20) not null default '' comment '姓名', \n    -&gt; age tinyint not null default 0 comment 'age', \n    -&gt; gender char(1) not null default 'M'  comment '性别',\n    -&gt; phone varchar(16) not null default '' comment '手机号',\n    -&gt; create_time datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n    -&gt; update_time datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间'\n    -&gt; ) engine = InnoDB DEFAULT CHARSET=utf8mb4 COMMENT '用户信息表';\nQuery OK, 0 rows affected (0.26 sec)\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n</ul>\n<pre class=\"prettyprint\"><code class=\"prism language-bash has-numbering\"><span class=\"token comment\"># ls -lh user1.ibd </span>\n-rw-r----- 1 mysql mysql 96K Nov  6 12:48 user.ibd\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n</ul>\n<p>设置参数innodb_file_per_table=1时，创建表时会自动创建一个segment，同时分配一个extent，包含32个data page的来存储数据，这样创建的空表默认大小就是96KB，extent使用完之后会申请64个连接页，这样对于一些小表，或者undo segment，可以在开始时申请较少的空间，节省磁盘容量的开销。</p>\n<pre class=\"prettyprint\"><code class=\"prism language-shell has-numbering\"><span class=\"token comment\"># python2 py_innodb_page_info.py -v /data2/mysql/test/user.ibd</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>File Space Header<span class=\"token operator\">&gt;</span>\npage offset 00000001, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Insert Buffer Bitmap<span class=\"token operator\">&gt;</span>\npage offset 00000002, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>File Segment inode<span class=\"token operator\">&gt;</span>\npage offset 00000003, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>B-tree Node<span class=\"token operator\">&gt;</span>, page level <span class=\"token operator\">&lt;</span>0000<span class=\"token operator\">&gt;</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Freshly Allocated Page<span class=\"token operator\">&gt;</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Freshly Allocated Page<span class=\"token operator\">&gt;</span>\nTotal number of page: 6:      <span class=\"token comment\">#总共分配的页数</span>\nFreshly Allocated Page: 2     <span class=\"token comment\">#可用的数据页</span>\nInsert Buffer Bitmap: 1       <span class=\"token comment\">#插入缓冲页</span>\nFile Space Header: 1          <span class=\"token comment\">#文件空间头</span>\nB-tree Node: 1                <span class=\"token comment\">#数据页</span>\nFile Segment inode: 1         <span class=\"token comment\">#文件端inonde，如果是在ibdata1.ibd上会有多个inode。</span>\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n</ul>\n<h3><a name=\"t5\"></a><a name=\"t5\"></a><a id=\"_108\"></a>插入数据后的空间变化</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; DELIMITER $$\nmysql&gt; CREATE PROCEDURE insert_user_data(num INTEGER) \n    -&gt; BEGIN\n    -&gt;     DECLARE v_i int unsigned DEFAULT 0;\n    -&gt; set autocommit= 0;\n    -&gt; WHILE v_i &lt; num DO\n    -&gt;    insert into user(`name`, age, gender, phone) values (CONCAT('lyn',v_i), mod(v_i,120), 'M', CONCAT('152',ROUND(RAND(1)*100000000)));\n    -&gt;  SET v_i = v_i+1;\n    -&gt; END WHILE;\n    -&gt; commit;\n    -&gt; END $$\nQuery OK, 0 rows affected (0.01 sec)\nmysql&gt; DELIMITER ;\n\n#插入10w数据\nmysql&gt; call insert_user_data(100000);\nQuery OK, 0 rows affected (6.69 sec)\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n</ul>\n<pre class=\"prettyprint\"><code class=\"prism language-shell has-numbering\"><span class=\"token comment\"># ls -lh user.ibd</span>\n-rw-r----- 1 mysql mysql 14M Nov 6 10:58 /data2/mysql/test/user.ibd\n\n<span class=\"token comment\"># python2 py_innodb_page_info.py -v /data2/mysql/test/user.ibd</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>File Space Header<span class=\"token operator\">&gt;</span>\npage offset 00000001, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Insert Buffer Bitmap<span class=\"token operator\">&gt;</span>\npage offset 00000002, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>File Segment inode<span class=\"token operator\">&gt;</span>\npage offset 00000003, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>B-tree Node<span class=\"token operator\">&gt;</span>, page level <span class=\"token operator\">&lt;</span>0001<span class=\"token operator\">&gt;</span>   <span class=\"token comment\">#增加了一个非叶子节点，树的高度从1变为2.</span>\n<span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Freshly Allocated Page<span class=\"token operator\">&gt;</span>\nTotal number of page: 896:\nFreshly Allocated Page: 493\nInsert Buffer Bitmap: 1\nFile Space Header: 1\nB-tree Node: 400\nFile Segment inode: 1\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n</ul>\n<h3><a name=\"t6\"></a><a name=\"t6\"></a><a id=\"delete_149\"></a>delete数据后的空间变化</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; select min(id),max(id),count(*) from user;\n+---------+---------+----------+\n| min(id) | max(id) | count(*) |\n+---------+---------+----------+\n|       1 |  100000 |   100000 |\n+---------+---------+----------+\n1 row in set (0.05 sec)\n#删除50000条数据，理论上空间应该从14MB变长7MB左右。\nmysql&gt; delete from user limit 50000;\nQuery OK, 50000 rows affected (0.25 sec)\n\n#数据文件大小依然是14MB，没有缩小。\n# ls -lh /data2/mysql/test/user1.ibd \n-rw-r----- 1 mysql mysql 14M Nov  6 13:22 /data2/mysql/test/user.ibd\n\n#数据页没有被回收。\n# python2 py_innodb_page_info.py -v /data2/mysql/test/user.ibd\npage offset 00000000, page type &lt;File Space Header&gt;\npage offset 00000001, page type &lt;Insert Buffer Bitmap&gt;\npage offset 00000002, page type &lt;File Segment inode&gt;\npage offset 00000003, page type &lt;B-tree Node&gt;, page level &lt;0001&gt;\n........................................................\npage offset 00000000, page type &lt;Freshly Allocated Page&gt;\nTotal number of page: 896:\nFreshly Allocated Page: 493\nInsert Buffer Bitmap: 1\nFile Space Header: 1\nB-tree Node: 400\nFile Segment inode: 1\n#在MySQL内部是标记删除，\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n</ul>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; use information_schema;\n\nDatabase changed\nmysql&gt; SELECT A.SPACE AS TBL_SPACEID, A.TABLE_ID, A.NAME AS TABLE_NAME, FILE_FORMAT, ROW_FORMAT, SPACE_TYPE,  B.INDEX_ID , B.NAME AS INDEX_NAME, PAGE_NO, B.TYPE AS INDEX_TYPE FROM INNODB_SYS_TABLES A LEFT JOIN INNODB_SYS_INDEXES B ON A.TABLE_ID =B.TABLE_ID WHERE A.NAME = 'test/user1';\n+-------------+----------+------------+-------------+------------+------------+----------+------------+---------+------------+\n| TBL_SPACEID | TABLE_ID | TABLE_NAME | FILE_FORMAT | ROW_FORMAT | SPACE_TYPE | INDEX_ID | INDEX_NAME | PAGE_NO | INDEX_TYPE |\n+-------------+----------+------------+-------------+------------+------------+----------+------------+---------+------------+\n|        1283 |     1207 | test/user | Barracuda   | Dynamic    | Single     |     2236 | PRIMARY    |       3 |          3 |\n+-------------+----------+------------+-------------+------------+------------+----------+------------+---------+------------+\n1 row in set (0.01 sec)\n\nPAGE_NO = 3 标识B-tree的root page是3号页，INDEX_TYPE = 3是聚集索引。 INDEX_TYPE取值如下：\n0 = nonunique secondary index; \n1 = automatically generated clustered index (GEN_CLUST_INDEX); \n2 = unique nonclustered index; \n3 = clustered index; \n32 = full-text index;\n#收缩空间再后进行观察\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n</ul>\n<p>MySQL内部不会真正删除空间，而且做标记删除，即将delflag:N修改为delflag:Y，commit之后会会被purge进入删除链表，如果下一次insert更大的记录，delete之后的空间不会被重用，如果插入的记录小于等于delete的记录空会被重用，这块内容可以通过知数堂的innblock工具进行分析。</p>\n<h2><a name=\"t7\"></a><a name=\"t7\"></a><a id=\"Innodb_207\"></a>Innodb中的碎片</h2>\n<h3><a name=\"t8\"></a><a name=\"t8\"></a><a id=\"_209\"></a>碎片的产生</h3>\n<p>我们知道数据存储在文件系统上的，总是不能100%利用分配给它的物理空间，删除数据会在页面上留下一些&rdquo;空洞&rdquo;，或者随机写入（聚集索引非线性增加）会导致页分裂，页分裂导致页面的利用空间少于50%，另外对表进行增删改会引起对应的二级索引值的随机的增删改，也会导致索引结构中的数据页面上留下一些\"空洞\"，虽然这些空洞有可能会被重复利用，但终究会导致部分物理空间未被使用，也就是碎片。</p>\n<p>同时，即便是设置了填充因子为100%，Innodb也会主动留下page页面1/16的空间作为预留使用（An innodb_fill_factor setting of 100 leaves 1/16 of the space in clustered index pages free for future index growth）防止update带来的行溢出。</p>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; select table_schema,\n    -&gt;        table_name,ENGINE,\n    -&gt;        round(DATA_LENGTH/1024/1024+ INDEX_LENGTH/1024/1024) total_mb,TABLE_ROWS,\n    -&gt;        round(DATA_LENGTH/1024/1024) data_mb, round(INDEX_LENGTH/1024/1024) index_mb, round(DATA_FREE/1024/1024) free_mb, round(DATA_FREE/DATA_LENGTH*100,2) free_ratio\n    -&gt; from information_schema.TABLES where  TABLE_SCHEMA= 'test'\n    -&gt; and TABLE_NAME= 'user';\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n| table_schema | table_name | ENGINE | total_mb | TABLE_ROWS | data_mb | index_mb | free_mb | free_ratio |\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n| test         | user      | InnoDB |        4 |      50000 |       4 |        0 |       6 |     149.42 |\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n1 row in set (0.00 sec)\n\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n</ul>\n<p>其中data_free是分配了未使用的字节数，并不能说明完全是碎片空间。</p>\n<h3><a name=\"t9\"></a><a name=\"t9\"></a><a id=\"_233\"></a>碎片的回收</h3>\n<p>对于InnoDB的表，可以通过以下命令来回收碎片，释放空间，这个是随机读IO操作，会比较耗时，也会阻塞表上正常的DML运行，同时需要占用额外更多的磁盘空间，对于RDS来说，可能会导致磁盘空间瞬间爆满，实例瞬间被锁定，应用无法做DML操作，所以禁止在线上环境去执行。</p>\n<pre class=\"prettyprint\"><code class=\"prism language-shell has-numbering\"><span class=\"token comment\">#执行InnoDB的碎片回收</span>\nmysql<span class=\"token operator\">&gt;</span> alter table user engine<span class=\"token operator\">=</span>InnoDB<span class=\"token punctuation\">;</span>\nQuery OK, 0 rows affected <span class=\"token punctuation\">(</span>9.00 sec<span class=\"token punctuation\">)</span>\nRecords: 0  Duplicates: 0  Warnings: 0\n\n<span class=\"token comment\">##执行完之后，数据文件大小从14MB降低到10M。</span>\n<span class=\"token comment\"># ls -lh /data2/mysql/test/user1.ibd </span>\n-rw-r----- 1 mysql mysql 10M Nov 6 16:18 /data2/mysql/test/user.ibd\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n</ul>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; select table_schema,        table_name,ENGINE,        round(DATA_LENGTH/1024/1024+ INDEX_LENGTH/1024/1024) total_mb,TABLE_ROWS,        round(DATA_LENGTH/1024/1024) data_mb, round(INDEX_LENGTH/1024/1024) index_mb, round(DATA_FREE/1024/1024) free_mb, round(DATA_FREE/DATA_LENGTH*100,2) free_ratio from information_schema.TABLES where  TABLE_SCHEMA= 'test' and TABLE_NAME= 'user';\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n| table_schema | table_name | ENGINE | total_mb | TABLE_ROWS | data_mb | index_mb | free_mb | free_ratio |\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n| test         | user      | InnoDB |        5 |      50000 |       5 |        0 |       2 |      44.29 |\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n1 row in set (0.00 sec)\n\n\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n</ul>\n<h2><a name=\"t10\"></a><a name=\"t10\"></a><a id=\"deleteSQL_260\"></a>delete对SQL的影响</h2>\n<h3><a name=\"t11\"></a><a name=\"t11\"></a><a id=\"SQL_262\"></a>未删除前的SQL执行情况</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#插入100W数据\nmysql&gt; call insert_user_data(1000000);\nQuery OK, 0 rows affected (35.99 sec)\n\n#添加相关索引\nmysql&gt; alter table user add index idx_name(name), add index idx_phone(phone);\nQuery OK, 0 rows affected (6.00 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\n#表上索引统计信息\nmysql&gt; show index from user;\n+-------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+\n| Table | Non_unique | Key_name  | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |\n+-------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+\n| user  |          0 | PRIMARY   |            1 | id          | A         |      996757 |     NULL | NULL   |      | BTREE      |         |               |\n| user  |          1 | idx_name  |            1 | name        | A         |      996757 |     NULL | NULL   |      | BTREE      |         |               |\n| user  |          1 | idx_phone |            1 | phone       | A         |           2 |     NULL | NULL   |      | BTREE      |         |               |\n+-------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+\n3 rows in set (0.00 sec)\n\n#重置状态变量计数\nmysql&gt; flush status;\nQuery OK, 0 rows affected (0.00 sec)\n\n#执行SQL语句\nmysql&gt; select id, age ,phone from user where name like 'lyn12%';\n+--------+-----+-------------+\n| id     | age | phone       |\n+--------+-----+-------------+\n|    124 |   3 | 15240540354 |\n|   1231 |  30 | 15240540354 |\n|  12301 |  60 | 15240540354 |\n.............................\n| 129998 |  37 | 15240540354 |\n| 129999 |  38 | 15240540354 |\n| 130000 |  39 | 15240540354 |\n+--------+-----+-------------+\n11111 rows in set (0.03 sec)\n\nmysql&gt; explain select id, age ,phone from user where name like 'lyn12%';\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n| id | select_type | table | type  | possible_keys | key      | key_len | ref  | rows  | Extra                 |\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n|  1 | SIMPLE      | user  | range | idx_name      | idx_name | 82      | NULL | 22226 | Using index condition |\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n1 row in set (0.00 sec)\n\n#查看相关状态呢变量\nmysql&gt; select * from information_schema.session_status where variable_name in('Last_query_cost','Handler_read_next','Innodb_pages_read','Innodb_data_reads','Innodb_pages_read');\n+-------------------+----------------+\n| VARIABLE_NAME     | VARIABLE_VALUE |\n+-------------------+----------------+\n| HANDLER_READ_NEXT | 11111          |    #请求读的行数\n| INNODB_DATA_READS | 7868409        |    #数据物理读的总数\n| INNODB_PAGES_READ | 7855239        |    #逻辑读的总数\n| LAST_QUERY_COST   | 10.499000      |    #SQL语句的成本COST，主要包括IO_COST和CPU_COST。\n+-------------------+----------------+\n4 rows in set (0.00 sec)\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n<li>31</li>\n<li>32</li>\n<li>33</li>\n<li>34</li>\n<li>35</li>\n<li>36</li>\n<li>37</li>\n<li>38</li>\n<li>39</li>\n<li>40</li>\n<li>41</li>\n<li>42</li>\n<li>43</li>\n<li>44</li>\n<li>45</li>\n<li>46</li>\n<li>47</li>\n<li>48</li>\n<li>49</li>\n<li>50</li>\n<li>51</li>\n<li>52</li>\n<li>53</li>\n<li>54</li>\n<li>55</li>\n<li>56</li>\n<li>57</li>\n<li>58</li>\n</ul>\n<h3><a name=\"t12\"></a><a name=\"t12\"></a><a id=\"SQL_325\"></a>删除后的SQL执行情况</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#删除50w数据\nmysql&gt; delete from user limit 500000;\nQuery OK, 500000 rows affected (3.70 sec)\n\n#分析表统计信息\nmysql&gt; analyze table user;\n+-----------+---------+----------+----------+\n| Table     | Op      | Msg_type | Msg_text |\n+-----------+---------+----------+----------+\n| test.user | analyze | status   | OK       |\n+-----------+---------+----------+----------+\n1 row in set (0.01 sec)\n\n#重置状态变量计数\nmysql&gt; flush status;\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql&gt; select id, age ,phone from user where name like 'lyn12%';\nEmpty set (0.05 sec)\n\nmysql&gt; explain select id, age ,phone from user where name like 'lyn12%';\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n| id | select_type | table | type  | possible_keys | key      | key_len | ref  | rows  | Extra                 |\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n|  1 | SIMPLE      | user  | range | idx_name      | idx_name | 82      | NULL | 22226 | Using index condition |\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n1 row in set (0.00 sec)\n\nmysql&gt; select * from information_schema.session_status where variable_name in('Last_query_cost','Handler_read_next','Innodb_pages_read','Innodb_data_reads','Innodb_pages_read');\n+-------------------+----------------+\n| VARIABLE_NAME     | VARIABLE_VALUE |\n+-------------------+----------------+\n| HANDLER_READ_NEXT | 0              |\n| INNODB_DATA_READS | 7868409        |\n| INNODB_PAGES_READ | 7855239        |\n| LAST_QUERY_COST   | 10.499000      |\n+-------------------+----------------+\n4 rows in set (0.00 sec)\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n<li>31</li>\n<li>32</li>\n<li>33</li>\n<li>34</li>\n<li>35</li>\n<li>36</li>\n<li>37</li>\n<li>38</li>\n</ul>\n<h3><a name=\"t13\"></a><a name=\"t13\"></a><a id=\"_368\"></a>结果统计分析</h3>\n<div class=\"table-box\">\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>COST</th>\n<th>物理读次数</th>\n<th>逻辑读次数</th>\n<th>扫描行数</th>\n<th>返回行数</th>\n<th>执行时间</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>初始化插入100W</td>\n<td>10.499000</td>\n<td>7868409</td>\n<td>7855239</td>\n<td>22226</td>\n<td>11111</td>\n<td>30ms</td>\n</tr>\n<tr>\n<td>100W随机删除50W</td>\n<td>10.499000</td>\n<td>7868409</td>\n<td>7855239</td>\n<td>22226</td>\n<td>0</td>\n<td>50ms</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>这也说明对普通的大表，想要通过delete数据来对表进行瘦身是不现实的，所以在任何时候不要用delete去删除数据，应该使用优雅的标记删除。</p>\n<h2><a name=\"t14\"></a><a name=\"t14\"></a><a id=\"delete_377\"></a>delete优化建议</h2>\n<h3><a name=\"t15\"></a><a name=\"t15\"></a><a id=\"_379\"></a>控制业务账号权限</h3>\n<p>对于一个大的系统来说，需要根据业务特点去拆分子系统，每个子系统可以看做是一个service，例如美团APP，上面有很多服务，核心的服务有用户服务user-service，搜索服务search-service，商品product-service，位置服务location-service，价格服务price-service等。每个服务对应一个数据库，为该数据库创建单独账号，同时只授予DML权限且没有delete权限，同时禁止跨库访问。</p>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#创建用户数据库并授权\ncreate database mt_user charset utf8mb4;\ngrant USAGE, SELECT, INSERT, UPDATE ON mt_user.*  to 'w_user'@'%' identified by 't$W*g@gaHTGi123456';\nflush privileges;\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n</ul>\n<h3><a name=\"t16\"></a><a name=\"t16\"></a><a id=\"delete_390\"></a>delete改为标记删除</h3>\n<p>在MySQL数据库建模规范中有4个公共字段，基本上每个表必须有的，同时在create_time列要创建索引，有两方面的好处：</p>\n<ol>\n<li>一些查询业务场景都会有一个默认的时间段，比如7天或者一个月，都是通过create_time去过滤，走索引扫描更快。</li>\n<li>一些核心的业务表需要以T +1的方式抽取数据仓库中，比如每天晚上00:30抽取前一天的数据，都是通过create_time过滤的。</li>\n</ol>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">`id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键id',\n`is_deleted` tinyint(4) NOT NULL DEFAULT '0' COMMENT '是否逻辑删除：0：未删除，1：已删除',\n`create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n`update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间'\n\n#有了删除标记，业务接口的delete操作就可以转换为update\nupdate user set is_deleted = 1 where user_id = 1213;\n\n#查询的时候需要带上is_deleted过滤\nselect id, age ,phone from user where is_deleted = 0 and name like 'lyn12%';\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n</ul>\n<h2><a name=\"t17\"></a><a name=\"t17\"></a><a id=\"_410\"></a>数据归档方式</h2>\n<h3><a name=\"t18\"></a><a name=\"t18\"></a><a id=\"_412\"></a>通用数据归档方法</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#1. 创建归档表，一般在原表名后面添加_bak。\nCREATE TABLE `ota_order_bak` (\n  `id` bigint(11) NOT NULL AUTO_INCREMENT COMMENT '主键',\n  `order_id` varchar(255) DEFAULT NULL COMMENT '订单id',\n  `ota_id` varchar(255) DEFAULT NULL COMMENT 'ota',\n  `check_in_date` varchar(255) DEFAULT NULL COMMENT '入住日期',\n  `check_out_date` varchar(255) DEFAULT NULL COMMENT '离店日期',\n  `hotel_id` varchar(255) DEFAULT NULL COMMENT '酒店ID',\n  `guest_name` varchar(255) DEFAULT NULL COMMENT '顾客',\n  `purcharse_time` timestamp NULL DEFAULT NULL COMMENT '购买时间',\n  `create_time` datetime DEFAULT NULL,\n  `update_time` datetime DEFAULT NULL,\n  `create_user` varchar(255) DEFAULT NULL,\n  `update_user` varchar(255) DEFAULT NULL,\n  `status` int(4) DEFAULT '1' COMMENT '状态 ： 1 正常 ， 0 删除',\n  `hotel_name` varchar(255) DEFAULT NULL,\n  `price` decimal(10,0) DEFAULT NULL,\n  `remark` longtext,\n  PRIMARY KEY (`id`),\n  KEY `IDX_order_id` (`order_id`) USING BTREE,\n  KEY `hotel_name` (`hotel_name`) USING BTREE,\n  KEY `ota_id` (`ota_id`) USING BTREE,\n  KEY `IDX_purcharse_time` (`purcharse_time`) USING BTREE,\n  KEY `IDX_create_time` (`create_time`) USING BTREE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8\nPARTITION BY RANGE (to_days(create_time)) ( \nPARTITION p201808 VALUES LESS THAN (to_days('2018-09-01')), \nPARTITION p201809 VALUES LESS THAN (to_days('2018-10-01')), \nPARTITION p201810 VALUES LESS THAN (to_days('2018-11-01')), \nPARTITION p201811 VALUES LESS THAN (to_days('2018-12-01')), \nPARTITION p201812 VALUES LESS THAN (to_days('2019-01-01')), \nPARTITION p201901 VALUES LESS THAN (to_days('2019-02-01')), \nPARTITION p201902 VALUES LESS THAN (to_days('2019-03-01')), \nPARTITION p201903 VALUES LESS THAN (to_days('2019-04-01')), \nPARTITION p201904 VALUES LESS THAN (to_days('2019-05-01')), \nPARTITION p201905 VALUES LESS THAN (to_days('2019-06-01')), \nPARTITION p201906 VALUES LESS THAN (to_days('2019-07-01')), \nPARTITION p201907 VALUES LESS THAN (to_days('2019-08-01')), \nPARTITION p201908 VALUES LESS THAN (to_days('2019-09-01')), \nPARTITION p201909 VALUES LESS THAN (to_days('2019-10-01')), \nPARTITION p201910 VALUES LESS THAN (to_days('2019-11-01')), \nPARTITION p201911 VALUES LESS THAN (to_days('2019-12-01')), \nPARTITION p201912 VALUES LESS THAN (to_days('2020-01-01')));\n\n#2. 插入原表中无效的数据（需要跟开发同学确认数据保留范围）\ncreate table tbl_p201808 as select * from ota_order where create_time between '2018-08-01 00:00:00' and '2018-08-31 23:59:59';\n\n#3. 跟归档表分区做分区交换\nalter table ota_order_bak exchange partition p201808 with table tbl_p201808; \n\n#4. 删除原表中已经规范的数据\ndelete from ota_order where create_time between '2018-08-01 00:00:00' and '2018-08-31 23:59:59' limit 3000;\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n<li>31</li>\n<li>32</li>\n<li>33</li>\n<li>34</li>\n<li>35</li>\n<li>36</li>\n<li>37</li>\n<li>38</li>\n<li>39</li>\n<li>40</li>\n<li>41</li>\n<li>42</li>\n<li>43</li>\n<li>44</li>\n<li>45</li>\n<li>46</li>\n<li>47</li>\n<li>48</li>\n<li>49</li>\n<li>50</li>\n<li>51</li>\n<li>52</li>\n</ul>\n<h3><a name=\"t19\"></a><a name=\"t19\"></a><a id=\"_469\"></a>优化后的归档方式</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#1. 创建中间表\nCREATE TABLE `ota_order_2020` (........) ENGINE=InnoDB DEFAULT CHARSET=utf8\nPARTITION BY RANGE (to_days(create_time)) ( \nPARTITION p201808 VALUES LESS THAN (to_days('2018-09-01')), \nPARTITION p201809 VALUES LESS THAN (to_days('2018-10-01')), \nPARTITION p201810 VALUES LESS THAN (to_days('2018-11-01')), \nPARTITION p201811 VALUES LESS THAN (to_days('2018-12-01')), \nPARTITION p201812 VALUES LESS THAN (to_days('2019-01-01')), \nPARTITION p201901 VALUES LESS THAN (to_days('2019-02-01')), \nPARTITION p201902 VALUES LESS THAN (to_days('2019-03-01')), \nPARTITION p201903 VALUES LESS THAN (to_days('2019-04-01')), \nPARTITION p201904 VALUES LESS THAN (to_days('2019-05-01')), \nPARTITION p201905 VALUES LESS THAN (to_days('2019-06-01')), \nPARTITION p201906 VALUES LESS THAN (to_days('2019-07-01')), \nPARTITION p201907 VALUES LESS THAN (to_days('2019-08-01')), \nPARTITION p201908 VALUES LESS THAN (to_days('2019-09-01')), \nPARTITION p201909 VALUES LESS THAN (to_days('2019-10-01')), \nPARTITION p201910 VALUES LESS THAN (to_days('2019-11-01')), \nPARTITION p201911 VALUES LESS THAN (to_days('2019-12-01')), \nPARTITION p201912 VALUES LESS THAN (to_days('2020-01-01')));\n\n#2. 插入原表中有效的数据，如果数据量在100W左右可以在业务低峰期直接插入，如果比较大，建议采用dataX来做，可以控制频率和大小，之前我这边用Go封装了dataX可以实现自动生成json文件，自定义大小去执行。\ninsert into ota_order_2020 select * from ota_order where create_time between '2020-08-01 00:00:00' and '2020-08-31 23:59:59';\n\n#3. 表重命名\nalter table ota_order rename to ota_order_bak;  \nalter table ota_order_2020 rename to ota_order;\n#4. 插入差异数据\ninsert into ota_order select * from ota_order_bak a where not exists (select 1 from ota_order b where a.id = b.id);\n#5. ota_order_bak改造成分区表，如果表比较大不建议直接改造，可以先创建好分区表，通过dataX把导入进去即可。\n\n#6. 后续的归档方法\n#创建中间普遍表\ncreate table ota_order_mid like ota_order;\n#交换原表无效数据分区到普通表\nalter table ota_order exchange partition p201808 with table ota_order_mid; \n##交换普通表数据到归档表的相应分区\nalter table ota_order_bak exchange partition p201808 with table ota_order_mid; \n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n<li>31</li>\n<li>32</li>\n<li>33</li>\n<li>34</li>\n<li>35</li>\n<li>36</li>\n<li>37</li>\n<li>38</li>\n</ul>\n<p>这样原表和归档表都是按月的分区表，只需要创建一个中间普通表，在业务低峰期做两次分区交换，既可以删除无效数据，又能回收空，而且没有空间碎片，不会影响表上的索引及SQL的执行计划。</p>\n<h2><a name=\"t20\"></a><a name=\"t20\"></a><a id=\"_514\"></a>总结</h2>\n<p>通过从InnoDB存储空间分布，delete对性能的影响可以看到，delete物理删除既不能释放磁盘空间，而且会产生大量的碎片，导致索引频繁分裂，影响SQL执行计划的稳定性；</p>\n<p>同时在碎片回收时，会耗用大量的CPU，磁盘空间，影响表上正常的DML操作。</p>\n<p>在业务代码层面，应该做逻辑标记删除，避免物理删除；为了实现数据归档需求，可以用采用MySQL分区表特性来实现，都是DDL操作，没有碎片产生。</p>\n<p>另外一个比较好的方案采用Clickhouse，对有生命周期的数据表可以使用Clickhouse存储，利用其TTL特性实现无效数据自动清理。</p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1330877080455553024","blogRead":0,"blogRemark":"MySQL","blogTitle":"面试官不讲武德问我：为什么MySQL不建议使用delete删除数据？","blogType":1,"createdTime":1606111996000,"version":3},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:27:49.704 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:28:57.304 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==>  Preparing: select blog_id, blog_title, blog_content, blog_goods, blog_image, blog_read, blog_collection, blog_type, blog_remark, blog_comment, blog_source, created_time, version from bl_blog where blog_id = ? and deleted = 0 
2020-12-24 23:28:57.305 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==> Parameters: 1324038097171820544(String)
2020-12-24 23:28:57.358 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -<==      Total: 1
2020-12-24 23:28:57.403 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:28:57.404 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/get/1324038097171820544(String), [1324038097171820544](String), 1(Integer), null, GET(String), 102(Long), {"code":20000,"data":{"blogCollection":0,"blogComment":0,"blogContent":"BeanUtils.copyProperties(a, b);b中的存在的属性，a中一定要有，但是a中可以有多余的属性；a中与b中相同的属性都会被替换，不管是否有值；a、 b中的属性要名字相同，才能被赋值，不然的话需要手动赋值；Spring的BeanUtils的CopyProperties方法需要对应的属性有getter和setter方法；如果存在属性完全相同的内部类，但是不是同一个内部类，即分别属于各自的内部类，则spring会认为属性不同，不会copy；spring和apache的copy属性的方法源和目的参数的位置正好相反，所以导包和调用的时候都要注意一下。","blogGoods":0,"blogId":"1324038097171820544","blogImage":"Java","blogRead":0,"blogRemark":"BeanUtils它提供了对java反射和自省API的包装。它里面还有很多工具类，这里我们介绍一下copyProperties。","blogSource":"百度","blogTitle":"BeanUtils.copyProperties的用法","blogType":1,"createdTime":1604481453000,"version":2},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:28:57.510 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:31:47.311 DEBUG [http-nio-8899-exec-4]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:31:47.312 DEBUG [http-nio-8899-exec-4]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /BlAdmin/info(String), [](String), 1(Integer), null, GET(String), 1(Long), {"code":20000,"data":{"name":"田起凯","password":"","signature":"hold on","username":"admin"},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:31:47.391 DEBUG [http-nio-8899-exec-4]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:31:47.668 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlTypeMapper.selectByExample.debug:159 -==>  Preparing: SELECT type_id,type_name,type_blog_count,enable,deleted FROM bl_type WHERE ( enable = ? and deleted = ? ) 
2020-12-24 23:31:47.669 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlTypeMapper.selectByExample.debug:159 -==> Parameters: 1(Integer), 0(Integer)
2020-12-24 23:31:47.699 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -==>  Preparing: select blog_id, blog_title, blog_image, blog_goods, blog_read, blog_collection, blog_remark, blog_comment, blog_source, created_time, update_time,type_name from bl_blog as b inner join bl_type as t on type_id = blog_type where t.deleted = 0 and b.deleted = 0 limit ?, ? 
2020-12-24 23:31:47.700 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -==> Parameters: 0(Integer), 10(Integer)
2020-12-24 23:31:47.706 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlTypeMapper.selectByExample.debug:159 -<==      Total: 7
2020-12-24 23:31:47.736 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -<==      Total: 3
2020-12-24 23:31:47.737 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -==>  Preparing: select count(*) from bl_blog as b inner join bl_type as t on type_id = blog_type where t.deleted = 0 and b.deleted = 0 
2020-12-24 23:31:47.738 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -==> Parameters: 
2020-12-24 23:31:47.744 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:31:47.745 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /type/getList(String), [](String), 1(Integer), null, GET(String), 81(Long), {"code":20000,"data":[{"deleted":0,"enable":1,"typeBlogCount":105,"typeId":1,"typeName":"Java"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"Python"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":6,"typeName":"going"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":7,"typeName":"Spring"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"nginx"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Redis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":10,"typeName":"Docker"}],"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:31:47.774 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -<==      Total: 1
2020-12-24 23:31:47.830 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:31:47.885 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:31:47.887 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/getByPage(String), [Page(currentPage=1, pageSize=10, totalPage=0, totalCount=0, list=[], params={}, sortColumn=null, sortMethod=asc)](String), 1(Integer), null, POST(String), 219(Long), {"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1324038097171820544","blogImage":"Java","blogRead":0,"blogRemark":"BeanUtils它提供了对java反射和自省API的包装。它里面还有很多工具类，这里我们介绍一下copyProperties。","blogSource":"百度","blogTitle":"BeanUtils.copyProperties的用法","createdTime":"2020-11-04 17:17:33","typeName":"Java","updateTime":"2020-11-22 13:04:15"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1330877080455553024","blogRead":0,"blogRemark":"MySQL","blogTitle":"面试官不讲武德问我：为什么MySQL不建议使用delete删除数据？","createdTime":"2020-11-23 14:13:16","typeName":"Java","updateTime":"2020-11-23 14:23:06"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1330879440221315072","blogRead":0,"blogRemark":"面试必备","blogTitle":"Java岗四面字节跳动成功之前，我都刷了那些面试题以及做了那些准备！","createdTime":"2020-11-23 14:22:39","typeName":"Java","updateTime":"2020-11-23 14:22:39"}],"pageSize":10,"params":{},"sortMethod":"asc","totalCount":3,"totalPage":1},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:31:47.971 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:31:51.691 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==>  Preparing: select blog_id, blog_title, blog_content, blog_goods, blog_image, blog_read, blog_collection, blog_type, blog_remark, blog_comment, blog_source, created_time, version from bl_blog where blog_id = ? and deleted = 0 
2020-12-24 23:31:51.692 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==> Parameters: 1324038097171820544(String)
2020-12-24 23:31:51.779 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -<==      Total: 1
2020-12-24 23:31:51.832 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:31:51.833 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/get/1324038097171820544(String), [1324038097171820544](String), 1(Integer), null, GET(String), 135(Long), {"code":20000,"data":{"blogCollection":0,"blogComment":0,"blogContent":"BeanUtils.copyProperties(a, b);b中的存在的属性，a中一定要有，但是a中可以有多余的属性；a中与b中相同的属性都会被替换，不管是否有值；a、 b中的属性要名字相同，才能被赋值，不然的话需要手动赋值；Spring的BeanUtils的CopyProperties方法需要对应的属性有getter和setter方法；如果存在属性完全相同的内部类，但是不是同一个内部类，即分别属于各自的内部类，则spring会认为属性不同，不会copy；spring和apache的copy属性的方法源和目的参数的位置正好相反，所以导包和调用的时候都要注意一下。","blogGoods":0,"blogId":"1324038097171820544","blogImage":"Java","blogRead":0,"blogRemark":"BeanUtils它提供了对java反射和自省API的包装。它里面还有很多工具类，这里我们介绍一下copyProperties。","blogSource":"百度","blogTitle":"BeanUtils.copyProperties的用法","blogType":1,"createdTime":1604481453000,"version":2},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:31:51.920 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:31:57.813 DEBUG [http-nio-8899-exec-8]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==>  Preparing: select blog_id, blog_title, blog_content, blog_goods, blog_image, blog_read, blog_collection, blog_type, blog_remark, blog_comment, blog_source, created_time, version from bl_blog where blog_id = ? and deleted = 0 
2020-12-24 23:31:57.814 DEBUG [http-nio-8899-exec-8]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==> Parameters: 1324038097171820544(String)
2020-12-24 23:31:57.851 DEBUG [http-nio-8899-exec-8]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -<==      Total: 1
2020-12-24 23:31:57.891 DEBUG [http-nio-8899-exec-8]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:31:57.892 DEBUG [http-nio-8899-exec-8]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/get/1324038097171820544(String), [1324038097171820544](String), 1(Integer), null, GET(String), 81(Long), {"code":20000,"data":{"blogCollection":0,"blogComment":0,"blogContent":"BeanUtils.copyProperties(a, b);b中的存在的属性，a中一定要有，但是a中可以有多余的属性；a中与b中相同的属性都会被替换，不管是否有值；a、 b中的属性要名字相同，才能被赋值，不然的话需要手动赋值；Spring的BeanUtils的CopyProperties方法需要对应的属性有getter和setter方法；如果存在属性完全相同的内部类，但是不是同一个内部类，即分别属于各自的内部类，则spring会认为属性不同，不会copy；spring和apache的copy属性的方法源和目的参数的位置正好相反，所以导包和调用的时候都要注意一下。","blogGoods":0,"blogId":"1324038097171820544","blogImage":"Java","blogRead":0,"blogRemark":"BeanUtils它提供了对java反射和自省API的包装。它里面还有很多工具类，这里我们介绍一下copyProperties。","blogSource":"百度","blogTitle":"BeanUtils.copyProperties的用法","blogType":1,"createdTime":1604481453000,"version":2},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:31:57.983 DEBUG [http-nio-8899-exec-8]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:35:58.925 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -==>  Preparing: select blog_id, blog_title, blog_image, blog_goods, blog_read, blog_collection, blog_remark, blog_comment, blog_source, created_time, update_time,type_name from bl_blog as b inner join bl_type as t on type_id = blog_type where t.deleted = 0 and b.deleted = 0 limit ?, ? 
2020-12-24 23:35:58.927 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -==> Parameters: 0(Integer), 10(Integer)
2020-12-24 23:35:58.968 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -<==      Total: 3
2020-12-24 23:35:58.969 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -==>  Preparing: select count(*) from bl_blog as b inner join bl_type as t on type_id = blog_type where t.deleted = 0 and b.deleted = 0 
2020-12-24 23:35:58.969 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -==> Parameters: 
2020-12-24 23:35:59.004 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -<==      Total: 1
2020-12-24 23:35:59.125 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:35:59.126 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/getByPage(String), [Page(currentPage=1, pageSize=10, totalPage=0, totalCount=0, list=[], params={}, sortColumn=null, sortMethod=asc)](String), 1(Integer), null, POST(String), 242(Long), {"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1324038097171820544","blogImage":"Java","blogRead":0,"blogRemark":"BeanUtils它提供了对java反射和自省API的包装。它里面还有很多工具类，这里我们介绍一下copyProperties。","blogSource":"百度","blogTitle":"BeanUtils.copyProperties的用法","createdTime":"2020-11-04 17:17:33","typeName":"Java","updateTime":"2020-11-22 13:04:15"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1330877080455553024","blogRead":0,"blogRemark":"MySQL","blogTitle":"面试官不讲武德问我：为什么MySQL不建议使用delete删除数据？","createdTime":"2020-11-23 14:13:16","typeName":"Java","updateTime":"2020-11-23 14:23:06"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1330879440221315072","blogRead":0,"blogRemark":"面试必备","blogTitle":"Java岗四面字节跳动成功之前，我都刷了那些面试题以及做了那些准备！","createdTime":"2020-11-23 14:22:39","typeName":"Java","updateTime":"2020-11-23 14:22:39"}],"pageSize":10,"params":{},"sortMethod":"asc","totalCount":3,"totalPage":1},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:35:59.206 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:36:34.231 DEBUG [http-nio-8899-exec-10]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -==>  Preparing: select blog_id, blog_title, blog_image, blog_goods, blog_read, blog_collection, blog_remark, blog_comment, blog_source, created_time, update_time,type_name from bl_blog as b inner join bl_type as t on type_id = blog_type where t.deleted = 0 and b.deleted = 0 limit ?, ? 
2020-12-24 23:36:34.232 DEBUG [http-nio-8899-exec-10]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -==> Parameters: 0(Integer), 10(Integer)
2020-12-24 23:36:34.271 DEBUG [http-nio-8899-exec-10]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -<==      Total: 3
2020-12-24 23:36:34.273 DEBUG [http-nio-8899-exec-10]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -==>  Preparing: select count(*) from bl_blog as b inner join bl_type as t on type_id = blog_type where t.deleted = 0 and b.deleted = 0 
2020-12-24 23:36:34.274 DEBUG [http-nio-8899-exec-10]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -==> Parameters: 
2020-12-24 23:36:34.315 DEBUG [http-nio-8899-exec-10]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -<==      Total: 1
2020-12-24 23:36:34.424 DEBUG [http-nio-8899-exec-10]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:36:34.426 DEBUG [http-nio-8899-exec-10]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/getByPage(String), [Page(currentPage=1, pageSize=10, totalPage=0, totalCount=0, list=[], params={}, sortColumn=null, sortMethod=asc)](String), 1(Integer), null, POST(String), 229(Long), {"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1324038097171820544","blogImage":"Java","blogRead":0,"blogRemark":"BeanUtils它提供了对java反射和自省API的包装。它里面还有很多工具类，这里我们介绍一下copyProperties。","blogSource":"百度","blogTitle":"BeanUtils.copyProperties的用法","createdTime":"2020-11-04 17:17:33","typeName":"Java","updateTime":"2020-11-22 13:04:15"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1330877080455553024","blogRead":0,"blogRemark":"MySQL","blogTitle":"面试官不讲武德问我：为什么MySQL不建议使用delete删除数据？","createdTime":"2020-11-23 14:13:16","typeName":"Java","updateTime":"2020-11-23 14:23:06"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1330879440221315072","blogRead":0,"blogRemark":"面试必备","blogTitle":"Java岗四面字节跳动成功之前，我都刷了那些面试题以及做了那些准备！","createdTime":"2020-11-23 14:22:39","typeName":"Java","updateTime":"2020-11-23 14:22:39"}],"pageSize":10,"params":{},"sortMethod":"asc","totalCount":3,"totalPage":1},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:36:34.521 DEBUG [http-nio-8899-exec-10]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:37:38.155 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:37:38.156 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /BlAdmin/info(String), [](String), 1(Integer), null, GET(String), 2(Long), {"code":20000,"data":{"name":"田起凯","password":"","signature":"hold on","username":"admin"},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:37:38.247 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:37:38.556 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlTypeMapper.selectByExample.debug:159 -==>  Preparing: SELECT type_id,type_name,type_blog_count,enable,deleted FROM bl_type WHERE ( enable = ? and deleted = ? ) 
2020-12-24 23:37:38.557 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlTypeMapper.selectByExample.debug:159 -==> Parameters: 1(Integer), 0(Integer)
2020-12-24 23:37:38.592 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -==>  Preparing: select blog_id, blog_title, blog_image, blog_goods, blog_read, blog_collection, blog_remark, blog_comment, blog_source, created_time, update_time,type_name from bl_blog as b inner join bl_type as t on type_id = blog_type where t.deleted = 0 and b.deleted = 0 limit ?, ? 
2020-12-24 23:37:38.593 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlTypeMapper.selectByExample.debug:159 -<==      Total: 7
2020-12-24 23:37:38.593 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -==> Parameters: 0(Integer), 10(Integer)
2020-12-24 23:37:38.632 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -<==      Total: 3
2020-12-24 23:37:38.633 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:37:38.633 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -==>  Preparing: select count(*) from bl_blog as b inner join bl_type as t on type_id = blog_type where t.deleted = 0 and b.deleted = 0 
2020-12-24 23:37:38.633 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /type/getList(String), [](String), 1(Integer), null, GET(String), 82(Long), {"code":20000,"data":[{"deleted":0,"enable":1,"typeBlogCount":105,"typeId":1,"typeName":"Java"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"Python"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":6,"typeName":"going"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":7,"typeName":"Spring"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"nginx"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Redis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":10,"typeName":"Docker"}],"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:37:38.633 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -==> Parameters: 
2020-12-24 23:37:38.669 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -<==      Total: 1
2020-12-24 23:37:38.714 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:37:38.777 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:37:38.778 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/getByPage(String), [Page(currentPage=1, pageSize=10, totalPage=0, totalCount=0, list=[], params={}, sortColumn=null, sortMethod=asc)](String), 1(Integer), null, POST(String), 227(Long), {"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1324038097171820544","blogImage":"Java","blogRead":0,"blogRemark":"BeanUtils它提供了对java反射和自省API的包装。它里面还有很多工具类，这里我们介绍一下copyProperties。","blogSource":"百度","blogTitle":"BeanUtils.copyProperties的用法","createdTime":"2020-11-04 17:17:33","typeName":"Java","updateTime":"2020-11-22 13:04:15"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1330877080455553024","blogRead":0,"blogRemark":"MySQL","blogTitle":"面试官不讲武德问我：为什么MySQL不建议使用delete删除数据？","createdTime":"2020-11-23 14:13:16","typeName":"Java","updateTime":"2020-11-23 14:23:06"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1330879440221315072","blogRead":0,"blogRemark":"面试必备","blogTitle":"Java岗四面字节跳动成功之前，我都刷了那些面试题以及做了那些准备！","createdTime":"2020-11-23 14:22:39","typeName":"Java","updateTime":"2020-11-23 14:22:39"}],"pageSize":10,"params":{},"sortMethod":"asc","totalCount":3,"totalPage":1},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:37:38.869 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:37:42.019 DEBUG [http-nio-8899-exec-4]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -==>  Preparing: select blog_id, blog_title, blog_image, blog_goods, blog_read, blog_collection, blog_remark, blog_comment, blog_source, created_time, update_time,type_name from bl_blog as b inner join bl_type as t on type_id = blog_type where t.deleted = 0 and b.deleted = 0 limit ?, ? 
2020-12-24 23:37:42.020 DEBUG [http-nio-8899-exec-4]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -==> Parameters: 0(Integer), 10(Integer)
2020-12-24 23:37:42.058 DEBUG [http-nio-8899-exec-4]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -<==      Total: 3
2020-12-24 23:37:42.060 DEBUG [http-nio-8899-exec-4]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -==>  Preparing: select count(*) from bl_blog as b inner join bl_type as t on type_id = blog_type where t.deleted = 0 and b.deleted = 0 
2020-12-24 23:37:42.061 DEBUG [http-nio-8899-exec-4]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -==> Parameters: 
2020-12-24 23:37:42.097 DEBUG [http-nio-8899-exec-4]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -<==      Total: 1
2020-12-24 23:37:42.210 DEBUG [http-nio-8899-exec-4]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:37:42.211 DEBUG [http-nio-8899-exec-4]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/getByPage(String), [Page(currentPage=1, pageSize=10, totalPage=1, totalCount=3, list=[BlogVo(blogId=1324038097171820544, blogTitle=BeanUtils.copyProperties的用法, blogImage=Java, blogContent=null, blogGoods=0, blogRead=0, blogCollection=0, typeName=Java, blogSource=百度, blogRemark=BeanUtils它提供了对java反射和自省API的包装。它里面还有很多工具类，这里我们介绍一下copyProperties。, blogComment=0, blogMonth=null, createdTime=2020-11-04 17:17:33, updateTime=2020-11-22 13:04:15), BlogVo(blogId=1330877080455553024, blogTitle=面试官不讲武德问我：为什么MySQL不建议使用delete删除数据？, blogImage=null, blogContent=null, blogGoods=0, blogRead=0, blogCollection=0, typeName=Java, blogSource=null, blogRemark=MySQL, blogComment=0, blogMonth=null, createdTime=2020-11-23 14:13:16, updateTime=2020-11-23 14:23:06), BlogVo(blogId=1330879440221315072, blogTitle=Java岗四面字节跳动成功之前，我都刷了那些面试题以及做了那些准备！, blogImage=null, blogContent=null, blogGoods=0, blogRead=0, blogCollection=0, typeName=Java, blogSource=null, blogRemark=面试必备, blogComment=0, blogMonth=null, createdTime=2020-11-23 14:22:39, updateTime=2020-11-23 14:22:39)], params={}, sortColumn=null, sortMethod=asc)](String), 1(Integer), null, POST(String), 230(Long), {"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1324038097171820544","blogImage":"Java","blogRead":0,"blogRemark":"BeanUtils它提供了对java反射和自省API的包装。它里面还有很多工具类，这里我们介绍一下copyProperties。","blogSource":"百度","blogTitle":"BeanUtils.copyProperties的用法","createdTime":"2020-11-04 17:17:33","typeName":"Java","updateTime":"2020-11-22 13:04:15"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1330877080455553024","blogRead":0,"blogRemark":"MySQL","blogTitle":"面试官不讲武德问我：为什么MySQL不建议使用delete删除数据？","createdTime":"2020-11-23 14:13:16","typeName":"Java","updateTime":"2020-11-23 14:23:06"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1330879440221315072","blogRead":0,"blogRemark":"面试必备","blogTitle":"Java岗四面字节跳动成功之前，我都刷了那些面试题以及做了那些准备！","createdTime":"2020-11-23 14:22:39","typeName":"Java","updateTime":"2020-11-23 14:22:39"}],"pageSize":10,"params":{},"sortMethod":"asc","totalCount":3,"totalPage":1},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:37:42.292 DEBUG [http-nio-8899-exec-4]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:37:48.971 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==>  Preparing: select blog_id, blog_title, blog_content, blog_goods, blog_image, blog_read, blog_collection, blog_type, blog_remark, blog_comment, blog_source, created_time, version from bl_blog where blog_id = ? and deleted = 0 
2020-12-24 23:37:48.972 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==> Parameters: 1324038097171820544(String)
2020-12-24 23:37:49.007 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -<==      Total: 1
2020-12-24 23:37:49.046 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:37:49.048 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/get/1324038097171820544(String), [1324038097171820544](String), 1(Integer), null, GET(String), 78(Long), {"code":20000,"data":{"blogCollection":0,"blogComment":0,"blogContent":"BeanUtils.copyProperties(a, b);b中的存在的属性，a中一定要有，但是a中可以有多余的属性；a中与b中相同的属性都会被替换，不管是否有值；a、 b中的属性要名字相同，才能被赋值，不然的话需要手动赋值；Spring的BeanUtils的CopyProperties方法需要对应的属性有getter和setter方法；如果存在属性完全相同的内部类，但是不是同一个内部类，即分别属于各自的内部类，则spring会认为属性不同，不会copy；spring和apache的copy属性的方法源和目的参数的位置正好相反，所以导包和调用的时候都要注意一下。","blogGoods":0,"blogId":"1324038097171820544","blogImage":"Java","blogRead":0,"blogRemark":"BeanUtils它提供了对java反射和自省API的包装。它里面还有很多工具类，这里我们介绍一下copyProperties。","blogSource":"百度","blogTitle":"BeanUtils.copyProperties的用法","blogType":1,"createdTime":1604481453000,"version":2},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:37:49.132 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:37:52.245 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==>  Preparing: select blog_id, blog_title, blog_content, blog_goods, blog_image, blog_read, blog_collection, blog_type, blog_remark, blog_comment, blog_source, created_time, version from bl_blog where blog_id = ? and deleted = 0 
2020-12-24 23:37:52.247 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==> Parameters: 1324038097171820544(String)
2020-12-24 23:37:52.285 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -<==      Total: 1
2020-12-24 23:37:52.327 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:37:52.328 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/get/1324038097171820544(String), [1324038097171820544](String), 1(Integer), null, GET(String), 94(Long), {"code":20000,"data":{"blogCollection":0,"blogComment":0,"blogContent":"BeanUtils.copyProperties(a, b);b中的存在的属性，a中一定要有，但是a中可以有多余的属性；a中与b中相同的属性都会被替换，不管是否有值；a、 b中的属性要名字相同，才能被赋值，不然的话需要手动赋值；Spring的BeanUtils的CopyProperties方法需要对应的属性有getter和setter方法；如果存在属性完全相同的内部类，但是不是同一个内部类，即分别属于各自的内部类，则spring会认为属性不同，不会copy；spring和apache的copy属性的方法源和目的参数的位置正好相反，所以导包和调用的时候都要注意一下。","blogGoods":0,"blogId":"1324038097171820544","blogImage":"Java","blogRead":0,"blogRemark":"BeanUtils它提供了对java反射和自省API的包装。它里面还有很多工具类，这里我们介绍一下copyProperties。","blogSource":"百度","blogTitle":"BeanUtils.copyProperties的用法","blogType":1,"createdTime":1604481453000,"version":2},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:37:52.459 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:37:53.922 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==>  Preparing: select blog_id, blog_title, blog_content, blog_goods, blog_image, blog_read, blog_collection, blog_type, blog_remark, blog_comment, blog_source, created_time, version from bl_blog where blog_id = ? and deleted = 0 
2020-12-24 23:37:53.923 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==> Parameters: 1330877080455553024(String)
2020-12-24 23:37:54.036 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -<==      Total: 1
2020-12-24 23:37:54.090 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:37:54.094 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/get/1330877080455553024(String), [1330877080455553024](String), 1(Integer), null, GET(String), 158(Long), {"code":20000,"data":{"blogCollection":0,"blogComment":0,"blogContent":"<h2>前言</h2>\n<p>我负责的有几个系统随着业务量的增长，存储在MySQL中的数据日益剧增，我当时就想现在的业务方不讲武德，搞偷袭，趁我没反应过来把很多表，很快，很快啊都打到了亿级别，我大意了，没有闪，这就导致跟其Join的表的SQL变得很慢，对的应用接口的response time也变长了，影响了用户体验。</p>\n<p>事后我找到业务方，我批评了他们跟他们说要讲武德，连忙跟我道歉，这个事情才就此作罢，走的时候我对他们说下次不要这样了，耗子尾汁，好好反思。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/3c93aececcb9e763f5476362c4e88710.png\" alt=\"\" /></p>\n<p>骂归骂，事情还是得解决，时候我分析原因发现，发现有些表的数据量增长很快，对应SQL扫描了很多无效数据，导致SQL慢了下来，通过确认之后，这些大表都是一些流水、记录、日志类型数据，只需要保留1到3个月，此时需要对表做数据清理实现瘦身，一般都会想到用insert + delete的方式去清理。</p>\n<p>这篇文章我会从InnoDB存储空间分布，delete对性能的影响，以及优化建议方面解释为什么不建议delete删除数据。</p>\n<h2><a name=\"t1\"></a><a name=\"t1\"></a><a id=\"InnoDB_16\"></a>InnoDB存储架构</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/5c66ffe9749c58e1613d2519f7ea7211.png\" alt=\"\" /></p>\n<p>从这张图可以看到，InnoDB存储结构主要包括两部分：逻辑存储结构和物理存储结构。</p>\n<p>逻辑上是由表空间tablespace &mdash;&gt; 段segment或者inode &mdash;&gt; 区Extent &mdash;&mdash;&gt;数据页Page构成，Innodb逻辑管理单位是segment，空间分配的最小单位是extent，每个segment都会从表空间FREE_PAGE中分配32个page，当这32个page不够用时，会按照以下原则进行扩展：如果当前小于1个extent，则扩展到1个extent；当表空间小于32MB时，每次扩展一个extent；表空间大于32MB，每次扩展4个extent。</p>\n<p>物理上主要由系统用户数据文件，日志文件组成，数据文件主要存储MySQL字典数据和用户数据，日志文件记录的是data page的变更记录，用于MySQL Crash时的恢复。</p>\n<h2><a name=\"t2\"></a><a name=\"t2\"></a><a id=\"Innodb_26\"></a>Innodb表空间</h2>\n<p>InnoDB存储包括三类表空间：系统表空间，用户表空间，Undo表空间。</p>\n<p><strong>系统表空间：</strong>&nbsp;主要存储MySQL内部的数据字典数据，如information_schema下的数据。</p>\n<p><strong>用户表空间：</strong>&nbsp;当开启innodb_file_per_table=1时，数据表从系统表空间独立出来存储在以table_name.ibd命令的数据文件中，结构信息存储在table_name.frm文件中。</p>\n<p><strong>Undo表空间：</strong>&nbsp;存储Undo信息，如快照一致读和flashback都是利用undo信息。</p>\n<p>从MySQL 8.0开始允许用户自定义表空间，具体语法如下：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">CREATE TABLESPACE tablespace_name\n    ADD DATAFILE 'file_name'               #数据文件名\n    USE LOGFILE GROUP logfile_group        #自定义日志文件组，一般每组2个logfile。\n    [EXTENT_SIZE [=] extent_size]          #区大小\n    [INITIAL_SIZE [=] initial_size]        #初始化大小 \n    [AUTOEXTEND_SIZE [=] autoextend_size]  #自动扩宽尺寸\n    [MAX_SIZE [=] max_size]                #单个文件最大size，最大是32G。\n    [NODEGROUP [=] nodegroup_id]           #节点组\n    [WAIT]\n    [COMMENT [=] comment_text]\n    ENGINE [=] engine_name\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n</ul>\n<p>这样的好处是可以做到数据的冷热分离，分别用HDD和SSD来存储，既能实现数据的高效访问，又能节约成本，比如可以添加两块500G硬盘，经过创建卷组vg，划分逻辑卷lv，创建数据目录并mount相应的lv，假设划分的两个目录分别是/hot_data 和 /cold_data。</p>\n<p>这样就可以将核心的业务表如用户表，订单表存储在高性能SSD盘上，一些日志，流水表存储在普通的HDD上，主要的操作步骤如下：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#创建热数据表空间\ncreate tablespace tbs_data_hot add datafile '/hot_data/tbs_data_hot01.dbf' max_size 20G;\n#创建核心业务表存储在热数据表空间\ncreate table booking(id bigint not null primary key auto_increment, &hellip;&hellip; ) tablespace tbs_data_hot;\n#创建冷数据表空间\ncreate tablespace tbs_data_cold add datafile '/hot_data/tbs_data_cold01.dbf' max_size 20G;\n#创建日志，流水，备份类的表存储在冷数据表空间\ncreate table payment_log(id bigint not null primary key auto_increment, &hellip;&hellip; ) tablespace tbs_data_cold;\n#可以移动表到另一个表空间\nalter table payment_log tablespace tbs_data_hot;\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n</ul>\n<h2><a name=\"t3\"></a><a name=\"t3\"></a><a id=\"Inndob_69\"></a>Inndob存储分布</h2>\n<h3><a name=\"t4\"></a><a name=\"t4\"></a><a id=\"_71\"></a>创建空表查看空间变化</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; create table user(id bigint not null primary key auto_increment, \n    -&gt; name varchar(20) not null default '' comment '姓名', \n    -&gt; age tinyint not null default 0 comment 'age', \n    -&gt; gender char(1) not null default 'M'  comment '性别',\n    -&gt; phone varchar(16) not null default '' comment '手机号',\n    -&gt; create_time datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n    -&gt; update_time datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间'\n    -&gt; ) engine = InnoDB DEFAULT CHARSET=utf8mb4 COMMENT '用户信息表';\nQuery OK, 0 rows affected (0.26 sec)\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n</ul>\n<pre class=\"prettyprint\"><code class=\"prism language-bash has-numbering\"><span class=\"token comment\"># ls -lh user1.ibd </span>\n-rw-r----- 1 mysql mysql 96K Nov  6 12:48 user.ibd\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n</ul>\n<p>设置参数innodb_file_per_table=1时，创建表时会自动创建一个segment，同时分配一个extent，包含32个data page的来存储数据，这样创建的空表默认大小就是96KB，extent使用完之后会申请64个连接页，这样对于一些小表，或者undo segment，可以在开始时申请较少的空间，节省磁盘容量的开销。</p>\n<pre class=\"prettyprint\"><code class=\"prism language-shell has-numbering\"><span class=\"token comment\"># python2 py_innodb_page_info.py -v /data2/mysql/test/user.ibd</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>File Space Header<span class=\"token operator\">&gt;</span>\npage offset 00000001, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Insert Buffer Bitmap<span class=\"token operator\">&gt;</span>\npage offset 00000002, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>File Segment inode<span class=\"token operator\">&gt;</span>\npage offset 00000003, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>B-tree Node<span class=\"token operator\">&gt;</span>, page level <span class=\"token operator\">&lt;</span>0000<span class=\"token operator\">&gt;</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Freshly Allocated Page<span class=\"token operator\">&gt;</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Freshly Allocated Page<span class=\"token operator\">&gt;</span>\nTotal number of page: 6:      <span class=\"token comment\">#总共分配的页数</span>\nFreshly Allocated Page: 2     <span class=\"token comment\">#可用的数据页</span>\nInsert Buffer Bitmap: 1       <span class=\"token comment\">#插入缓冲页</span>\nFile Space Header: 1          <span class=\"token comment\">#文件空间头</span>\nB-tree Node: 1                <span class=\"token comment\">#数据页</span>\nFile Segment inode: 1         <span class=\"token comment\">#文件端inonde，如果是在ibdata1.ibd上会有多个inode。</span>\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n</ul>\n<h3><a name=\"t5\"></a><a name=\"t5\"></a><a id=\"_108\"></a>插入数据后的空间变化</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; DELIMITER $$\nmysql&gt; CREATE PROCEDURE insert_user_data(num INTEGER) \n    -&gt; BEGIN\n    -&gt;     DECLARE v_i int unsigned DEFAULT 0;\n    -&gt; set autocommit= 0;\n    -&gt; WHILE v_i &lt; num DO\n    -&gt;    insert into user(`name`, age, gender, phone) values (CONCAT('lyn',v_i), mod(v_i,120), 'M', CONCAT('152',ROUND(RAND(1)*100000000)));\n    -&gt;  SET v_i = v_i+1;\n    -&gt; END WHILE;\n    -&gt; commit;\n    -&gt; END $$\nQuery OK, 0 rows affected (0.01 sec)\nmysql&gt; DELIMITER ;\n\n#插入10w数据\nmysql&gt; call insert_user_data(100000);\nQuery OK, 0 rows affected (6.69 sec)\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n</ul>\n<pre class=\"prettyprint\"><code class=\"prism language-shell has-numbering\"><span class=\"token comment\"># ls -lh user.ibd</span>\n-rw-r----- 1 mysql mysql 14M Nov 6 10:58 /data2/mysql/test/user.ibd\n\n<span class=\"token comment\"># python2 py_innodb_page_info.py -v /data2/mysql/test/user.ibd</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>File Space Header<span class=\"token operator\">&gt;</span>\npage offset 00000001, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Insert Buffer Bitmap<span class=\"token operator\">&gt;</span>\npage offset 00000002, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>File Segment inode<span class=\"token operator\">&gt;</span>\npage offset 00000003, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>B-tree Node<span class=\"token operator\">&gt;</span>, page level <span class=\"token operator\">&lt;</span>0001<span class=\"token operator\">&gt;</span>   <span class=\"token comment\">#增加了一个非叶子节点，树的高度从1变为2.</span>\n<span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Freshly Allocated Page<span class=\"token operator\">&gt;</span>\nTotal number of page: 896:\nFreshly Allocated Page: 493\nInsert Buffer Bitmap: 1\nFile Space Header: 1\nB-tree Node: 400\nFile Segment inode: 1\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n</ul>\n<h3><a name=\"t6\"></a><a name=\"t6\"></a><a id=\"delete_149\"></a>delete数据后的空间变化</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; select min(id),max(id),count(*) from user;\n+---------+---------+----------+\n| min(id) | max(id) | count(*) |\n+---------+---------+----------+\n|       1 |  100000 |   100000 |\n+---------+---------+----------+\n1 row in set (0.05 sec)\n#删除50000条数据，理论上空间应该从14MB变长7MB左右。\nmysql&gt; delete from user limit 50000;\nQuery OK, 50000 rows affected (0.25 sec)\n\n#数据文件大小依然是14MB，没有缩小。\n# ls -lh /data2/mysql/test/user1.ibd \n-rw-r----- 1 mysql mysql 14M Nov  6 13:22 /data2/mysql/test/user.ibd\n\n#数据页没有被回收。\n# python2 py_innodb_page_info.py -v /data2/mysql/test/user.ibd\npage offset 00000000, page type &lt;File Space Header&gt;\npage offset 00000001, page type &lt;Insert Buffer Bitmap&gt;\npage offset 00000002, page type &lt;File Segment inode&gt;\npage offset 00000003, page type &lt;B-tree Node&gt;, page level &lt;0001&gt;\n........................................................\npage offset 00000000, page type &lt;Freshly Allocated Page&gt;\nTotal number of page: 896:\nFreshly Allocated Page: 493\nInsert Buffer Bitmap: 1\nFile Space Header: 1\nB-tree Node: 400\nFile Segment inode: 1\n#在MySQL内部是标记删除，\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n</ul>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; use information_schema;\n\nDatabase changed\nmysql&gt; SELECT A.SPACE AS TBL_SPACEID, A.TABLE_ID, A.NAME AS TABLE_NAME, FILE_FORMAT, ROW_FORMAT, SPACE_TYPE,  B.INDEX_ID , B.NAME AS INDEX_NAME, PAGE_NO, B.TYPE AS INDEX_TYPE FROM INNODB_SYS_TABLES A LEFT JOIN INNODB_SYS_INDEXES B ON A.TABLE_ID =B.TABLE_ID WHERE A.NAME = 'test/user1';\n+-------------+----------+------------+-------------+------------+------------+----------+------------+---------+------------+\n| TBL_SPACEID | TABLE_ID | TABLE_NAME | FILE_FORMAT | ROW_FORMAT | SPACE_TYPE | INDEX_ID | INDEX_NAME | PAGE_NO | INDEX_TYPE |\n+-------------+----------+------------+-------------+------------+------------+----------+------------+---------+------------+\n|        1283 |     1207 | test/user | Barracuda   | Dynamic    | Single     |     2236 | PRIMARY    |       3 |          3 |\n+-------------+----------+------------+-------------+------------+------------+----------+------------+---------+------------+\n1 row in set (0.01 sec)\n\nPAGE_NO = 3 标识B-tree的root page是3号页，INDEX_TYPE = 3是聚集索引。 INDEX_TYPE取值如下：\n0 = nonunique secondary index; \n1 = automatically generated clustered index (GEN_CLUST_INDEX); \n2 = unique nonclustered index; \n3 = clustered index; \n32 = full-text index;\n#收缩空间再后进行观察\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n</ul>\n<p>MySQL内部不会真正删除空间，而且做标记删除，即将delflag:N修改为delflag:Y，commit之后会会被purge进入删除链表，如果下一次insert更大的记录，delete之后的空间不会被重用，如果插入的记录小于等于delete的记录空会被重用，这块内容可以通过知数堂的innblock工具进行分析。</p>\n<h2><a name=\"t7\"></a><a name=\"t7\"></a><a id=\"Innodb_207\"></a>Innodb中的碎片</h2>\n<h3><a name=\"t8\"></a><a name=\"t8\"></a><a id=\"_209\"></a>碎片的产生</h3>\n<p>我们知道数据存储在文件系统上的，总是不能100%利用分配给它的物理空间，删除数据会在页面上留下一些&rdquo;空洞&rdquo;，或者随机写入（聚集索引非线性增加）会导致页分裂，页分裂导致页面的利用空间少于50%，另外对表进行增删改会引起对应的二级索引值的随机的增删改，也会导致索引结构中的数据页面上留下一些\"空洞\"，虽然这些空洞有可能会被重复利用，但终究会导致部分物理空间未被使用，也就是碎片。</p>\n<p>同时，即便是设置了填充因子为100%，Innodb也会主动留下page页面1/16的空间作为预留使用（An innodb_fill_factor setting of 100 leaves 1/16 of the space in clustered index pages free for future index growth）防止update带来的行溢出。</p>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; select table_schema,\n    -&gt;        table_name,ENGINE,\n    -&gt;        round(DATA_LENGTH/1024/1024+ INDEX_LENGTH/1024/1024) total_mb,TABLE_ROWS,\n    -&gt;        round(DATA_LENGTH/1024/1024) data_mb, round(INDEX_LENGTH/1024/1024) index_mb, round(DATA_FREE/1024/1024) free_mb, round(DATA_FREE/DATA_LENGTH*100,2) free_ratio\n    -&gt; from information_schema.TABLES where  TABLE_SCHEMA= 'test'\n    -&gt; and TABLE_NAME= 'user';\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n| table_schema | table_name | ENGINE | total_mb | TABLE_ROWS | data_mb | index_mb | free_mb | free_ratio |\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n| test         | user      | InnoDB |        4 |      50000 |       4 |        0 |       6 |     149.42 |\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n1 row in set (0.00 sec)\n\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n</ul>\n<p>其中data_free是分配了未使用的字节数，并不能说明完全是碎片空间。</p>\n<h3><a name=\"t9\"></a><a name=\"t9\"></a><a id=\"_233\"></a>碎片的回收</h3>\n<p>对于InnoDB的表，可以通过以下命令来回收碎片，释放空间，这个是随机读IO操作，会比较耗时，也会阻塞表上正常的DML运行，同时需要占用额外更多的磁盘空间，对于RDS来说，可能会导致磁盘空间瞬间爆满，实例瞬间被锁定，应用无法做DML操作，所以禁止在线上环境去执行。</p>\n<pre class=\"prettyprint\"><code class=\"prism language-shell has-numbering\"><span class=\"token comment\">#执行InnoDB的碎片回收</span>\nmysql<span class=\"token operator\">&gt;</span> alter table user engine<span class=\"token operator\">=</span>InnoDB<span class=\"token punctuation\">;</span>\nQuery OK, 0 rows affected <span class=\"token punctuation\">(</span>9.00 sec<span class=\"token punctuation\">)</span>\nRecords: 0  Duplicates: 0  Warnings: 0\n\n<span class=\"token comment\">##执行完之后，数据文件大小从14MB降低到10M。</span>\n<span class=\"token comment\"># ls -lh /data2/mysql/test/user1.ibd </span>\n-rw-r----- 1 mysql mysql 10M Nov 6 16:18 /data2/mysql/test/user.ibd\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n</ul>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; select table_schema,        table_name,ENGINE,        round(DATA_LENGTH/1024/1024+ INDEX_LENGTH/1024/1024) total_mb,TABLE_ROWS,        round(DATA_LENGTH/1024/1024) data_mb, round(INDEX_LENGTH/1024/1024) index_mb, round(DATA_FREE/1024/1024) free_mb, round(DATA_FREE/DATA_LENGTH*100,2) free_ratio from information_schema.TABLES where  TABLE_SCHEMA= 'test' and TABLE_NAME= 'user';\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n| table_schema | table_name | ENGINE | total_mb | TABLE_ROWS | data_mb | index_mb | free_mb | free_ratio |\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n| test         | user      | InnoDB |        5 |      50000 |       5 |        0 |       2 |      44.29 |\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n1 row in set (0.00 sec)\n\n\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n</ul>\n<h2><a name=\"t10\"></a><a name=\"t10\"></a><a id=\"deleteSQL_260\"></a>delete对SQL的影响</h2>\n<h3><a name=\"t11\"></a><a name=\"t11\"></a><a id=\"SQL_262\"></a>未删除前的SQL执行情况</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#插入100W数据\nmysql&gt; call insert_user_data(1000000);\nQuery OK, 0 rows affected (35.99 sec)\n\n#添加相关索引\nmysql&gt; alter table user add index idx_name(name), add index idx_phone(phone);\nQuery OK, 0 rows affected (6.00 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\n#表上索引统计信息\nmysql&gt; show index from user;\n+-------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+\n| Table | Non_unique | Key_name  | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |\n+-------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+\n| user  |          0 | PRIMARY   |            1 | id          | A         |      996757 |     NULL | NULL   |      | BTREE      |         |               |\n| user  |          1 | idx_name  |            1 | name        | A         |      996757 |     NULL | NULL   |      | BTREE      |         |               |\n| user  |          1 | idx_phone |            1 | phone       | A         |           2 |     NULL | NULL   |      | BTREE      |         |               |\n+-------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+\n3 rows in set (0.00 sec)\n\n#重置状态变量计数\nmysql&gt; flush status;\nQuery OK, 0 rows affected (0.00 sec)\n\n#执行SQL语句\nmysql&gt; select id, age ,phone from user where name like 'lyn12%';\n+--------+-----+-------------+\n| id     | age | phone       |\n+--------+-----+-------------+\n|    124 |   3 | 15240540354 |\n|   1231 |  30 | 15240540354 |\n|  12301 |  60 | 15240540354 |\n.............................\n| 129998 |  37 | 15240540354 |\n| 129999 |  38 | 15240540354 |\n| 130000 |  39 | 15240540354 |\n+--------+-----+-------------+\n11111 rows in set (0.03 sec)\n\nmysql&gt; explain select id, age ,phone from user where name like 'lyn12%';\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n| id | select_type | table | type  | possible_keys | key      | key_len | ref  | rows  | Extra                 |\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n|  1 | SIMPLE      | user  | range | idx_name      | idx_name | 82      | NULL | 22226 | Using index condition |\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n1 row in set (0.00 sec)\n\n#查看相关状态呢变量\nmysql&gt; select * from information_schema.session_status where variable_name in('Last_query_cost','Handler_read_next','Innodb_pages_read','Innodb_data_reads','Innodb_pages_read');\n+-------------------+----------------+\n| VARIABLE_NAME     | VARIABLE_VALUE |\n+-------------------+----------------+\n| HANDLER_READ_NEXT | 11111          |    #请求读的行数\n| INNODB_DATA_READS | 7868409        |    #数据物理读的总数\n| INNODB_PAGES_READ | 7855239        |    #逻辑读的总数\n| LAST_QUERY_COST   | 10.499000      |    #SQL语句的成本COST，主要包括IO_COST和CPU_COST。\n+-------------------+----------------+\n4 rows in set (0.00 sec)\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n<li>31</li>\n<li>32</li>\n<li>33</li>\n<li>34</li>\n<li>35</li>\n<li>36</li>\n<li>37</li>\n<li>38</li>\n<li>39</li>\n<li>40</li>\n<li>41</li>\n<li>42</li>\n<li>43</li>\n<li>44</li>\n<li>45</li>\n<li>46</li>\n<li>47</li>\n<li>48</li>\n<li>49</li>\n<li>50</li>\n<li>51</li>\n<li>52</li>\n<li>53</li>\n<li>54</li>\n<li>55</li>\n<li>56</li>\n<li>57</li>\n<li>58</li>\n</ul>\n<h3><a name=\"t12\"></a><a name=\"t12\"></a><a id=\"SQL_325\"></a>删除后的SQL执行情况</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#删除50w数据\nmysql&gt; delete from user limit 500000;\nQuery OK, 500000 rows affected (3.70 sec)\n\n#分析表统计信息\nmysql&gt; analyze table user;\n+-----------+---------+----------+----------+\n| Table     | Op      | Msg_type | Msg_text |\n+-----------+---------+----------+----------+\n| test.user | analyze | status   | OK       |\n+-----------+---------+----------+----------+\n1 row in set (0.01 sec)\n\n#重置状态变量计数\nmysql&gt; flush status;\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql&gt; select id, age ,phone from user where name like 'lyn12%';\nEmpty set (0.05 sec)\n\nmysql&gt; explain select id, age ,phone from user where name like 'lyn12%';\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n| id | select_type | table | type  | possible_keys | key      | key_len | ref  | rows  | Extra                 |\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n|  1 | SIMPLE      | user  | range | idx_name      | idx_name | 82      | NULL | 22226 | Using index condition |\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n1 row in set (0.00 sec)\n\nmysql&gt; select * from information_schema.session_status where variable_name in('Last_query_cost','Handler_read_next','Innodb_pages_read','Innodb_data_reads','Innodb_pages_read');\n+-------------------+----------------+\n| VARIABLE_NAME     | VARIABLE_VALUE |\n+-------------------+----------------+\n| HANDLER_READ_NEXT | 0              |\n| INNODB_DATA_READS | 7868409        |\n| INNODB_PAGES_READ | 7855239        |\n| LAST_QUERY_COST   | 10.499000      |\n+-------------------+----------------+\n4 rows in set (0.00 sec)\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n<li>31</li>\n<li>32</li>\n<li>33</li>\n<li>34</li>\n<li>35</li>\n<li>36</li>\n<li>37</li>\n<li>38</li>\n</ul>\n<h3><a name=\"t13\"></a><a name=\"t13\"></a><a id=\"_368\"></a>结果统计分析</h3>\n<div class=\"table-box\">\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>COST</th>\n<th>物理读次数</th>\n<th>逻辑读次数</th>\n<th>扫描行数</th>\n<th>返回行数</th>\n<th>执行时间</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>初始化插入100W</td>\n<td>10.499000</td>\n<td>7868409</td>\n<td>7855239</td>\n<td>22226</td>\n<td>11111</td>\n<td>30ms</td>\n</tr>\n<tr>\n<td>100W随机删除50W</td>\n<td>10.499000</td>\n<td>7868409</td>\n<td>7855239</td>\n<td>22226</td>\n<td>0</td>\n<td>50ms</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>这也说明对普通的大表，想要通过delete数据来对表进行瘦身是不现实的，所以在任何时候不要用delete去删除数据，应该使用优雅的标记删除。</p>\n<h2><a name=\"t14\"></a><a name=\"t14\"></a><a id=\"delete_377\"></a>delete优化建议</h2>\n<h3><a name=\"t15\"></a><a name=\"t15\"></a><a id=\"_379\"></a>控制业务账号权限</h3>\n<p>对于一个大的系统来说，需要根据业务特点去拆分子系统，每个子系统可以看做是一个service，例如美团APP，上面有很多服务，核心的服务有用户服务user-service，搜索服务search-service，商品product-service，位置服务location-service，价格服务price-service等。每个服务对应一个数据库，为该数据库创建单独账号，同时只授予DML权限且没有delete权限，同时禁止跨库访问。</p>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#创建用户数据库并授权\ncreate database mt_user charset utf8mb4;\ngrant USAGE, SELECT, INSERT, UPDATE ON mt_user.*  to 'w_user'@'%' identified by 't$W*g@gaHTGi123456';\nflush privileges;\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n</ul>\n<h3><a name=\"t16\"></a><a name=\"t16\"></a><a id=\"delete_390\"></a>delete改为标记删除</h3>\n<p>在MySQL数据库建模规范中有4个公共字段，基本上每个表必须有的，同时在create_time列要创建索引，有两方面的好处：</p>\n<ol>\n<li>一些查询业务场景都会有一个默认的时间段，比如7天或者一个月，都是通过create_time去过滤，走索引扫描更快。</li>\n<li>一些核心的业务表需要以T +1的方式抽取数据仓库中，比如每天晚上00:30抽取前一天的数据，都是通过create_time过滤的。</li>\n</ol>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">`id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键id',\n`is_deleted` tinyint(4) NOT NULL DEFAULT '0' COMMENT '是否逻辑删除：0：未删除，1：已删除',\n`create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n`update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间'\n\n#有了删除标记，业务接口的delete操作就可以转换为update\nupdate user set is_deleted = 1 where user_id = 1213;\n\n#查询的时候需要带上is_deleted过滤\nselect id, age ,phone from user where is_deleted = 0 and name like 'lyn12%';\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n</ul>\n<h2><a name=\"t17\"></a><a name=\"t17\"></a><a id=\"_410\"></a>数据归档方式</h2>\n<h3><a name=\"t18\"></a><a name=\"t18\"></a><a id=\"_412\"></a>通用数据归档方法</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#1. 创建归档表，一般在原表名后面添加_bak。\nCREATE TABLE `ota_order_bak` (\n  `id` bigint(11) NOT NULL AUTO_INCREMENT COMMENT '主键',\n  `order_id` varchar(255) DEFAULT NULL COMMENT '订单id',\n  `ota_id` varchar(255) DEFAULT NULL COMMENT 'ota',\n  `check_in_date` varchar(255) DEFAULT NULL COMMENT '入住日期',\n  `check_out_date` varchar(255) DEFAULT NULL COMMENT '离店日期',\n  `hotel_id` varchar(255) DEFAULT NULL COMMENT '酒店ID',\n  `guest_name` varchar(255) DEFAULT NULL COMMENT '顾客',\n  `purcharse_time` timestamp NULL DEFAULT NULL COMMENT '购买时间',\n  `create_time` datetime DEFAULT NULL,\n  `update_time` datetime DEFAULT NULL,\n  `create_user` varchar(255) DEFAULT NULL,\n  `update_user` varchar(255) DEFAULT NULL,\n  `status` int(4) DEFAULT '1' COMMENT '状态 ： 1 正常 ， 0 删除',\n  `hotel_name` varchar(255) DEFAULT NULL,\n  `price` decimal(10,0) DEFAULT NULL,\n  `remark` longtext,\n  PRIMARY KEY (`id`),\n  KEY `IDX_order_id` (`order_id`) USING BTREE,\n  KEY `hotel_name` (`hotel_name`) USING BTREE,\n  KEY `ota_id` (`ota_id`) USING BTREE,\n  KEY `IDX_purcharse_time` (`purcharse_time`) USING BTREE,\n  KEY `IDX_create_time` (`create_time`) USING BTREE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8\nPARTITION BY RANGE (to_days(create_time)) ( \nPARTITION p201808 VALUES LESS THAN (to_days('2018-09-01')), \nPARTITION p201809 VALUES LESS THAN (to_days('2018-10-01')), \nPARTITION p201810 VALUES LESS THAN (to_days('2018-11-01')), \nPARTITION p201811 VALUES LESS THAN (to_days('2018-12-01')), \nPARTITION p201812 VALUES LESS THAN (to_days('2019-01-01')), \nPARTITION p201901 VALUES LESS THAN (to_days('2019-02-01')), \nPARTITION p201902 VALUES LESS THAN (to_days('2019-03-01')), \nPARTITION p201903 VALUES LESS THAN (to_days('2019-04-01')), \nPARTITION p201904 VALUES LESS THAN (to_days('2019-05-01')), \nPARTITION p201905 VALUES LESS THAN (to_days('2019-06-01')), \nPARTITION p201906 VALUES LESS THAN (to_days('2019-07-01')), \nPARTITION p201907 VALUES LESS THAN (to_days('2019-08-01')), \nPARTITION p201908 VALUES LESS THAN (to_days('2019-09-01')), \nPARTITION p201909 VALUES LESS THAN (to_days('2019-10-01')), \nPARTITION p201910 VALUES LESS THAN (to_days('2019-11-01')), \nPARTITION p201911 VALUES LESS THAN (to_days('2019-12-01')), \nPARTITION p201912 VALUES LESS THAN (to_days('2020-01-01')));\n\n#2. 插入原表中无效的数据（需要跟开发同学确认数据保留范围）\ncreate table tbl_p201808 as select * from ota_order where create_time between '2018-08-01 00:00:00' and '2018-08-31 23:59:59';\n\n#3. 跟归档表分区做分区交换\nalter table ota_order_bak exchange partition p201808 with table tbl_p201808; \n\n#4. 删除原表中已经规范的数据\ndelete from ota_order where create_time between '2018-08-01 00:00:00' and '2018-08-31 23:59:59' limit 3000;\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n<li>31</li>\n<li>32</li>\n<li>33</li>\n<li>34</li>\n<li>35</li>\n<li>36</li>\n<li>37</li>\n<li>38</li>\n<li>39</li>\n<li>40</li>\n<li>41</li>\n<li>42</li>\n<li>43</li>\n<li>44</li>\n<li>45</li>\n<li>46</li>\n<li>47</li>\n<li>48</li>\n<li>49</li>\n<li>50</li>\n<li>51</li>\n<li>52</li>\n</ul>\n<h3><a name=\"t19\"></a><a name=\"t19\"></a><a id=\"_469\"></a>优化后的归档方式</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#1. 创建中间表\nCREATE TABLE `ota_order_2020` (........) ENGINE=InnoDB DEFAULT CHARSET=utf8\nPARTITION BY RANGE (to_days(create_time)) ( \nPARTITION p201808 VALUES LESS THAN (to_days('2018-09-01')), \nPARTITION p201809 VALUES LESS THAN (to_days('2018-10-01')), \nPARTITION p201810 VALUES LESS THAN (to_days('2018-11-01')), \nPARTITION p201811 VALUES LESS THAN (to_days('2018-12-01')), \nPARTITION p201812 VALUES LESS THAN (to_days('2019-01-01')), \nPARTITION p201901 VALUES LESS THAN (to_days('2019-02-01')), \nPARTITION p201902 VALUES LESS THAN (to_days('2019-03-01')), \nPARTITION p201903 VALUES LESS THAN (to_days('2019-04-01')), \nPARTITION p201904 VALUES LESS THAN (to_days('2019-05-01')), \nPARTITION p201905 VALUES LESS THAN (to_days('2019-06-01')), \nPARTITION p201906 VALUES LESS THAN (to_days('2019-07-01')), \nPARTITION p201907 VALUES LESS THAN (to_days('2019-08-01')), \nPARTITION p201908 VALUES LESS THAN (to_days('2019-09-01')), \nPARTITION p201909 VALUES LESS THAN (to_days('2019-10-01')), \nPARTITION p201910 VALUES LESS THAN (to_days('2019-11-01')), \nPARTITION p201911 VALUES LESS THAN (to_days('2019-12-01')), \nPARTITION p201912 VALUES LESS THAN (to_days('2020-01-01')));\n\n#2. 插入原表中有效的数据，如果数据量在100W左右可以在业务低峰期直接插入，如果比较大，建议采用dataX来做，可以控制频率和大小，之前我这边用Go封装了dataX可以实现自动生成json文件，自定义大小去执行。\ninsert into ota_order_2020 select * from ota_order where create_time between '2020-08-01 00:00:00' and '2020-08-31 23:59:59';\n\n#3. 表重命名\nalter table ota_order rename to ota_order_bak;  \nalter table ota_order_2020 rename to ota_order;\n#4. 插入差异数据\ninsert into ota_order select * from ota_order_bak a where not exists (select 1 from ota_order b where a.id = b.id);\n#5. ota_order_bak改造成分区表，如果表比较大不建议直接改造，可以先创建好分区表，通过dataX把导入进去即可。\n\n#6. 后续的归档方法\n#创建中间普遍表\ncreate table ota_order_mid like ota_order;\n#交换原表无效数据分区到普通表\nalter table ota_order exchange partition p201808 with table ota_order_mid; \n##交换普通表数据到归档表的相应分区\nalter table ota_order_bak exchange partition p201808 with table ota_order_mid; \n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n<li>31</li>\n<li>32</li>\n<li>33</li>\n<li>34</li>\n<li>35</li>\n<li>36</li>\n<li>37</li>\n<li>38</li>\n</ul>\n<p>这样原表和归档表都是按月的分区表，只需要创建一个中间普通表，在业务低峰期做两次分区交换，既可以删除无效数据，又能回收空，而且没有空间碎片，不会影响表上的索引及SQL的执行计划。</p>\n<h2><a name=\"t20\"></a><a name=\"t20\"></a><a id=\"_514\"></a>总结</h2>\n<p>通过从InnoDB存储空间分布，delete对性能的影响可以看到，delete物理删除既不能释放磁盘空间，而且会产生大量的碎片，导致索引频繁分裂，影响SQL执行计划的稳定性；</p>\n<p>同时在碎片回收时，会耗用大量的CPU，磁盘空间，影响表上正常的DML操作。</p>\n<p>在业务代码层面，应该做逻辑标记删除，避免物理删除；为了实现数据归档需求，可以用采用MySQL分区表特性来实现，都是DDL操作，没有碎片产生。</p>\n<p>另外一个比较好的方案采用Clickhouse，对有生命周期的数据表可以使用Clickhouse存储，利用其TTL特性实现无效数据自动清理。</p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1330877080455553024","blogRead":0,"blogRemark":"MySQL","blogTitle":"面试官不讲武德问我：为什么MySQL不建议使用delete删除数据？","blogType":1,"createdTime":1606111996000,"version":3},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:37:54.253 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:38:20.901 DEBUG [http-nio-8899-exec-8]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==>  Preparing: select blog_id, blog_title, blog_content, blog_goods, blog_image, blog_read, blog_collection, blog_type, blog_remark, blog_comment, blog_source, created_time, version from bl_blog where blog_id = ? and deleted = 0 
2020-12-24 23:38:20.902 DEBUG [http-nio-8899-exec-8]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==> Parameters: 1324038097171820544(String)
2020-12-24 23:38:20.938 DEBUG [http-nio-8899-exec-8]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -<==      Total: 1
2020-12-24 23:38:20.978 DEBUG [http-nio-8899-exec-8]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:38:20.980 DEBUG [http-nio-8899-exec-8]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/get/1324038097171820544(String), [1324038097171820544](String), 1(Integer), null, GET(String), 82(Long), {"code":20000,"data":{"blogCollection":0,"blogComment":0,"blogContent":"BeanUtils.copyProperties(a, b);b中的存在的属性，a中一定要有，但是a中可以有多余的属性；a中与b中相同的属性都会被替换，不管是否有值；a、 b中的属性要名字相同，才能被赋值，不然的话需要手动赋值；Spring的BeanUtils的CopyProperties方法需要对应的属性有getter和setter方法；如果存在属性完全相同的内部类，但是不是同一个内部类，即分别属于各自的内部类，则spring会认为属性不同，不会copy；spring和apache的copy属性的方法源和目的参数的位置正好相反，所以导包和调用的时候都要注意一下。","blogGoods":0,"blogId":"1324038097171820544","blogImage":"Java","blogRead":0,"blogRemark":"BeanUtils它提供了对java反射和自省API的包装。它里面还有很多工具类，这里我们介绍一下copyProperties。","blogSource":"百度","blogTitle":"BeanUtils.copyProperties的用法","blogType":1,"createdTime":1604481453000,"version":2},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:38:21.062 DEBUG [http-nio-8899-exec-8]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:39:50.800 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:39:50.801 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /BlAdmin/info(String), [](String), 1(Integer), null, GET(String), 3(Long), {"code":20000,"data":{"name":"田起凯","password":"","signature":"hold on","username":"admin"},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:39:50.890 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:39:51.163 DEBUG [http-nio-8899-exec-10]com.tqk.blog.mapper.BlTypeMapper.selectByExample.debug:159 -==>  Preparing: SELECT type_id,type_name,type_blog_count,enable,deleted FROM bl_type WHERE ( enable = ? and deleted = ? ) 
2020-12-24 23:39:51.164 DEBUG [http-nio-8899-exec-10]com.tqk.blog.mapper.BlTypeMapper.selectByExample.debug:159 -==> Parameters: 1(Integer), 0(Integer)
2020-12-24 23:39:51.199 DEBUG [http-nio-8899-exec-10]com.tqk.blog.mapper.BlTypeMapper.selectByExample.debug:159 -<==      Total: 7
2020-12-24 23:39:51.199 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -==>  Preparing: select blog_id, blog_title, blog_image, blog_goods, blog_read, blog_collection, blog_remark, blog_comment, blog_source, created_time, update_time,type_name from bl_blog as b inner join bl_type as t on type_id = blog_type where t.deleted = 0 and b.deleted = 0 limit ?, ? 
2020-12-24 23:39:51.200 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -==> Parameters: 0(Integer), 10(Integer)
2020-12-24 23:39:51.236 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -<==      Total: 3
2020-12-24 23:39:51.237 DEBUG [http-nio-8899-exec-10]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:39:51.237 DEBUG [http-nio-8899-exec-10]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /type/getList(String), [](String), 1(Integer), null, GET(String), 79(Long), {"code":20000,"data":[{"deleted":0,"enable":1,"typeBlogCount":105,"typeId":1,"typeName":"Java"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"Python"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":6,"typeName":"going"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":7,"typeName":"Spring"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"nginx"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Redis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":10,"typeName":"Docker"}],"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:39:51.238 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -==>  Preparing: select count(*) from bl_blog as b inner join bl_type as t on type_id = blog_type where t.deleted = 0 and b.deleted = 0 
2020-12-24 23:39:51.238 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -==> Parameters: 
2020-12-24 23:39:51.281 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -<==      Total: 1
2020-12-24 23:39:51.326 DEBUG [http-nio-8899-exec-10]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:39:51.392 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:39:51.393 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/getByPage(String), [Page(currentPage=1, pageSize=10, totalPage=0, totalCount=0, list=[], params={}, sortColumn=null, sortMethod=asc)](String), 1(Integer), null, POST(String), 230(Long), {"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1324038097171820544","blogImage":"Java","blogRead":0,"blogRemark":"BeanUtils它提供了对java反射和自省API的包装。它里面还有很多工具类，这里我们介绍一下copyProperties。","blogSource":"百度","blogTitle":"BeanUtils.copyProperties的用法","createdTime":"2020-11-04 17:17:33","typeName":"Java","updateTime":"2020-11-22 13:04:15"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1330877080455553024","blogRead":0,"blogRemark":"MySQL","blogTitle":"面试官不讲武德问我：为什么MySQL不建议使用delete删除数据？","createdTime":"2020-11-23 14:13:16","typeName":"Java","updateTime":"2020-11-23 14:23:06"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1330879440221315072","blogRead":0,"blogRemark":"面试必备","blogTitle":"Java岗四面字节跳动成功之前，我都刷了那些面试题以及做了那些准备！","createdTime":"2020-11-23 14:22:39","typeName":"Java","updateTime":"2020-11-23 14:22:39"}],"pageSize":10,"params":{},"sortMethod":"asc","totalCount":3,"totalPage":1},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:39:51.470 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:39:57.556 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==>  Preparing: select blog_id, blog_title, blog_content, blog_goods, blog_image, blog_read, blog_collection, blog_type, blog_remark, blog_comment, blog_source, created_time, version from bl_blog where blog_id = ? and deleted = 0 
2020-12-24 23:39:57.557 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==> Parameters: 1324038097171820544(String)
2020-12-24 23:39:57.601 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -<==      Total: 1
2020-12-24 23:39:57.638 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:39:57.639 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/get/1324038097171820544(String), [1324038097171820544](String), 1(Integer), null, GET(String), 88(Long), {"code":20000,"data":{"blogCollection":0,"blogComment":0,"blogContent":"BeanUtils.copyProperties(a, b);b中的存在的属性，a中一定要有，但是a中可以有多余的属性；a中与b中相同的属性都会被替换，不管是否有值；a、 b中的属性要名字相同，才能被赋值，不然的话需要手动赋值；Spring的BeanUtils的CopyProperties方法需要对应的属性有getter和setter方法；如果存在属性完全相同的内部类，但是不是同一个内部类，即分别属于各自的内部类，则spring会认为属性不同，不会copy；spring和apache的copy属性的方法源和目的参数的位置正好相反，所以导包和调用的时候都要注意一下。","blogGoods":0,"blogId":"1324038097171820544","blogImage":"Java","blogRead":0,"blogRemark":"BeanUtils它提供了对java反射和自省API的包装。它里面还有很多工具类，这里我们介绍一下copyProperties。","blogSource":"百度","blogTitle":"BeanUtils.copyProperties的用法","blogType":1,"createdTime":1604481453000,"version":2},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:39:57.730 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:40:02.037 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==>  Preparing: select blog_id, blog_title, blog_content, blog_goods, blog_image, blog_read, blog_collection, blog_type, blog_remark, blog_comment, blog_source, created_time, version from bl_blog where blog_id = ? and deleted = 0 
2020-12-24 23:40:02.037 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==> Parameters: 1324038097171820544(String)
2020-12-24 23:40:02.073 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -<==      Total: 1
2020-12-24 23:40:02.110 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:40:02.110 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/get/1324038097171820544(String), [1324038097171820544](String), 1(Integer), null, GET(String), 74(Long), {"code":20000,"data":{"blogCollection":0,"blogComment":0,"blogContent":"BeanUtils.copyProperties(a, b);b中的存在的属性，a中一定要有，但是a中可以有多余的属性；a中与b中相同的属性都会被替换，不管是否有值；a、 b中的属性要名字相同，才能被赋值，不然的话需要手动赋值；Spring的BeanUtils的CopyProperties方法需要对应的属性有getter和setter方法；如果存在属性完全相同的内部类，但是不是同一个内部类，即分别属于各自的内部类，则spring会认为属性不同，不会copy；spring和apache的copy属性的方法源和目的参数的位置正好相反，所以导包和调用的时候都要注意一下。","blogGoods":0,"blogId":"1324038097171820544","blogImage":"Java","blogRead":0,"blogRemark":"BeanUtils它提供了对java反射和自省API的包装。它里面还有很多工具类，这里我们介绍一下copyProperties。","blogSource":"百度","blogTitle":"BeanUtils.copyProperties的用法","blogType":1,"createdTime":1604481453000,"version":2},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:40:02.201 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:43:59.669 DEBUG [http-nio-8899-exec-4]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==>  Preparing: select blog_id, blog_title, blog_content, blog_goods, blog_image, blog_read, blog_collection, blog_type, blog_remark, blog_comment, blog_source, created_time, version from bl_blog where blog_id = ? and deleted = 0 
2020-12-24 23:43:59.670 DEBUG [http-nio-8899-exec-4]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==> Parameters: 1324038097171820544(String)
2020-12-24 23:43:59.731 DEBUG [http-nio-8899-exec-4]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -<==      Total: 1
2020-12-24 23:43:59.772 DEBUG [http-nio-8899-exec-4]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:43:59.774 DEBUG [http-nio-8899-exec-4]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/get/1324038097171820544(String), [1324038097171820544](String), 1(Integer), null, GET(String), 106(Long), {"code":20000,"data":{"blogCollection":0,"blogComment":0,"blogContent":"BeanUtils.copyProperties(a, b);b中的存在的属性，a中一定要有，但是a中可以有多余的属性；a中与b中相同的属性都会被替换，不管是否有值；a、 b中的属性要名字相同，才能被赋值，不然的话需要手动赋值；Spring的BeanUtils的CopyProperties方法需要对应的属性有getter和setter方法；如果存在属性完全相同的内部类，但是不是同一个内部类，即分别属于各自的内部类，则spring会认为属性不同，不会copy；spring和apache的copy属性的方法源和目的参数的位置正好相反，所以导包和调用的时候都要注意一下。","blogGoods":0,"blogId":"1324038097171820544","blogImage":"Java","blogRead":0,"blogRemark":"BeanUtils它提供了对java反射和自省API的包装。它里面还有很多工具类，这里我们介绍一下copyProperties。","blogSource":"百度","blogTitle":"BeanUtils.copyProperties的用法","blogType":1,"createdTime":1604481453000,"version":2},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:43:59.862 DEBUG [http-nio-8899-exec-4]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:44:01.855 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==>  Preparing: select blog_id, blog_title, blog_content, blog_goods, blog_image, blog_read, blog_collection, blog_type, blog_remark, blog_comment, blog_source, created_time, version from bl_blog where blog_id = ? and deleted = 0 
2020-12-24 23:44:01.856 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==> Parameters: 1330877080455553024(String)
2020-12-24 23:44:01.946 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -<==      Total: 1
2020-12-24 23:44:01.994 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:44:01.997 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/get/1330877080455553024(String), [1330877080455553024](String), 1(Integer), null, GET(String), 129(Long), {"code":20000,"data":{"blogCollection":0,"blogComment":0,"blogContent":"<h2>前言</h2>\n<p>我负责的有几个系统随着业务量的增长，存储在MySQL中的数据日益剧增，我当时就想现在的业务方不讲武德，搞偷袭，趁我没反应过来把很多表，很快，很快啊都打到了亿级别，我大意了，没有闪，这就导致跟其Join的表的SQL变得很慢，对的应用接口的response time也变长了，影响了用户体验。</p>\n<p>事后我找到业务方，我批评了他们跟他们说要讲武德，连忙跟我道歉，这个事情才就此作罢，走的时候我对他们说下次不要这样了，耗子尾汁，好好反思。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/3c93aececcb9e763f5476362c4e88710.png\" alt=\"\" /></p>\n<p>骂归骂，事情还是得解决，时候我分析原因发现，发现有些表的数据量增长很快，对应SQL扫描了很多无效数据，导致SQL慢了下来，通过确认之后，这些大表都是一些流水、记录、日志类型数据，只需要保留1到3个月，此时需要对表做数据清理实现瘦身，一般都会想到用insert + delete的方式去清理。</p>\n<p>这篇文章我会从InnoDB存储空间分布，delete对性能的影响，以及优化建议方面解释为什么不建议delete删除数据。</p>\n<h2><a name=\"t1\"></a><a name=\"t1\"></a><a id=\"InnoDB_16\"></a>InnoDB存储架构</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/5c66ffe9749c58e1613d2519f7ea7211.png\" alt=\"\" /></p>\n<p>从这张图可以看到，InnoDB存储结构主要包括两部分：逻辑存储结构和物理存储结构。</p>\n<p>逻辑上是由表空间tablespace &mdash;&gt; 段segment或者inode &mdash;&gt; 区Extent &mdash;&mdash;&gt;数据页Page构成，Innodb逻辑管理单位是segment，空间分配的最小单位是extent，每个segment都会从表空间FREE_PAGE中分配32个page，当这32个page不够用时，会按照以下原则进行扩展：如果当前小于1个extent，则扩展到1个extent；当表空间小于32MB时，每次扩展一个extent；表空间大于32MB，每次扩展4个extent。</p>\n<p>物理上主要由系统用户数据文件，日志文件组成，数据文件主要存储MySQL字典数据和用户数据，日志文件记录的是data page的变更记录，用于MySQL Crash时的恢复。</p>\n<h2><a name=\"t2\"></a><a name=\"t2\"></a><a id=\"Innodb_26\"></a>Innodb表空间</h2>\n<p>InnoDB存储包括三类表空间：系统表空间，用户表空间，Undo表空间。</p>\n<p><strong>系统表空间：</strong>&nbsp;主要存储MySQL内部的数据字典数据，如information_schema下的数据。</p>\n<p><strong>用户表空间：</strong>&nbsp;当开启innodb_file_per_table=1时，数据表从系统表空间独立出来存储在以table_name.ibd命令的数据文件中，结构信息存储在table_name.frm文件中。</p>\n<p><strong>Undo表空间：</strong>&nbsp;存储Undo信息，如快照一致读和flashback都是利用undo信息。</p>\n<p>从MySQL 8.0开始允许用户自定义表空间，具体语法如下：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">CREATE TABLESPACE tablespace_name\n    ADD DATAFILE 'file_name'               #数据文件名\n    USE LOGFILE GROUP logfile_group        #自定义日志文件组，一般每组2个logfile。\n    [EXTENT_SIZE [=] extent_size]          #区大小\n    [INITIAL_SIZE [=] initial_size]        #初始化大小 \n    [AUTOEXTEND_SIZE [=] autoextend_size]  #自动扩宽尺寸\n    [MAX_SIZE [=] max_size]                #单个文件最大size，最大是32G。\n    [NODEGROUP [=] nodegroup_id]           #节点组\n    [WAIT]\n    [COMMENT [=] comment_text]\n    ENGINE [=] engine_name\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n</ul>\n<p>这样的好处是可以做到数据的冷热分离，分别用HDD和SSD来存储，既能实现数据的高效访问，又能节约成本，比如可以添加两块500G硬盘，经过创建卷组vg，划分逻辑卷lv，创建数据目录并mount相应的lv，假设划分的两个目录分别是/hot_data 和 /cold_data。</p>\n<p>这样就可以将核心的业务表如用户表，订单表存储在高性能SSD盘上，一些日志，流水表存储在普通的HDD上，主要的操作步骤如下：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#创建热数据表空间\ncreate tablespace tbs_data_hot add datafile '/hot_data/tbs_data_hot01.dbf' max_size 20G;\n#创建核心业务表存储在热数据表空间\ncreate table booking(id bigint not null primary key auto_increment, &hellip;&hellip; ) tablespace tbs_data_hot;\n#创建冷数据表空间\ncreate tablespace tbs_data_cold add datafile '/hot_data/tbs_data_cold01.dbf' max_size 20G;\n#创建日志，流水，备份类的表存储在冷数据表空间\ncreate table payment_log(id bigint not null primary key auto_increment, &hellip;&hellip; ) tablespace tbs_data_cold;\n#可以移动表到另一个表空间\nalter table payment_log tablespace tbs_data_hot;\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n</ul>\n<h2><a name=\"t3\"></a><a name=\"t3\"></a><a id=\"Inndob_69\"></a>Inndob存储分布</h2>\n<h3><a name=\"t4\"></a><a name=\"t4\"></a><a id=\"_71\"></a>创建空表查看空间变化</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; create table user(id bigint not null primary key auto_increment, \n    -&gt; name varchar(20) not null default '' comment '姓名', \n    -&gt; age tinyint not null default 0 comment 'age', \n    -&gt; gender char(1) not null default 'M'  comment '性别',\n    -&gt; phone varchar(16) not null default '' comment '手机号',\n    -&gt; create_time datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n    -&gt; update_time datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间'\n    -&gt; ) engine = InnoDB DEFAULT CHARSET=utf8mb4 COMMENT '用户信息表';\nQuery OK, 0 rows affected (0.26 sec)\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n</ul>\n<pre class=\"prettyprint\"><code class=\"prism language-bash has-numbering\"><span class=\"token comment\"># ls -lh user1.ibd </span>\n-rw-r----- 1 mysql mysql 96K Nov  6 12:48 user.ibd\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n</ul>\n<p>设置参数innodb_file_per_table=1时，创建表时会自动创建一个segment，同时分配一个extent，包含32个data page的来存储数据，这样创建的空表默认大小就是96KB，extent使用完之后会申请64个连接页，这样对于一些小表，或者undo segment，可以在开始时申请较少的空间，节省磁盘容量的开销。</p>\n<pre class=\"prettyprint\"><code class=\"prism language-shell has-numbering\"><span class=\"token comment\"># python2 py_innodb_page_info.py -v /data2/mysql/test/user.ibd</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>File Space Header<span class=\"token operator\">&gt;</span>\npage offset 00000001, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Insert Buffer Bitmap<span class=\"token operator\">&gt;</span>\npage offset 00000002, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>File Segment inode<span class=\"token operator\">&gt;</span>\npage offset 00000003, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>B-tree Node<span class=\"token operator\">&gt;</span>, page level <span class=\"token operator\">&lt;</span>0000<span class=\"token operator\">&gt;</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Freshly Allocated Page<span class=\"token operator\">&gt;</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Freshly Allocated Page<span class=\"token operator\">&gt;</span>\nTotal number of page: 6:      <span class=\"token comment\">#总共分配的页数</span>\nFreshly Allocated Page: 2     <span class=\"token comment\">#可用的数据页</span>\nInsert Buffer Bitmap: 1       <span class=\"token comment\">#插入缓冲页</span>\nFile Space Header: 1          <span class=\"token comment\">#文件空间头</span>\nB-tree Node: 1                <span class=\"token comment\">#数据页</span>\nFile Segment inode: 1         <span class=\"token comment\">#文件端inonde，如果是在ibdata1.ibd上会有多个inode。</span>\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n</ul>\n<h3><a name=\"t5\"></a><a name=\"t5\"></a><a id=\"_108\"></a>插入数据后的空间变化</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; DELIMITER $$\nmysql&gt; CREATE PROCEDURE insert_user_data(num INTEGER) \n    -&gt; BEGIN\n    -&gt;     DECLARE v_i int unsigned DEFAULT 0;\n    -&gt; set autocommit= 0;\n    -&gt; WHILE v_i &lt; num DO\n    -&gt;    insert into user(`name`, age, gender, phone) values (CONCAT('lyn',v_i), mod(v_i,120), 'M', CONCAT('152',ROUND(RAND(1)*100000000)));\n    -&gt;  SET v_i = v_i+1;\n    -&gt; END WHILE;\n    -&gt; commit;\n    -&gt; END $$\nQuery OK, 0 rows affected (0.01 sec)\nmysql&gt; DELIMITER ;\n\n#插入10w数据\nmysql&gt; call insert_user_data(100000);\nQuery OK, 0 rows affected (6.69 sec)\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n</ul>\n<pre class=\"prettyprint\"><code class=\"prism language-shell has-numbering\"><span class=\"token comment\"># ls -lh user.ibd</span>\n-rw-r----- 1 mysql mysql 14M Nov 6 10:58 /data2/mysql/test/user.ibd\n\n<span class=\"token comment\"># python2 py_innodb_page_info.py -v /data2/mysql/test/user.ibd</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>File Space Header<span class=\"token operator\">&gt;</span>\npage offset 00000001, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Insert Buffer Bitmap<span class=\"token operator\">&gt;</span>\npage offset 00000002, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>File Segment inode<span class=\"token operator\">&gt;</span>\npage offset 00000003, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>B-tree Node<span class=\"token operator\">&gt;</span>, page level <span class=\"token operator\">&lt;</span>0001<span class=\"token operator\">&gt;</span>   <span class=\"token comment\">#增加了一个非叶子节点，树的高度从1变为2.</span>\n<span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Freshly Allocated Page<span class=\"token operator\">&gt;</span>\nTotal number of page: 896:\nFreshly Allocated Page: 493\nInsert Buffer Bitmap: 1\nFile Space Header: 1\nB-tree Node: 400\nFile Segment inode: 1\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n</ul>\n<h3><a name=\"t6\"></a><a name=\"t6\"></a><a id=\"delete_149\"></a>delete数据后的空间变化</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; select min(id),max(id),count(*) from user;\n+---------+---------+----------+\n| min(id) | max(id) | count(*) |\n+---------+---------+----------+\n|       1 |  100000 |   100000 |\n+---------+---------+----------+\n1 row in set (0.05 sec)\n#删除50000条数据，理论上空间应该从14MB变长7MB左右。\nmysql&gt; delete from user limit 50000;\nQuery OK, 50000 rows affected (0.25 sec)\n\n#数据文件大小依然是14MB，没有缩小。\n# ls -lh /data2/mysql/test/user1.ibd \n-rw-r----- 1 mysql mysql 14M Nov  6 13:22 /data2/mysql/test/user.ibd\n\n#数据页没有被回收。\n# python2 py_innodb_page_info.py -v /data2/mysql/test/user.ibd\npage offset 00000000, page type &lt;File Space Header&gt;\npage offset 00000001, page type &lt;Insert Buffer Bitmap&gt;\npage offset 00000002, page type &lt;File Segment inode&gt;\npage offset 00000003, page type &lt;B-tree Node&gt;, page level &lt;0001&gt;\n........................................................\npage offset 00000000, page type &lt;Freshly Allocated Page&gt;\nTotal number of page: 896:\nFreshly Allocated Page: 493\nInsert Buffer Bitmap: 1\nFile Space Header: 1\nB-tree Node: 400\nFile Segment inode: 1\n#在MySQL内部是标记删除，\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n</ul>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; use information_schema;\n\nDatabase changed\nmysql&gt; SELECT A.SPACE AS TBL_SPACEID, A.TABLE_ID, A.NAME AS TABLE_NAME, FILE_FORMAT, ROW_FORMAT, SPACE_TYPE,  B.INDEX_ID , B.NAME AS INDEX_NAME, PAGE_NO, B.TYPE AS INDEX_TYPE FROM INNODB_SYS_TABLES A LEFT JOIN INNODB_SYS_INDEXES B ON A.TABLE_ID =B.TABLE_ID WHERE A.NAME = 'test/user1';\n+-------------+----------+------------+-------------+------------+------------+----------+------------+---------+------------+\n| TBL_SPACEID | TABLE_ID | TABLE_NAME | FILE_FORMAT | ROW_FORMAT | SPACE_TYPE | INDEX_ID | INDEX_NAME | PAGE_NO | INDEX_TYPE |\n+-------------+----------+------------+-------------+------------+------------+----------+------------+---------+------------+\n|        1283 |     1207 | test/user | Barracuda   | Dynamic    | Single     |     2236 | PRIMARY    |       3 |          3 |\n+-------------+----------+------------+-------------+------------+------------+----------+------------+---------+------------+\n1 row in set (0.01 sec)\n\nPAGE_NO = 3 标识B-tree的root page是3号页，INDEX_TYPE = 3是聚集索引。 INDEX_TYPE取值如下：\n0 = nonunique secondary index; \n1 = automatically generated clustered index (GEN_CLUST_INDEX); \n2 = unique nonclustered index; \n3 = clustered index; \n32 = full-text index;\n#收缩空间再后进行观察\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n</ul>\n<p>MySQL内部不会真正删除空间，而且做标记删除，即将delflag:N修改为delflag:Y，commit之后会会被purge进入删除链表，如果下一次insert更大的记录，delete之后的空间不会被重用，如果插入的记录小于等于delete的记录空会被重用，这块内容可以通过知数堂的innblock工具进行分析。</p>\n<h2><a name=\"t7\"></a><a name=\"t7\"></a><a id=\"Innodb_207\"></a>Innodb中的碎片</h2>\n<h3><a name=\"t8\"></a><a name=\"t8\"></a><a id=\"_209\"></a>碎片的产生</h3>\n<p>我们知道数据存储在文件系统上的，总是不能100%利用分配给它的物理空间，删除数据会在页面上留下一些&rdquo;空洞&rdquo;，或者随机写入（聚集索引非线性增加）会导致页分裂，页分裂导致页面的利用空间少于50%，另外对表进行增删改会引起对应的二级索引值的随机的增删改，也会导致索引结构中的数据页面上留下一些\"空洞\"，虽然这些空洞有可能会被重复利用，但终究会导致部分物理空间未被使用，也就是碎片。</p>\n<p>同时，即便是设置了填充因子为100%，Innodb也会主动留下page页面1/16的空间作为预留使用（An innodb_fill_factor setting of 100 leaves 1/16 of the space in clustered index pages free for future index growth）防止update带来的行溢出。</p>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; select table_schema,\n    -&gt;        table_name,ENGINE,\n    -&gt;        round(DATA_LENGTH/1024/1024+ INDEX_LENGTH/1024/1024) total_mb,TABLE_ROWS,\n    -&gt;        round(DATA_LENGTH/1024/1024) data_mb, round(INDEX_LENGTH/1024/1024) index_mb, round(DATA_FREE/1024/1024) free_mb, round(DATA_FREE/DATA_LENGTH*100,2) free_ratio\n    -&gt; from information_schema.TABLES where  TABLE_SCHEMA= 'test'\n    -&gt; and TABLE_NAME= 'user';\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n| table_schema | table_name | ENGINE | total_mb | TABLE_ROWS | data_mb | index_mb | free_mb | free_ratio |\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n| test         | user      | InnoDB |        4 |      50000 |       4 |        0 |       6 |     149.42 |\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n1 row in set (0.00 sec)\n\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n</ul>\n<p>其中data_free是分配了未使用的字节数，并不能说明完全是碎片空间。</p>\n<h3><a name=\"t9\"></a><a name=\"t9\"></a><a id=\"_233\"></a>碎片的回收</h3>\n<p>对于InnoDB的表，可以通过以下命令来回收碎片，释放空间，这个是随机读IO操作，会比较耗时，也会阻塞表上正常的DML运行，同时需要占用额外更多的磁盘空间，对于RDS来说，可能会导致磁盘空间瞬间爆满，实例瞬间被锁定，应用无法做DML操作，所以禁止在线上环境去执行。</p>\n<pre class=\"prettyprint\"><code class=\"prism language-shell has-numbering\"><span class=\"token comment\">#执行InnoDB的碎片回收</span>\nmysql<span class=\"token operator\">&gt;</span> alter table user engine<span class=\"token operator\">=</span>InnoDB<span class=\"token punctuation\">;</span>\nQuery OK, 0 rows affected <span class=\"token punctuation\">(</span>9.00 sec<span class=\"token punctuation\">)</span>\nRecords: 0  Duplicates: 0  Warnings: 0\n\n<span class=\"token comment\">##执行完之后，数据文件大小从14MB降低到10M。</span>\n<span class=\"token comment\"># ls -lh /data2/mysql/test/user1.ibd </span>\n-rw-r----- 1 mysql mysql 10M Nov 6 16:18 /data2/mysql/test/user.ibd\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n</ul>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; select table_schema,        table_name,ENGINE,        round(DATA_LENGTH/1024/1024+ INDEX_LENGTH/1024/1024) total_mb,TABLE_ROWS,        round(DATA_LENGTH/1024/1024) data_mb, round(INDEX_LENGTH/1024/1024) index_mb, round(DATA_FREE/1024/1024) free_mb, round(DATA_FREE/DATA_LENGTH*100,2) free_ratio from information_schema.TABLES where  TABLE_SCHEMA= 'test' and TABLE_NAME= 'user';\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n| table_schema | table_name | ENGINE | total_mb | TABLE_ROWS | data_mb | index_mb | free_mb | free_ratio |\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n| test         | user      | InnoDB |        5 |      50000 |       5 |        0 |       2 |      44.29 |\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n1 row in set (0.00 sec)\n\n\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n</ul>\n<h2><a name=\"t10\"></a><a name=\"t10\"></a><a id=\"deleteSQL_260\"></a>delete对SQL的影响</h2>\n<h3><a name=\"t11\"></a><a name=\"t11\"></a><a id=\"SQL_262\"></a>未删除前的SQL执行情况</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#插入100W数据\nmysql&gt; call insert_user_data(1000000);\nQuery OK, 0 rows affected (35.99 sec)\n\n#添加相关索引\nmysql&gt; alter table user add index idx_name(name), add index idx_phone(phone);\nQuery OK, 0 rows affected (6.00 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\n#表上索引统计信息\nmysql&gt; show index from user;\n+-------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+\n| Table | Non_unique | Key_name  | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |\n+-------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+\n| user  |          0 | PRIMARY   |            1 | id          | A         |      996757 |     NULL | NULL   |      | BTREE      |         |               |\n| user  |          1 | idx_name  |            1 | name        | A         |      996757 |     NULL | NULL   |      | BTREE      |         |               |\n| user  |          1 | idx_phone |            1 | phone       | A         |           2 |     NULL | NULL   |      | BTREE      |         |               |\n+-------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+\n3 rows in set (0.00 sec)\n\n#重置状态变量计数\nmysql&gt; flush status;\nQuery OK, 0 rows affected (0.00 sec)\n\n#执行SQL语句\nmysql&gt; select id, age ,phone from user where name like 'lyn12%';\n+--------+-----+-------------+\n| id     | age | phone       |\n+--------+-----+-------------+\n|    124 |   3 | 15240540354 |\n|   1231 |  30 | 15240540354 |\n|  12301 |  60 | 15240540354 |\n.............................\n| 129998 |  37 | 15240540354 |\n| 129999 |  38 | 15240540354 |\n| 130000 |  39 | 15240540354 |\n+--------+-----+-------------+\n11111 rows in set (0.03 sec)\n\nmysql&gt; explain select id, age ,phone from user where name like 'lyn12%';\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n| id | select_type | table | type  | possible_keys | key      | key_len | ref  | rows  | Extra                 |\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n|  1 | SIMPLE      | user  | range | idx_name      | idx_name | 82      | NULL | 22226 | Using index condition |\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n1 row in set (0.00 sec)\n\n#查看相关状态呢变量\nmysql&gt; select * from information_schema.session_status where variable_name in('Last_query_cost','Handler_read_next','Innodb_pages_read','Innodb_data_reads','Innodb_pages_read');\n+-------------------+----------------+\n| VARIABLE_NAME     | VARIABLE_VALUE |\n+-------------------+----------------+\n| HANDLER_READ_NEXT | 11111          |    #请求读的行数\n| INNODB_DATA_READS | 7868409        |    #数据物理读的总数\n| INNODB_PAGES_READ | 7855239        |    #逻辑读的总数\n| LAST_QUERY_COST   | 10.499000      |    #SQL语句的成本COST，主要包括IO_COST和CPU_COST。\n+-------------------+----------------+\n4 rows in set (0.00 sec)\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n<li>31</li>\n<li>32</li>\n<li>33</li>\n<li>34</li>\n<li>35</li>\n<li>36</li>\n<li>37</li>\n<li>38</li>\n<li>39</li>\n<li>40</li>\n<li>41</li>\n<li>42</li>\n<li>43</li>\n<li>44</li>\n<li>45</li>\n<li>46</li>\n<li>47</li>\n<li>48</li>\n<li>49</li>\n<li>50</li>\n<li>51</li>\n<li>52</li>\n<li>53</li>\n<li>54</li>\n<li>55</li>\n<li>56</li>\n<li>57</li>\n<li>58</li>\n</ul>\n<h3><a name=\"t12\"></a><a name=\"t12\"></a><a id=\"SQL_325\"></a>删除后的SQL执行情况</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#删除50w数据\nmysql&gt; delete from user limit 500000;\nQuery OK, 500000 rows affected (3.70 sec)\n\n#分析表统计信息\nmysql&gt; analyze table user;\n+-----------+---------+----------+----------+\n| Table     | Op      | Msg_type | Msg_text |\n+-----------+---------+----------+----------+\n| test.user | analyze | status   | OK       |\n+-----------+---------+----------+----------+\n1 row in set (0.01 sec)\n\n#重置状态变量计数\nmysql&gt; flush status;\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql&gt; select id, age ,phone from user where name like 'lyn12%';\nEmpty set (0.05 sec)\n\nmysql&gt; explain select id, age ,phone from user where name like 'lyn12%';\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n| id | select_type | table | type  | possible_keys | key      | key_len | ref  | rows  | Extra                 |\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n|  1 | SIMPLE      | user  | range | idx_name      | idx_name | 82      | NULL | 22226 | Using index condition |\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n1 row in set (0.00 sec)\n\nmysql&gt; select * from information_schema.session_status where variable_name in('Last_query_cost','Handler_read_next','Innodb_pages_read','Innodb_data_reads','Innodb_pages_read');\n+-------------------+----------------+\n| VARIABLE_NAME     | VARIABLE_VALUE |\n+-------------------+----------------+\n| HANDLER_READ_NEXT | 0              |\n| INNODB_DATA_READS | 7868409        |\n| INNODB_PAGES_READ | 7855239        |\n| LAST_QUERY_COST   | 10.499000      |\n+-------------------+----------------+\n4 rows in set (0.00 sec)\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n<li>31</li>\n<li>32</li>\n<li>33</li>\n<li>34</li>\n<li>35</li>\n<li>36</li>\n<li>37</li>\n<li>38</li>\n</ul>\n<h3><a name=\"t13\"></a><a name=\"t13\"></a><a id=\"_368\"></a>结果统计分析</h3>\n<div class=\"table-box\">\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>COST</th>\n<th>物理读次数</th>\n<th>逻辑读次数</th>\n<th>扫描行数</th>\n<th>返回行数</th>\n<th>执行时间</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>初始化插入100W</td>\n<td>10.499000</td>\n<td>7868409</td>\n<td>7855239</td>\n<td>22226</td>\n<td>11111</td>\n<td>30ms</td>\n</tr>\n<tr>\n<td>100W随机删除50W</td>\n<td>10.499000</td>\n<td>7868409</td>\n<td>7855239</td>\n<td>22226</td>\n<td>0</td>\n<td>50ms</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>这也说明对普通的大表，想要通过delete数据来对表进行瘦身是不现实的，所以在任何时候不要用delete去删除数据，应该使用优雅的标记删除。</p>\n<h2><a name=\"t14\"></a><a name=\"t14\"></a><a id=\"delete_377\"></a>delete优化建议</h2>\n<h3><a name=\"t15\"></a><a name=\"t15\"></a><a id=\"_379\"></a>控制业务账号权限</h3>\n<p>对于一个大的系统来说，需要根据业务特点去拆分子系统，每个子系统可以看做是一个service，例如美团APP，上面有很多服务，核心的服务有用户服务user-service，搜索服务search-service，商品product-service，位置服务location-service，价格服务price-service等。每个服务对应一个数据库，为该数据库创建单独账号，同时只授予DML权限且没有delete权限，同时禁止跨库访问。</p>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#创建用户数据库并授权\ncreate database mt_user charset utf8mb4;\ngrant USAGE, SELECT, INSERT, UPDATE ON mt_user.*  to 'w_user'@'%' identified by 't$W*g@gaHTGi123456';\nflush privileges;\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n</ul>\n<h3><a name=\"t16\"></a><a name=\"t16\"></a><a id=\"delete_390\"></a>delete改为标记删除</h3>\n<p>在MySQL数据库建模规范中有4个公共字段，基本上每个表必须有的，同时在create_time列要创建索引，有两方面的好处：</p>\n<ol>\n<li>一些查询业务场景都会有一个默认的时间段，比如7天或者一个月，都是通过create_time去过滤，走索引扫描更快。</li>\n<li>一些核心的业务表需要以T +1的方式抽取数据仓库中，比如每天晚上00:30抽取前一天的数据，都是通过create_time过滤的。</li>\n</ol>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">`id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键id',\n`is_deleted` tinyint(4) NOT NULL DEFAULT '0' COMMENT '是否逻辑删除：0：未删除，1：已删除',\n`create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n`update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间'\n\n#有了删除标记，业务接口的delete操作就可以转换为update\nupdate user set is_deleted = 1 where user_id = 1213;\n\n#查询的时候需要带上is_deleted过滤\nselect id, age ,phone from user where is_deleted = 0 and name like 'lyn12%';\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n</ul>\n<h2><a name=\"t17\"></a><a name=\"t17\"></a><a id=\"_410\"></a>数据归档方式</h2>\n<h3><a name=\"t18\"></a><a name=\"t18\"></a><a id=\"_412\"></a>通用数据归档方法</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#1. 创建归档表，一般在原表名后面添加_bak。\nCREATE TABLE `ota_order_bak` (\n  `id` bigint(11) NOT NULL AUTO_INCREMENT COMMENT '主键',\n  `order_id` varchar(255) DEFAULT NULL COMMENT '订单id',\n  `ota_id` varchar(255) DEFAULT NULL COMMENT 'ota',\n  `check_in_date` varchar(255) DEFAULT NULL COMMENT '入住日期',\n  `check_out_date` varchar(255) DEFAULT NULL COMMENT '离店日期',\n  `hotel_id` varchar(255) DEFAULT NULL COMMENT '酒店ID',\n  `guest_name` varchar(255) DEFAULT NULL COMMENT '顾客',\n  `purcharse_time` timestamp NULL DEFAULT NULL COMMENT '购买时间',\n  `create_time` datetime DEFAULT NULL,\n  `update_time` datetime DEFAULT NULL,\n  `create_user` varchar(255) DEFAULT NULL,\n  `update_user` varchar(255) DEFAULT NULL,\n  `status` int(4) DEFAULT '1' COMMENT '状态 ： 1 正常 ， 0 删除',\n  `hotel_name` varchar(255) DEFAULT NULL,\n  `price` decimal(10,0) DEFAULT NULL,\n  `remark` longtext,\n  PRIMARY KEY (`id`),\n  KEY `IDX_order_id` (`order_id`) USING BTREE,\n  KEY `hotel_name` (`hotel_name`) USING BTREE,\n  KEY `ota_id` (`ota_id`) USING BTREE,\n  KEY `IDX_purcharse_time` (`purcharse_time`) USING BTREE,\n  KEY `IDX_create_time` (`create_time`) USING BTREE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8\nPARTITION BY RANGE (to_days(create_time)) ( \nPARTITION p201808 VALUES LESS THAN (to_days('2018-09-01')), \nPARTITION p201809 VALUES LESS THAN (to_days('2018-10-01')), \nPARTITION p201810 VALUES LESS THAN (to_days('2018-11-01')), \nPARTITION p201811 VALUES LESS THAN (to_days('2018-12-01')), \nPARTITION p201812 VALUES LESS THAN (to_days('2019-01-01')), \nPARTITION p201901 VALUES LESS THAN (to_days('2019-02-01')), \nPARTITION p201902 VALUES LESS THAN (to_days('2019-03-01')), \nPARTITION p201903 VALUES LESS THAN (to_days('2019-04-01')), \nPARTITION p201904 VALUES LESS THAN (to_days('2019-05-01')), \nPARTITION p201905 VALUES LESS THAN (to_days('2019-06-01')), \nPARTITION p201906 VALUES LESS THAN (to_days('2019-07-01')), \nPARTITION p201907 VALUES LESS THAN (to_days('2019-08-01')), \nPARTITION p201908 VALUES LESS THAN (to_days('2019-09-01')), \nPARTITION p201909 VALUES LESS THAN (to_days('2019-10-01')), \nPARTITION p201910 VALUES LESS THAN (to_days('2019-11-01')), \nPARTITION p201911 VALUES LESS THAN (to_days('2019-12-01')), \nPARTITION p201912 VALUES LESS THAN (to_days('2020-01-01')));\n\n#2. 插入原表中无效的数据（需要跟开发同学确认数据保留范围）\ncreate table tbl_p201808 as select * from ota_order where create_time between '2018-08-01 00:00:00' and '2018-08-31 23:59:59';\n\n#3. 跟归档表分区做分区交换\nalter table ota_order_bak exchange partition p201808 with table tbl_p201808; \n\n#4. 删除原表中已经规范的数据\ndelete from ota_order where create_time between '2018-08-01 00:00:00' and '2018-08-31 23:59:59' limit 3000;\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n<li>31</li>\n<li>32</li>\n<li>33</li>\n<li>34</li>\n<li>35</li>\n<li>36</li>\n<li>37</li>\n<li>38</li>\n<li>39</li>\n<li>40</li>\n<li>41</li>\n<li>42</li>\n<li>43</li>\n<li>44</li>\n<li>45</li>\n<li>46</li>\n<li>47</li>\n<li>48</li>\n<li>49</li>\n<li>50</li>\n<li>51</li>\n<li>52</li>\n</ul>\n<h3><a name=\"t19\"></a><a name=\"t19\"></a><a id=\"_469\"></a>优化后的归档方式</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#1. 创建中间表\nCREATE TABLE `ota_order_2020` (........) ENGINE=InnoDB DEFAULT CHARSET=utf8\nPARTITION BY RANGE (to_days(create_time)) ( \nPARTITION p201808 VALUES LESS THAN (to_days('2018-09-01')), \nPARTITION p201809 VALUES LESS THAN (to_days('2018-10-01')), \nPARTITION p201810 VALUES LESS THAN (to_days('2018-11-01')), \nPARTITION p201811 VALUES LESS THAN (to_days('2018-12-01')), \nPARTITION p201812 VALUES LESS THAN (to_days('2019-01-01')), \nPARTITION p201901 VALUES LESS THAN (to_days('2019-02-01')), \nPARTITION p201902 VALUES LESS THAN (to_days('2019-03-01')), \nPARTITION p201903 VALUES LESS THAN (to_days('2019-04-01')), \nPARTITION p201904 VALUES LESS THAN (to_days('2019-05-01')), \nPARTITION p201905 VALUES LESS THAN (to_days('2019-06-01')), \nPARTITION p201906 VALUES LESS THAN (to_days('2019-07-01')), \nPARTITION p201907 VALUES LESS THAN (to_days('2019-08-01')), \nPARTITION p201908 VALUES LESS THAN (to_days('2019-09-01')), \nPARTITION p201909 VALUES LESS THAN (to_days('2019-10-01')), \nPARTITION p201910 VALUES LESS THAN (to_days('2019-11-01')), \nPARTITION p201911 VALUES LESS THAN (to_days('2019-12-01')), \nPARTITION p201912 VALUES LESS THAN (to_days('2020-01-01')));\n\n#2. 插入原表中有效的数据，如果数据量在100W左右可以在业务低峰期直接插入，如果比较大，建议采用dataX来做，可以控制频率和大小，之前我这边用Go封装了dataX可以实现自动生成json文件，自定义大小去执行。\ninsert into ota_order_2020 select * from ota_order where create_time between '2020-08-01 00:00:00' and '2020-08-31 23:59:59';\n\n#3. 表重命名\nalter table ota_order rename to ota_order_bak;  \nalter table ota_order_2020 rename to ota_order;\n#4. 插入差异数据\ninsert into ota_order select * from ota_order_bak a where not exists (select 1 from ota_order b where a.id = b.id);\n#5. ota_order_bak改造成分区表，如果表比较大不建议直接改造，可以先创建好分区表，通过dataX把导入进去即可。\n\n#6. 后续的归档方法\n#创建中间普遍表\ncreate table ota_order_mid like ota_order;\n#交换原表无效数据分区到普通表\nalter table ota_order exchange partition p201808 with table ota_order_mid; \n##交换普通表数据到归档表的相应分区\nalter table ota_order_bak exchange partition p201808 with table ota_order_mid; \n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n<li>31</li>\n<li>32</li>\n<li>33</li>\n<li>34</li>\n<li>35</li>\n<li>36</li>\n<li>37</li>\n<li>38</li>\n</ul>\n<p>这样原表和归档表都是按月的分区表，只需要创建一个中间普通表，在业务低峰期做两次分区交换，既可以删除无效数据，又能回收空，而且没有空间碎片，不会影响表上的索引及SQL的执行计划。</p>\n<h2><a name=\"t20\"></a><a name=\"t20\"></a><a id=\"_514\"></a>总结</h2>\n<p>通过从InnoDB存储空间分布，delete对性能的影响可以看到，delete物理删除既不能释放磁盘空间，而且会产生大量的碎片，导致索引频繁分裂，影响SQL执行计划的稳定性；</p>\n<p>同时在碎片回收时，会耗用大量的CPU，磁盘空间，影响表上正常的DML操作。</p>\n<p>在业务代码层面，应该做逻辑标记删除，避免物理删除；为了实现数据归档需求，可以用采用MySQL分区表特性来实现，都是DDL操作，没有碎片产生。</p>\n<p>另外一个比较好的方案采用Clickhouse，对有生命周期的数据表可以使用Clickhouse存储，利用其TTL特性实现无效数据自动清理。</p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1330877080455553024","blogRead":0,"blogRemark":"MySQL","blogTitle":"面试官不讲武德问我：为什么MySQL不建议使用delete删除数据？","blogType":1,"createdTime":1606111996000,"version":3},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:44:02.227 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:44:06.026 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==>  Preparing: select blog_id, blog_title, blog_content, blog_goods, blog_image, blog_read, blog_collection, blog_type, blog_remark, blog_comment, blog_source, created_time, version from bl_blog where blog_id = ? and deleted = 0 
2020-12-24 23:44:06.027 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==> Parameters: 1330877080455553024(String)
2020-12-24 23:44:06.100 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -<==      Total: 1
2020-12-24 23:44:06.144 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:44:06.147 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/get/1330877080455553024(String), [1330877080455553024](String), 1(Integer), null, GET(String), 116(Long), {"code":20000,"data":{"blogCollection":0,"blogComment":0,"blogContent":"<h2>前言</h2>\n<p>我负责的有几个系统随着业务量的增长，存储在MySQL中的数据日益剧增，我当时就想现在的业务方不讲武德，搞偷袭，趁我没反应过来把很多表，很快，很快啊都打到了亿级别，我大意了，没有闪，这就导致跟其Join的表的SQL变得很慢，对的应用接口的response time也变长了，影响了用户体验。</p>\n<p>事后我找到业务方，我批评了他们跟他们说要讲武德，连忙跟我道歉，这个事情才就此作罢，走的时候我对他们说下次不要这样了，耗子尾汁，好好反思。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/3c93aececcb9e763f5476362c4e88710.png\" alt=\"\" /></p>\n<p>骂归骂，事情还是得解决，时候我分析原因发现，发现有些表的数据量增长很快，对应SQL扫描了很多无效数据，导致SQL慢了下来，通过确认之后，这些大表都是一些流水、记录、日志类型数据，只需要保留1到3个月，此时需要对表做数据清理实现瘦身，一般都会想到用insert + delete的方式去清理。</p>\n<p>这篇文章我会从InnoDB存储空间分布，delete对性能的影响，以及优化建议方面解释为什么不建议delete删除数据。</p>\n<h2><a name=\"t1\"></a><a name=\"t1\"></a><a id=\"InnoDB_16\"></a>InnoDB存储架构</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/5c66ffe9749c58e1613d2519f7ea7211.png\" alt=\"\" /></p>\n<p>从这张图可以看到，InnoDB存储结构主要包括两部分：逻辑存储结构和物理存储结构。</p>\n<p>逻辑上是由表空间tablespace &mdash;&gt; 段segment或者inode &mdash;&gt; 区Extent &mdash;&mdash;&gt;数据页Page构成，Innodb逻辑管理单位是segment，空间分配的最小单位是extent，每个segment都会从表空间FREE_PAGE中分配32个page，当这32个page不够用时，会按照以下原则进行扩展：如果当前小于1个extent，则扩展到1个extent；当表空间小于32MB时，每次扩展一个extent；表空间大于32MB，每次扩展4个extent。</p>\n<p>物理上主要由系统用户数据文件，日志文件组成，数据文件主要存储MySQL字典数据和用户数据，日志文件记录的是data page的变更记录，用于MySQL Crash时的恢复。</p>\n<h2><a name=\"t2\"></a><a name=\"t2\"></a><a id=\"Innodb_26\"></a>Innodb表空间</h2>\n<p>InnoDB存储包括三类表空间：系统表空间，用户表空间，Undo表空间。</p>\n<p><strong>系统表空间：</strong>&nbsp;主要存储MySQL内部的数据字典数据，如information_schema下的数据。</p>\n<p><strong>用户表空间：</strong>&nbsp;当开启innodb_file_per_table=1时，数据表从系统表空间独立出来存储在以table_name.ibd命令的数据文件中，结构信息存储在table_name.frm文件中。</p>\n<p><strong>Undo表空间：</strong>&nbsp;存储Undo信息，如快照一致读和flashback都是利用undo信息。</p>\n<p>从MySQL 8.0开始允许用户自定义表空间，具体语法如下：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">CREATE TABLESPACE tablespace_name\n    ADD DATAFILE 'file_name'               #数据文件名\n    USE LOGFILE GROUP logfile_group        #自定义日志文件组，一般每组2个logfile。\n    [EXTENT_SIZE [=] extent_size]          #区大小\n    [INITIAL_SIZE [=] initial_size]        #初始化大小 \n    [AUTOEXTEND_SIZE [=] autoextend_size]  #自动扩宽尺寸\n    [MAX_SIZE [=] max_size]                #单个文件最大size，最大是32G。\n    [NODEGROUP [=] nodegroup_id]           #节点组\n    [WAIT]\n    [COMMENT [=] comment_text]\n    ENGINE [=] engine_name\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n</ul>\n<p>这样的好处是可以做到数据的冷热分离，分别用HDD和SSD来存储，既能实现数据的高效访问，又能节约成本，比如可以添加两块500G硬盘，经过创建卷组vg，划分逻辑卷lv，创建数据目录并mount相应的lv，假设划分的两个目录分别是/hot_data 和 /cold_data。</p>\n<p>这样就可以将核心的业务表如用户表，订单表存储在高性能SSD盘上，一些日志，流水表存储在普通的HDD上，主要的操作步骤如下：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#创建热数据表空间\ncreate tablespace tbs_data_hot add datafile '/hot_data/tbs_data_hot01.dbf' max_size 20G;\n#创建核心业务表存储在热数据表空间\ncreate table booking(id bigint not null primary key auto_increment, &hellip;&hellip; ) tablespace tbs_data_hot;\n#创建冷数据表空间\ncreate tablespace tbs_data_cold add datafile '/hot_data/tbs_data_cold01.dbf' max_size 20G;\n#创建日志，流水，备份类的表存储在冷数据表空间\ncreate table payment_log(id bigint not null primary key auto_increment, &hellip;&hellip; ) tablespace tbs_data_cold;\n#可以移动表到另一个表空间\nalter table payment_log tablespace tbs_data_hot;\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n</ul>\n<h2><a name=\"t3\"></a><a name=\"t3\"></a><a id=\"Inndob_69\"></a>Inndob存储分布</h2>\n<h3><a name=\"t4\"></a><a name=\"t4\"></a><a id=\"_71\"></a>创建空表查看空间变化</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; create table user(id bigint not null primary key auto_increment, \n    -&gt; name varchar(20) not null default '' comment '姓名', \n    -&gt; age tinyint not null default 0 comment 'age', \n    -&gt; gender char(1) not null default 'M'  comment '性别',\n    -&gt; phone varchar(16) not null default '' comment '手机号',\n    -&gt; create_time datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n    -&gt; update_time datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间'\n    -&gt; ) engine = InnoDB DEFAULT CHARSET=utf8mb4 COMMENT '用户信息表';\nQuery OK, 0 rows affected (0.26 sec)\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n</ul>\n<pre class=\"prettyprint\"><code class=\"prism language-bash has-numbering\"><span class=\"token comment\"># ls -lh user1.ibd </span>\n-rw-r----- 1 mysql mysql 96K Nov  6 12:48 user.ibd\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n</ul>\n<p>设置参数innodb_file_per_table=1时，创建表时会自动创建一个segment，同时分配一个extent，包含32个data page的来存储数据，这样创建的空表默认大小就是96KB，extent使用完之后会申请64个连接页，这样对于一些小表，或者undo segment，可以在开始时申请较少的空间，节省磁盘容量的开销。</p>\n<pre class=\"prettyprint\"><code class=\"prism language-shell has-numbering\"><span class=\"token comment\"># python2 py_innodb_page_info.py -v /data2/mysql/test/user.ibd</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>File Space Header<span class=\"token operator\">&gt;</span>\npage offset 00000001, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Insert Buffer Bitmap<span class=\"token operator\">&gt;</span>\npage offset 00000002, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>File Segment inode<span class=\"token operator\">&gt;</span>\npage offset 00000003, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>B-tree Node<span class=\"token operator\">&gt;</span>, page level <span class=\"token operator\">&lt;</span>0000<span class=\"token operator\">&gt;</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Freshly Allocated Page<span class=\"token operator\">&gt;</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Freshly Allocated Page<span class=\"token operator\">&gt;</span>\nTotal number of page: 6:      <span class=\"token comment\">#总共分配的页数</span>\nFreshly Allocated Page: 2     <span class=\"token comment\">#可用的数据页</span>\nInsert Buffer Bitmap: 1       <span class=\"token comment\">#插入缓冲页</span>\nFile Space Header: 1          <span class=\"token comment\">#文件空间头</span>\nB-tree Node: 1                <span class=\"token comment\">#数据页</span>\nFile Segment inode: 1         <span class=\"token comment\">#文件端inonde，如果是在ibdata1.ibd上会有多个inode。</span>\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n</ul>\n<h3><a name=\"t5\"></a><a name=\"t5\"></a><a id=\"_108\"></a>插入数据后的空间变化</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; DELIMITER $$\nmysql&gt; CREATE PROCEDURE insert_user_data(num INTEGER) \n    -&gt; BEGIN\n    -&gt;     DECLARE v_i int unsigned DEFAULT 0;\n    -&gt; set autocommit= 0;\n    -&gt; WHILE v_i &lt; num DO\n    -&gt;    insert into user(`name`, age, gender, phone) values (CONCAT('lyn',v_i), mod(v_i,120), 'M', CONCAT('152',ROUND(RAND(1)*100000000)));\n    -&gt;  SET v_i = v_i+1;\n    -&gt; END WHILE;\n    -&gt; commit;\n    -&gt; END $$\nQuery OK, 0 rows affected (0.01 sec)\nmysql&gt; DELIMITER ;\n\n#插入10w数据\nmysql&gt; call insert_user_data(100000);\nQuery OK, 0 rows affected (6.69 sec)\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n</ul>\n<pre class=\"prettyprint\"><code class=\"prism language-shell has-numbering\"><span class=\"token comment\"># ls -lh user.ibd</span>\n-rw-r----- 1 mysql mysql 14M Nov 6 10:58 /data2/mysql/test/user.ibd\n\n<span class=\"token comment\"># python2 py_innodb_page_info.py -v /data2/mysql/test/user.ibd</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>File Space Header<span class=\"token operator\">&gt;</span>\npage offset 00000001, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Insert Buffer Bitmap<span class=\"token operator\">&gt;</span>\npage offset 00000002, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>File Segment inode<span class=\"token operator\">&gt;</span>\npage offset 00000003, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>B-tree Node<span class=\"token operator\">&gt;</span>, page level <span class=\"token operator\">&lt;</span>0001<span class=\"token operator\">&gt;</span>   <span class=\"token comment\">#增加了一个非叶子节点，树的高度从1变为2.</span>\n<span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Freshly Allocated Page<span class=\"token operator\">&gt;</span>\nTotal number of page: 896:\nFreshly Allocated Page: 493\nInsert Buffer Bitmap: 1\nFile Space Header: 1\nB-tree Node: 400\nFile Segment inode: 1\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n</ul>\n<h3><a name=\"t6\"></a><a name=\"t6\"></a><a id=\"delete_149\"></a>delete数据后的空间变化</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; select min(id),max(id),count(*) from user;\n+---------+---------+----------+\n| min(id) | max(id) | count(*) |\n+---------+---------+----------+\n|       1 |  100000 |   100000 |\n+---------+---------+----------+\n1 row in set (0.05 sec)\n#删除50000条数据，理论上空间应该从14MB变长7MB左右。\nmysql&gt; delete from user limit 50000;\nQuery OK, 50000 rows affected (0.25 sec)\n\n#数据文件大小依然是14MB，没有缩小。\n# ls -lh /data2/mysql/test/user1.ibd \n-rw-r----- 1 mysql mysql 14M Nov  6 13:22 /data2/mysql/test/user.ibd\n\n#数据页没有被回收。\n# python2 py_innodb_page_info.py -v /data2/mysql/test/user.ibd\npage offset 00000000, page type &lt;File Space Header&gt;\npage offset 00000001, page type &lt;Insert Buffer Bitmap&gt;\npage offset 00000002, page type &lt;File Segment inode&gt;\npage offset 00000003, page type &lt;B-tree Node&gt;, page level &lt;0001&gt;\n........................................................\npage offset 00000000, page type &lt;Freshly Allocated Page&gt;\nTotal number of page: 896:\nFreshly Allocated Page: 493\nInsert Buffer Bitmap: 1\nFile Space Header: 1\nB-tree Node: 400\nFile Segment inode: 1\n#在MySQL内部是标记删除，\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n</ul>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; use information_schema;\n\nDatabase changed\nmysql&gt; SELECT A.SPACE AS TBL_SPACEID, A.TABLE_ID, A.NAME AS TABLE_NAME, FILE_FORMAT, ROW_FORMAT, SPACE_TYPE,  B.INDEX_ID , B.NAME AS INDEX_NAME, PAGE_NO, B.TYPE AS INDEX_TYPE FROM INNODB_SYS_TABLES A LEFT JOIN INNODB_SYS_INDEXES B ON A.TABLE_ID =B.TABLE_ID WHERE A.NAME = 'test/user1';\n+-------------+----------+------------+-------------+------------+------------+----------+------------+---------+------------+\n| TBL_SPACEID | TABLE_ID | TABLE_NAME | FILE_FORMAT | ROW_FORMAT | SPACE_TYPE | INDEX_ID | INDEX_NAME | PAGE_NO | INDEX_TYPE |\n+-------------+----------+------------+-------------+------------+------------+----------+------------+---------+------------+\n|        1283 |     1207 | test/user | Barracuda   | Dynamic    | Single     |     2236 | PRIMARY    |       3 |          3 |\n+-------------+----------+------------+-------------+------------+------------+----------+------------+---------+------------+\n1 row in set (0.01 sec)\n\nPAGE_NO = 3 标识B-tree的root page是3号页，INDEX_TYPE = 3是聚集索引。 INDEX_TYPE取值如下：\n0 = nonunique secondary index; \n1 = automatically generated clustered index (GEN_CLUST_INDEX); \n2 = unique nonclustered index; \n3 = clustered index; \n32 = full-text index;\n#收缩空间再后进行观察\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n</ul>\n<p>MySQL内部不会真正删除空间，而且做标记删除，即将delflag:N修改为delflag:Y，commit之后会会被purge进入删除链表，如果下一次insert更大的记录，delete之后的空间不会被重用，如果插入的记录小于等于delete的记录空会被重用，这块内容可以通过知数堂的innblock工具进行分析。</p>\n<h2><a name=\"t7\"></a><a name=\"t7\"></a><a id=\"Innodb_207\"></a>Innodb中的碎片</h2>\n<h3><a name=\"t8\"></a><a name=\"t8\"></a><a id=\"_209\"></a>碎片的产生</h3>\n<p>我们知道数据存储在文件系统上的，总是不能100%利用分配给它的物理空间，删除数据会在页面上留下一些&rdquo;空洞&rdquo;，或者随机写入（聚集索引非线性增加）会导致页分裂，页分裂导致页面的利用空间少于50%，另外对表进行增删改会引起对应的二级索引值的随机的增删改，也会导致索引结构中的数据页面上留下一些\"空洞\"，虽然这些空洞有可能会被重复利用，但终究会导致部分物理空间未被使用，也就是碎片。</p>\n<p>同时，即便是设置了填充因子为100%，Innodb也会主动留下page页面1/16的空间作为预留使用（An innodb_fill_factor setting of 100 leaves 1/16 of the space in clustered index pages free for future index growth）防止update带来的行溢出。</p>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; select table_schema,\n    -&gt;        table_name,ENGINE,\n    -&gt;        round(DATA_LENGTH/1024/1024+ INDEX_LENGTH/1024/1024) total_mb,TABLE_ROWS,\n    -&gt;        round(DATA_LENGTH/1024/1024) data_mb, round(INDEX_LENGTH/1024/1024) index_mb, round(DATA_FREE/1024/1024) free_mb, round(DATA_FREE/DATA_LENGTH*100,2) free_ratio\n    -&gt; from information_schema.TABLES where  TABLE_SCHEMA= 'test'\n    -&gt; and TABLE_NAME= 'user';\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n| table_schema | table_name | ENGINE | total_mb | TABLE_ROWS | data_mb | index_mb | free_mb | free_ratio |\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n| test         | user      | InnoDB |        4 |      50000 |       4 |        0 |       6 |     149.42 |\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n1 row in set (0.00 sec)\n\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n</ul>\n<p>其中data_free是分配了未使用的字节数，并不能说明完全是碎片空间。</p>\n<h3><a name=\"t9\"></a><a name=\"t9\"></a><a id=\"_233\"></a>碎片的回收</h3>\n<p>对于InnoDB的表，可以通过以下命令来回收碎片，释放空间，这个是随机读IO操作，会比较耗时，也会阻塞表上正常的DML运行，同时需要占用额外更多的磁盘空间，对于RDS来说，可能会导致磁盘空间瞬间爆满，实例瞬间被锁定，应用无法做DML操作，所以禁止在线上环境去执行。</p>\n<pre class=\"prettyprint\"><code class=\"prism language-shell has-numbering\"><span class=\"token comment\">#执行InnoDB的碎片回收</span>\nmysql<span class=\"token operator\">&gt;</span> alter table user engine<span class=\"token operator\">=</span>InnoDB<span class=\"token punctuation\">;</span>\nQuery OK, 0 rows affected <span class=\"token punctuation\">(</span>9.00 sec<span class=\"token punctuation\">)</span>\nRecords: 0  Duplicates: 0  Warnings: 0\n\n<span class=\"token comment\">##执行完之后，数据文件大小从14MB降低到10M。</span>\n<span class=\"token comment\"># ls -lh /data2/mysql/test/user1.ibd </span>\n-rw-r----- 1 mysql mysql 10M Nov 6 16:18 /data2/mysql/test/user.ibd\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n</ul>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; select table_schema,        table_name,ENGINE,        round(DATA_LENGTH/1024/1024+ INDEX_LENGTH/1024/1024) total_mb,TABLE_ROWS,        round(DATA_LENGTH/1024/1024) data_mb, round(INDEX_LENGTH/1024/1024) index_mb, round(DATA_FREE/1024/1024) free_mb, round(DATA_FREE/DATA_LENGTH*100,2) free_ratio from information_schema.TABLES where  TABLE_SCHEMA= 'test' and TABLE_NAME= 'user';\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n| table_schema | table_name | ENGINE | total_mb | TABLE_ROWS | data_mb | index_mb | free_mb | free_ratio |\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n| test         | user      | InnoDB |        5 |      50000 |       5 |        0 |       2 |      44.29 |\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n1 row in set (0.00 sec)\n\n\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n</ul>\n<h2><a name=\"t10\"></a><a name=\"t10\"></a><a id=\"deleteSQL_260\"></a>delete对SQL的影响</h2>\n<h3><a name=\"t11\"></a><a name=\"t11\"></a><a id=\"SQL_262\"></a>未删除前的SQL执行情况</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#插入100W数据\nmysql&gt; call insert_user_data(1000000);\nQuery OK, 0 rows affected (35.99 sec)\n\n#添加相关索引\nmysql&gt; alter table user add index idx_name(name), add index idx_phone(phone);\nQuery OK, 0 rows affected (6.00 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\n#表上索引统计信息\nmysql&gt; show index from user;\n+-------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+\n| Table | Non_unique | Key_name  | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |\n+-------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+\n| user  |          0 | PRIMARY   |            1 | id          | A         |      996757 |     NULL | NULL   |      | BTREE      |         |               |\n| user  |          1 | idx_name  |            1 | name        | A         |      996757 |     NULL | NULL   |      | BTREE      |         |               |\n| user  |          1 | idx_phone |            1 | phone       | A         |           2 |     NULL | NULL   |      | BTREE      |         |               |\n+-------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+\n3 rows in set (0.00 sec)\n\n#重置状态变量计数\nmysql&gt; flush status;\nQuery OK, 0 rows affected (0.00 sec)\n\n#执行SQL语句\nmysql&gt; select id, age ,phone from user where name like 'lyn12%';\n+--------+-----+-------------+\n| id     | age | phone       |\n+--------+-----+-------------+\n|    124 |   3 | 15240540354 |\n|   1231 |  30 | 15240540354 |\n|  12301 |  60 | 15240540354 |\n.............................\n| 129998 |  37 | 15240540354 |\n| 129999 |  38 | 15240540354 |\n| 130000 |  39 | 15240540354 |\n+--------+-----+-------------+\n11111 rows in set (0.03 sec)\n\nmysql&gt; explain select id, age ,phone from user where name like 'lyn12%';\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n| id | select_type | table | type  | possible_keys | key      | key_len | ref  | rows  | Extra                 |\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n|  1 | SIMPLE      | user  | range | idx_name      | idx_name | 82      | NULL | 22226 | Using index condition |\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n1 row in set (0.00 sec)\n\n#查看相关状态呢变量\nmysql&gt; select * from information_schema.session_status where variable_name in('Last_query_cost','Handler_read_next','Innodb_pages_read','Innodb_data_reads','Innodb_pages_read');\n+-------------------+----------------+\n| VARIABLE_NAME     | VARIABLE_VALUE |\n+-------------------+----------------+\n| HANDLER_READ_NEXT | 11111          |    #请求读的行数\n| INNODB_DATA_READS | 7868409        |    #数据物理读的总数\n| INNODB_PAGES_READ | 7855239        |    #逻辑读的总数\n| LAST_QUERY_COST   | 10.499000      |    #SQL语句的成本COST，主要包括IO_COST和CPU_COST。\n+-------------------+----------------+\n4 rows in set (0.00 sec)\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n<li>31</li>\n<li>32</li>\n<li>33</li>\n<li>34</li>\n<li>35</li>\n<li>36</li>\n<li>37</li>\n<li>38</li>\n<li>39</li>\n<li>40</li>\n<li>41</li>\n<li>42</li>\n<li>43</li>\n<li>44</li>\n<li>45</li>\n<li>46</li>\n<li>47</li>\n<li>48</li>\n<li>49</li>\n<li>50</li>\n<li>51</li>\n<li>52</li>\n<li>53</li>\n<li>54</li>\n<li>55</li>\n<li>56</li>\n<li>57</li>\n<li>58</li>\n</ul>\n<h3><a name=\"t12\"></a><a name=\"t12\"></a><a id=\"SQL_325\"></a>删除后的SQL执行情况</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#删除50w数据\nmysql&gt; delete from user limit 500000;\nQuery OK, 500000 rows affected (3.70 sec)\n\n#分析表统计信息\nmysql&gt; analyze table user;\n+-----------+---------+----------+----------+\n| Table     | Op      | Msg_type | Msg_text |\n+-----------+---------+----------+----------+\n| test.user | analyze | status   | OK       |\n+-----------+---------+----------+----------+\n1 row in set (0.01 sec)\n\n#重置状态变量计数\nmysql&gt; flush status;\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql&gt; select id, age ,phone from user where name like 'lyn12%';\nEmpty set (0.05 sec)\n\nmysql&gt; explain select id, age ,phone from user where name like 'lyn12%';\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n| id | select_type | table | type  | possible_keys | key      | key_len | ref  | rows  | Extra                 |\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n|  1 | SIMPLE      | user  | range | idx_name      | idx_name | 82      | NULL | 22226 | Using index condition |\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n1 row in set (0.00 sec)\n\nmysql&gt; select * from information_schema.session_status where variable_name in('Last_query_cost','Handler_read_next','Innodb_pages_read','Innodb_data_reads','Innodb_pages_read');\n+-------------------+----------------+\n| VARIABLE_NAME     | VARIABLE_VALUE |\n+-------------------+----------------+\n| HANDLER_READ_NEXT | 0              |\n| INNODB_DATA_READS | 7868409        |\n| INNODB_PAGES_READ | 7855239        |\n| LAST_QUERY_COST   | 10.499000      |\n+-------------------+----------------+\n4 rows in set (0.00 sec)\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n<li>31</li>\n<li>32</li>\n<li>33</li>\n<li>34</li>\n<li>35</li>\n<li>36</li>\n<li>37</li>\n<li>38</li>\n</ul>\n<h3><a name=\"t13\"></a><a name=\"t13\"></a><a id=\"_368\"></a>结果统计分析</h3>\n<div class=\"table-box\">\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>COST</th>\n<th>物理读次数</th>\n<th>逻辑读次数</th>\n<th>扫描行数</th>\n<th>返回行数</th>\n<th>执行时间</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>初始化插入100W</td>\n<td>10.499000</td>\n<td>7868409</td>\n<td>7855239</td>\n<td>22226</td>\n<td>11111</td>\n<td>30ms</td>\n</tr>\n<tr>\n<td>100W随机删除50W</td>\n<td>10.499000</td>\n<td>7868409</td>\n<td>7855239</td>\n<td>22226</td>\n<td>0</td>\n<td>50ms</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>这也说明对普通的大表，想要通过delete数据来对表进行瘦身是不现实的，所以在任何时候不要用delete去删除数据，应该使用优雅的标记删除。</p>\n<h2><a name=\"t14\"></a><a name=\"t14\"></a><a id=\"delete_377\"></a>delete优化建议</h2>\n<h3><a name=\"t15\"></a><a name=\"t15\"></a><a id=\"_379\"></a>控制业务账号权限</h3>\n<p>对于一个大的系统来说，需要根据业务特点去拆分子系统，每个子系统可以看做是一个service，例如美团APP，上面有很多服务，核心的服务有用户服务user-service，搜索服务search-service，商品product-service，位置服务location-service，价格服务price-service等。每个服务对应一个数据库，为该数据库创建单独账号，同时只授予DML权限且没有delete权限，同时禁止跨库访问。</p>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#创建用户数据库并授权\ncreate database mt_user charset utf8mb4;\ngrant USAGE, SELECT, INSERT, UPDATE ON mt_user.*  to 'w_user'@'%' identified by 't$W*g@gaHTGi123456';\nflush privileges;\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n</ul>\n<h3><a name=\"t16\"></a><a name=\"t16\"></a><a id=\"delete_390\"></a>delete改为标记删除</h3>\n<p>在MySQL数据库建模规范中有4个公共字段，基本上每个表必须有的，同时在create_time列要创建索引，有两方面的好处：</p>\n<ol>\n<li>一些查询业务场景都会有一个默认的时间段，比如7天或者一个月，都是通过create_time去过滤，走索引扫描更快。</li>\n<li>一些核心的业务表需要以T +1的方式抽取数据仓库中，比如每天晚上00:30抽取前一天的数据，都是通过create_time过滤的。</li>\n</ol>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">`id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键id',\n`is_deleted` tinyint(4) NOT NULL DEFAULT '0' COMMENT '是否逻辑删除：0：未删除，1：已删除',\n`create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n`update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间'\n\n#有了删除标记，业务接口的delete操作就可以转换为update\nupdate user set is_deleted = 1 where user_id = 1213;\n\n#查询的时候需要带上is_deleted过滤\nselect id, age ,phone from user where is_deleted = 0 and name like 'lyn12%';\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n</ul>\n<h2><a name=\"t17\"></a><a name=\"t17\"></a><a id=\"_410\"></a>数据归档方式</h2>\n<h3><a name=\"t18\"></a><a name=\"t18\"></a><a id=\"_412\"></a>通用数据归档方法</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#1. 创建归档表，一般在原表名后面添加_bak。\nCREATE TABLE `ota_order_bak` (\n  `id` bigint(11) NOT NULL AUTO_INCREMENT COMMENT '主键',\n  `order_id` varchar(255) DEFAULT NULL COMMENT '订单id',\n  `ota_id` varchar(255) DEFAULT NULL COMMENT 'ota',\n  `check_in_date` varchar(255) DEFAULT NULL COMMENT '入住日期',\n  `check_out_date` varchar(255) DEFAULT NULL COMMENT '离店日期',\n  `hotel_id` varchar(255) DEFAULT NULL COMMENT '酒店ID',\n  `guest_name` varchar(255) DEFAULT NULL COMMENT '顾客',\n  `purcharse_time` timestamp NULL DEFAULT NULL COMMENT '购买时间',\n  `create_time` datetime DEFAULT NULL,\n  `update_time` datetime DEFAULT NULL,\n  `create_user` varchar(255) DEFAULT NULL,\n  `update_user` varchar(255) DEFAULT NULL,\n  `status` int(4) DEFAULT '1' COMMENT '状态 ： 1 正常 ， 0 删除',\n  `hotel_name` varchar(255) DEFAULT NULL,\n  `price` decimal(10,0) DEFAULT NULL,\n  `remark` longtext,\n  PRIMARY KEY (`id`),\n  KEY `IDX_order_id` (`order_id`) USING BTREE,\n  KEY `hotel_name` (`hotel_name`) USING BTREE,\n  KEY `ota_id` (`ota_id`) USING BTREE,\n  KEY `IDX_purcharse_time` (`purcharse_time`) USING BTREE,\n  KEY `IDX_create_time` (`create_time`) USING BTREE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8\nPARTITION BY RANGE (to_days(create_time)) ( \nPARTITION p201808 VALUES LESS THAN (to_days('2018-09-01')), \nPARTITION p201809 VALUES LESS THAN (to_days('2018-10-01')), \nPARTITION p201810 VALUES LESS THAN (to_days('2018-11-01')), \nPARTITION p201811 VALUES LESS THAN (to_days('2018-12-01')), \nPARTITION p201812 VALUES LESS THAN (to_days('2019-01-01')), \nPARTITION p201901 VALUES LESS THAN (to_days('2019-02-01')), \nPARTITION p201902 VALUES LESS THAN (to_days('2019-03-01')), \nPARTITION p201903 VALUES LESS THAN (to_days('2019-04-01')), \nPARTITION p201904 VALUES LESS THAN (to_days('2019-05-01')), \nPARTITION p201905 VALUES LESS THAN (to_days('2019-06-01')), \nPARTITION p201906 VALUES LESS THAN (to_days('2019-07-01')), \nPARTITION p201907 VALUES LESS THAN (to_days('2019-08-01')), \nPARTITION p201908 VALUES LESS THAN (to_days('2019-09-01')), \nPARTITION p201909 VALUES LESS THAN (to_days('2019-10-01')), \nPARTITION p201910 VALUES LESS THAN (to_days('2019-11-01')), \nPARTITION p201911 VALUES LESS THAN (to_days('2019-12-01')), \nPARTITION p201912 VALUES LESS THAN (to_days('2020-01-01')));\n\n#2. 插入原表中无效的数据（需要跟开发同学确认数据保留范围）\ncreate table tbl_p201808 as select * from ota_order where create_time between '2018-08-01 00:00:00' and '2018-08-31 23:59:59';\n\n#3. 跟归档表分区做分区交换\nalter table ota_order_bak exchange partition p201808 with table tbl_p201808; \n\n#4. 删除原表中已经规范的数据\ndelete from ota_order where create_time between '2018-08-01 00:00:00' and '2018-08-31 23:59:59' limit 3000;\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n<li>31</li>\n<li>32</li>\n<li>33</li>\n<li>34</li>\n<li>35</li>\n<li>36</li>\n<li>37</li>\n<li>38</li>\n<li>39</li>\n<li>40</li>\n<li>41</li>\n<li>42</li>\n<li>43</li>\n<li>44</li>\n<li>45</li>\n<li>46</li>\n<li>47</li>\n<li>48</li>\n<li>49</li>\n<li>50</li>\n<li>51</li>\n<li>52</li>\n</ul>\n<h3><a name=\"t19\"></a><a name=\"t19\"></a><a id=\"_469\"></a>优化后的归档方式</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#1. 创建中间表\nCREATE TABLE `ota_order_2020` (........) ENGINE=InnoDB DEFAULT CHARSET=utf8\nPARTITION BY RANGE (to_days(create_time)) ( \nPARTITION p201808 VALUES LESS THAN (to_days('2018-09-01')), \nPARTITION p201809 VALUES LESS THAN (to_days('2018-10-01')), \nPARTITION p201810 VALUES LESS THAN (to_days('2018-11-01')), \nPARTITION p201811 VALUES LESS THAN (to_days('2018-12-01')), \nPARTITION p201812 VALUES LESS THAN (to_days('2019-01-01')), \nPARTITION p201901 VALUES LESS THAN (to_days('2019-02-01')), \nPARTITION p201902 VALUES LESS THAN (to_days('2019-03-01')), \nPARTITION p201903 VALUES LESS THAN (to_days('2019-04-01')), \nPARTITION p201904 VALUES LESS THAN (to_days('2019-05-01')), \nPARTITION p201905 VALUES LESS THAN (to_days('2019-06-01')), \nPARTITION p201906 VALUES LESS THAN (to_days('2019-07-01')), \nPARTITION p201907 VALUES LESS THAN (to_days('2019-08-01')), \nPARTITION p201908 VALUES LESS THAN (to_days('2019-09-01')), \nPARTITION p201909 VALUES LESS THAN (to_days('2019-10-01')), \nPARTITION p201910 VALUES LESS THAN (to_days('2019-11-01')), \nPARTITION p201911 VALUES LESS THAN (to_days('2019-12-01')), \nPARTITION p201912 VALUES LESS THAN (to_days('2020-01-01')));\n\n#2. 插入原表中有效的数据，如果数据量在100W左右可以在业务低峰期直接插入，如果比较大，建议采用dataX来做，可以控制频率和大小，之前我这边用Go封装了dataX可以实现自动生成json文件，自定义大小去执行。\ninsert into ota_order_2020 select * from ota_order where create_time between '2020-08-01 00:00:00' and '2020-08-31 23:59:59';\n\n#3. 表重命名\nalter table ota_order rename to ota_order_bak;  \nalter table ota_order_2020 rename to ota_order;\n#4. 插入差异数据\ninsert into ota_order select * from ota_order_bak a where not exists (select 1 from ota_order b where a.id = b.id);\n#5. ota_order_bak改造成分区表，如果表比较大不建议直接改造，可以先创建好分区表，通过dataX把导入进去即可。\n\n#6. 后续的归档方法\n#创建中间普遍表\ncreate table ota_order_mid like ota_order;\n#交换原表无效数据分区到普通表\nalter table ota_order exchange partition p201808 with table ota_order_mid; \n##交换普通表数据到归档表的相应分区\nalter table ota_order_bak exchange partition p201808 with table ota_order_mid; \n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n<li>31</li>\n<li>32</li>\n<li>33</li>\n<li>34</li>\n<li>35</li>\n<li>36</li>\n<li>37</li>\n<li>38</li>\n</ul>\n<p>这样原表和归档表都是按月的分区表，只需要创建一个中间普通表，在业务低峰期做两次分区交换，既可以删除无效数据，又能回收空，而且没有空间碎片，不会影响表上的索引及SQL的执行计划。</p>\n<h2><a name=\"t20\"></a><a name=\"t20\"></a><a id=\"_514\"></a>总结</h2>\n<p>通过从InnoDB存储空间分布，delete对性能的影响可以看到，delete物理删除既不能释放磁盘空间，而且会产生大量的碎片，导致索引频繁分裂，影响SQL执行计划的稳定性；</p>\n<p>同时在碎片回收时，会耗用大量的CPU，磁盘空间，影响表上正常的DML操作。</p>\n<p>在业务代码层面，应该做逻辑标记删除，避免物理删除；为了实现数据归档需求，可以用采用MySQL分区表特性来实现，都是DDL操作，没有碎片产生。</p>\n<p>另外一个比较好的方案采用Clickhouse，对有生命周期的数据表可以使用Clickhouse存储，利用其TTL特性实现无效数据自动清理。</p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1330877080455553024","blogRead":0,"blogRemark":"MySQL","blogTitle":"面试官不讲武德问我：为什么MySQL不建议使用delete删除数据？","blogType":1,"createdTime":1606111996000,"version":3},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:44:06.271 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:46:30.599 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==>  Preparing: select blog_id, blog_title, blog_content, blog_goods, blog_image, blog_read, blog_collection, blog_type, blog_remark, blog_comment, blog_source, created_time, version from bl_blog where blog_id = ? and deleted = 0 
2020-12-24 23:46:30.601 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==> Parameters: 1324038097171820544(String)
2020-12-24 23:46:30.638 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -<==      Total: 1
2020-12-24 23:46:30.677 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:46:30.679 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/get/1324038097171820544(String), [1324038097171820544](String), 1(Integer), null, GET(String), 87(Long), {"code":20000,"data":{"blogCollection":0,"blogComment":0,"blogContent":"BeanUtils.copyProperties(a, b);b中的存在的属性，a中一定要有，但是a中可以有多余的属性；a中与b中相同的属性都会被替换，不管是否有值；a、 b中的属性要名字相同，才能被赋值，不然的话需要手动赋值；Spring的BeanUtils的CopyProperties方法需要对应的属性有getter和setter方法；如果存在属性完全相同的内部类，但是不是同一个内部类，即分别属于各自的内部类，则spring会认为属性不同，不会copy；spring和apache的copy属性的方法源和目的参数的位置正好相反，所以导包和调用的时候都要注意一下。","blogGoods":0,"blogId":"1324038097171820544","blogImage":"Java","blogRead":0,"blogRemark":"BeanUtils它提供了对java反射和自省API的包装。它里面还有很多工具类，这里我们介绍一下copyProperties。","blogSource":"百度","blogTitle":"BeanUtils.copyProperties的用法","blogType":1,"createdTime":1604481453000,"version":2},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:46:30.767 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:46:34.623 DEBUG [http-nio-8899-exec-8]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==>  Preparing: select blog_id, blog_title, blog_content, blog_goods, blog_image, blog_read, blog_collection, blog_type, blog_remark, blog_comment, blog_source, created_time, version from bl_blog where blog_id = ? and deleted = 0 
2020-12-24 23:46:34.624 DEBUG [http-nio-8899-exec-8]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==> Parameters: 1330879440221315072(String)
2020-12-24 23:46:34.662 DEBUG [http-nio-8899-exec-8]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -<==      Total: 1
2020-12-24 23:46:34.701 DEBUG [http-nio-8899-exec-8]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:46:34.703 DEBUG [http-nio-8899-exec-8]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/get/1330879440221315072(String), [1330879440221315072](String), 1(Integer), null, GET(String), 81(Long), {"code":20000,"data":{"blogCollection":0,"blogComment":0,"blogContent":"<h3>一面</h3>\n<p>一面面试老师是个小姑娘，人特别好（不仅仅指长相啊）。</p>\n<p>问了mysql的索引</p>\n<p>Redis的string类型</p>\n<p>为什么使用rabbitmq</p>\n<p>rabbitmq有哪些部件，如何保证准确性跟一致性。</p>\n<p>算法问了两道</p>\n<p>快排</p>\n<p>无序数组计算每个位置大于前面的多少个数字（归并排序）</p>\n<h3><a name=\"t1\"></a><a name=\"t1\"></a>二面</h3>\n<p>二面就开始偏向项目了，</p>\n<p>如何进行jvm调优（然后我巴拉巴拉，老师说你写下具体的参数跟请求命令）</p>\n<p>cpu满了重启系统后好了，但是一会又满了，如何具体解决。（老师有点严格，一直说我不要听原理，你给我说具体的命令）</p>\n<p>然后问了如何设置秒杀系统</p>\n<p>如何设置银行系统，会碰到什么问题</p>\n<p>为什么项目中使用了mongodb</p>\n<p>同样两个算法</p>\n<p>一个文本距离计算</p>\n<p>（用动态规划解决）</p>\n<p>一个是无序数组可以存储多少雨水问题</p>\n<p>&nbsp;</p>\n<h3><a name=\"t2\"></a><a name=\"t2\"></a>三面</h3>\n<p>没有问技术</p>\n<p>就是聊了聊怎么学习的</p>\n<p>看了那些书</p>\n<p>如何设置一个抢红包的功能</p>\n<p>以及自己项目中碰到了哪些问题，如何解决的</p>\n<p>项目的技术选型以及为什么要选择它</p>\n<p>然后最手写一个算法</p>\n<p>实现对hashmap增强，加上过期自动删除还有淘汰策略实现最短过期时间删除</p>\n<h3><a name=\"t3\"></a><a name=\"t3\"></a>HR面</h3>\n<p>技术规划</p>\n<p>还投了哪些公司</p>\n<p>字节了解</p>\n<p>为什么考研</p>\n<p>项目中最大的收获</p>\n<blockquote>\n<p>获取Java学习笔记，面试文档，电子书PDF，面经资料，面试题目解析：加我&ldquo;VX小助理&rdquo;即可免费获取到</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20201119150314177.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ExNTkzNTc0NDU1NjY=,size_16,color_FFFFFF,t_70\" alt=\"\" /></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20201113164315865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ExNTkzNTc0NDU1NjY=,size_16,color_FFFFFF,t_70\" alt=\"\" width=\"851\" height=\"401\" /></p>\n</blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/2020111316432769.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ExNTkzNTc0NDU1NjY=,size_16,color_FFFFFF,t_70\" alt=\"\" width=\"593\" height=\"506\" /></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20201113164343666.png\" alt=\"\" width=\"482\" height=\"198\" /></p>\n<h1><a name=\"t4\"></a><a name=\"t4\"></a>Java基础</h1>\n<ul>\n<li>JAVA 中的几种数据类型是什么，各自占用多少字节。</li>\n<li>String 类能被继承吗，为什么。</li>\n<li>两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？</li>\n<li>String 属于基础的数据类型吗？</li>\n<li>Java 中操作字符串都有哪些类？它们之间有什么区别？</li>\n<li>Java 中 IO 流分为几种？</li>\n<li>BIO、NIO、AIO 有什么区别？</li>\n<li>用过哪些 Map 类，都有什么区别，HashMap 时线程安全的吗，并发下使用的 Map 是什么，他们的内部原理分别是什么，比如存储方法，hashcode，扩容，默认容量等。</li>\n<li>如何将字符串反转？</li>\n<li>抽象类必须要有抽象方法吗？</li>\n<li>普通类和抽象类有哪些区别？</li>\n<li>抽象类能使用 final 修饰吗？</li>\n<li>ArrayList 和 LinkedList 有什么区别？</li>\n<li>ConcurrentHashMap的数据结构（必考）</li>\n<li>volatile作用（必考）</li>\n<li>Atomic类如何保证原子性（CAS操作）（必考）</li>\n<li>为什么要使用线程池（必考）</li>\n</ul>\n<p>&nbsp;</p>\n<h1><a name=\"t5\"></a><a name=\"t5\"></a>Redis</h1>\n<ul>\n<li>Redis的应用场景</li>\n<li>Redis支持的数据类型（必考）</li>\n<li>zset跳表的数据结构（必考）</li>\n<li>Redis的数据过期策略（必考）</li>\n<li>Redis的LRU过期策略的具体实现</li>\n<li>如何解决Redis缓存雪崩，缓存穿透问题</li>\n<li>Redis的持久化机制（必考）</li>\n<li>Redis为什么是单线程的？</li>\n<li>什么是缓存穿透？怎么解决？</li>\n<li>Redis持久化有几种方式？</li>\n<li>Redis为什么这么快？（必考）</li>\n<li>Redis怎么实现分布式锁？</li>\n<li>Redis如何做内存优化？</li>\n<li>Redis淘汰策略有哪些？</li>\n<li>Redis常见的性能问题有哪些？该如何解决？</li>\n<li>Redis的使用要注意什么？</li>\n</ul>\n<h1><a name=\"t6\"></a><a name=\"t6\"></a>ZooKeeper</h1>\n<ul>\n<li>CAP定理</li>\n<li>ZAB协议</li>\n<li>leader选举<a href=\"https://blog.csdn.net/jump/super-jump/word?word=%E7%AE%97%E6%B3%95\">算法</a>和流程</li>\n<li>zoo<a href=\"https://blog.csdn.net/jump/super-jump/word?word=keep\">keep</a>er 是什么？</li>\n<li>zoo<a href=\"https://blog.csdn.net/jump/super-jump/word?word=keep\">keep</a>er 有几种部署模式？</li>\n<li>zoo<a href=\"https://blog.csdn.net/jump/super-jump/word?word=keep\">keep</a>er 怎么保证主从节点的状态同步？</li>\n</ul>\n<h1><a name=\"t7\"></a><a name=\"t7\"></a>Mysql</h1>\n<ul>\n<li>事务的基本要素</li>\n<li>事务隔离级别（必考）</li>\n<li>如何解决事务的并发问题(脏读，幻读)（必考）</li>\n<li>MVCC多版本并发控制（必考）</li>\n<li>binlog,redolog,undolog都是什么，起什么作用</li>\n<li>InnoDB的行锁/表锁</li>\n<li>myisam和innodb的区别，什么时候选择myisam</li>\n<li>为什么选择B+树作为索引结构（必考）</li>\n<li>索引B+树的叶子节点都可以存哪些东西（必考）</li>\n<li>查询在什么时候不走（预期中的）索引（必考）</li>\n<li>sql如何优化</li>\n<li>explain是如何解析sql的</li>\n<li>order by原理</li>\n</ul>\n<h1><a name=\"t8\"></a><a name=\"t8\"></a>JVM</h1>\n<ul>\n<li>运行时数据区域（内存模型）（必考）</li>\n<li>垃圾回收机制（必考）</li>\n<li>垃圾回收<a href=\"https://blog.csdn.net/jump/super-jump/word?word=%E7%AE%97%E6%B3%95\">算法</a>（必考）</li>\n<li>Minor GC和Full GC触发条件</li>\n<li>GC中Stop the world（STW）</li>\n<li>各垃圾回收器的特点及区别</li>\n<li>双亲委派模型</li>\n<li>JDBC和双亲委派模型关系</li>\n<li>JVM 中一次完整的 GC 流程是什么样子的，对象如何晋升到老年代，说说你知道的几种主要的 JVM 参数</li>\n</ul>\n<h1><a name=\"t9\"></a><a name=\"t9\"></a>Spring</h1>\n<ul>\n<li>Spring的IOC/AOP的实现（必考）</li>\n<li>动态代理的实现方式（必考）</li>\n<li>Spring如何解决循环依赖（三级缓存）（必考）</li>\n<li>Spring的后置处理器</li>\n<li>Spring的@Transactional如何实现的（必考）</li>\n<li>Spring的事务传播级别</li>\n<li>BeanFactory和ApplicationContext的联系和区别</li>\n</ul>\n<h1><a name=\"t10\"></a><a name=\"t10\"></a>其他</h1>\n<ul>\n<li>高并发系统的限流如何实现</li>\n<li>高并发秒杀系统的设计</li>\n<li>负载均衡如何设计</li>\n</ul>\n<h1><a name=\"t11\"></a><a name=\"t11\"></a>操作系统篇</h1>\n<ul>\n<li>进程和线程的区别</li>\n<li>进程同步的几种方式</li>\n<li>线程间同步的方式</li>\n<li>什么是缓冲区溢出。有什么危害，其原因是什么</li>\n<li>进程中有哪几种状态</li>\n<li>分页和分段有什么区别</li>\n</ul>\n<h1><a name=\"t12\"></a><a name=\"t12\"></a>多线程篇</h1>\n<ul>\n<li>多线程的几种实现方式，什么是线程安全</li>\n<li>volatile 的原理，作用，能代替锁吗?</li>\n<li>sleep 和 wait 的区别</li>\n<li>sleep(0)的意义</li>\n<li>Lock 和 Synchronized 的区别</li>\n<li>synchronized 的原理是什么，一般用在什么地方（比如加载静态方法和非静态方法的区别）</li>\n</ul>\n<p>获取Java学习笔记，面试文档，电子书PDF，面经资料，面试题目解析：加我&ldquo;VX小助理&rdquo;即可免费获取到</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20201119150314177.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ExNTkzNTc0NDU1NjY=,size_16,color_FFFFFF,t_70\" alt=\"\" /></p>\n<h1><a name=\"t13\"></a><a name=\"t13\"></a>补充</h1>\n<p>另外还会考一些计算机网络之类的。像消息队列，RPC框架这种考的比较少。计算机网络就是分层啊，tcp/udp啊，三次握手之类的。操作系统就是进程与线程啊，进程的数据结构以及如何通信之类的。</p>\n<p>数据结构的排序算法也比较常考，考的话一定会让你手写个快排。剩下的算法题就靠LeetCode的积累了。其实非算法岗考的算法题都蛮简单的，很多题完全就是考察你智力是否正常，稍微难点的涉及到一些算法思想的按照LeetCode题目类型的分类，每种题做一两道基本就能完全应付面试了。</p>","blogGoods":0,"blogId":"1330879440221315072","blogRead":0,"blogRemark":"面试必备","blogTitle":"Java岗四面字节跳动成功之前，我都刷了那些面试题以及做了那些准备！","blogType":1,"createdTime":1606112559000,"version":1},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:46:34.820 DEBUG [http-nio-8899-exec-8]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:46:41.768 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==>  Preparing: select blog_id, blog_title, blog_content, blog_goods, blog_image, blog_read, blog_collection, blog_type, blog_remark, blog_comment, blog_source, created_time, version from bl_blog where blog_id = ? and deleted = 0 
2020-12-24 23:46:41.769 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==> Parameters: 1324038097171820544(String)
2020-12-24 23:46:41.805 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -<==      Total: 1
2020-12-24 23:46:41.850 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:46:41.852 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/get/1324038097171820544(String), [1324038097171820544](String), 1(Integer), null, GET(String), 81(Long), {"code":20000,"data":{"blogCollection":0,"blogComment":0,"blogContent":"BeanUtils.copyProperties(a, b);b中的存在的属性，a中一定要有，但是a中可以有多余的属性；a中与b中相同的属性都会被替换，不管是否有值；a、 b中的属性要名字相同，才能被赋值，不然的话需要手动赋值；Spring的BeanUtils的CopyProperties方法需要对应的属性有getter和setter方法；如果存在属性完全相同的内部类，但是不是同一个内部类，即分别属于各自的内部类，则spring会认为属性不同，不会copy；spring和apache的copy属性的方法源和目的参数的位置正好相反，所以导包和调用的时候都要注意一下。","blogGoods":0,"blogId":"1324038097171820544","blogImage":"Java","blogRead":0,"blogRemark":"BeanUtils它提供了对java反射和自省API的包装。它里面还有很多工具类，这里我们介绍一下copyProperties。","blogSource":"百度","blogTitle":"BeanUtils.copyProperties的用法","blogType":1,"createdTime":1604481453000,"version":2},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:46:41.950 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:46:42.970 DEBUG [http-nio-8899-exec-10]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==>  Preparing: select blog_id, blog_title, blog_content, blog_goods, blog_image, blog_read, blog_collection, blog_type, blog_remark, blog_comment, blog_source, created_time, version from bl_blog where blog_id = ? and deleted = 0 
2020-12-24 23:46:42.971 DEBUG [http-nio-8899-exec-10]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==> Parameters: 1330877080455553024(String)
2020-12-24 23:46:43.041 DEBUG [http-nio-8899-exec-10]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -<==      Total: 1
2020-12-24 23:46:43.091 DEBUG [http-nio-8899-exec-10]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:46:43.093 DEBUG [http-nio-8899-exec-10]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/get/1330877080455553024(String), [1330877080455553024](String), 1(Integer), null, GET(String), 113(Long), {"code":20000,"data":{"blogCollection":0,"blogComment":0,"blogContent":"<h2>前言</h2>\n<p>我负责的有几个系统随着业务量的增长，存储在MySQL中的数据日益剧增，我当时就想现在的业务方不讲武德，搞偷袭，趁我没反应过来把很多表，很快，很快啊都打到了亿级别，我大意了，没有闪，这就导致跟其Join的表的SQL变得很慢，对的应用接口的response time也变长了，影响了用户体验。</p>\n<p>事后我找到业务方，我批评了他们跟他们说要讲武德，连忙跟我道歉，这个事情才就此作罢，走的时候我对他们说下次不要这样了，耗子尾汁，好好反思。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/3c93aececcb9e763f5476362c4e88710.png\" alt=\"\" /></p>\n<p>骂归骂，事情还是得解决，时候我分析原因发现，发现有些表的数据量增长很快，对应SQL扫描了很多无效数据，导致SQL慢了下来，通过确认之后，这些大表都是一些流水、记录、日志类型数据，只需要保留1到3个月，此时需要对表做数据清理实现瘦身，一般都会想到用insert + delete的方式去清理。</p>\n<p>这篇文章我会从InnoDB存储空间分布，delete对性能的影响，以及优化建议方面解释为什么不建议delete删除数据。</p>\n<h2><a name=\"t1\"></a><a name=\"t1\"></a><a id=\"InnoDB_16\"></a>InnoDB存储架构</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/5c66ffe9749c58e1613d2519f7ea7211.png\" alt=\"\" /></p>\n<p>从这张图可以看到，InnoDB存储结构主要包括两部分：逻辑存储结构和物理存储结构。</p>\n<p>逻辑上是由表空间tablespace &mdash;&gt; 段segment或者inode &mdash;&gt; 区Extent &mdash;&mdash;&gt;数据页Page构成，Innodb逻辑管理单位是segment，空间分配的最小单位是extent，每个segment都会从表空间FREE_PAGE中分配32个page，当这32个page不够用时，会按照以下原则进行扩展：如果当前小于1个extent，则扩展到1个extent；当表空间小于32MB时，每次扩展一个extent；表空间大于32MB，每次扩展4个extent。</p>\n<p>物理上主要由系统用户数据文件，日志文件组成，数据文件主要存储MySQL字典数据和用户数据，日志文件记录的是data page的变更记录，用于MySQL Crash时的恢复。</p>\n<h2><a name=\"t2\"></a><a name=\"t2\"></a><a id=\"Innodb_26\"></a>Innodb表空间</h2>\n<p>InnoDB存储包括三类表空间：系统表空间，用户表空间，Undo表空间。</p>\n<p><strong>系统表空间：</strong>&nbsp;主要存储MySQL内部的数据字典数据，如information_schema下的数据。</p>\n<p><strong>用户表空间：</strong>&nbsp;当开启innodb_file_per_table=1时，数据表从系统表空间独立出来存储在以table_name.ibd命令的数据文件中，结构信息存储在table_name.frm文件中。</p>\n<p><strong>Undo表空间：</strong>&nbsp;存储Undo信息，如快照一致读和flashback都是利用undo信息。</p>\n<p>从MySQL 8.0开始允许用户自定义表空间，具体语法如下：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">CREATE TABLESPACE tablespace_name\n    ADD DATAFILE 'file_name'               #数据文件名\n    USE LOGFILE GROUP logfile_group        #自定义日志文件组，一般每组2个logfile。\n    [EXTENT_SIZE [=] extent_size]          #区大小\n    [INITIAL_SIZE [=] initial_size]        #初始化大小 \n    [AUTOEXTEND_SIZE [=] autoextend_size]  #自动扩宽尺寸\n    [MAX_SIZE [=] max_size]                #单个文件最大size，最大是32G。\n    [NODEGROUP [=] nodegroup_id]           #节点组\n    [WAIT]\n    [COMMENT [=] comment_text]\n    ENGINE [=] engine_name\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n</ul>\n<p>这样的好处是可以做到数据的冷热分离，分别用HDD和SSD来存储，既能实现数据的高效访问，又能节约成本，比如可以添加两块500G硬盘，经过创建卷组vg，划分逻辑卷lv，创建数据目录并mount相应的lv，假设划分的两个目录分别是/hot_data 和 /cold_data。</p>\n<p>这样就可以将核心的业务表如用户表，订单表存储在高性能SSD盘上，一些日志，流水表存储在普通的HDD上，主要的操作步骤如下：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#创建热数据表空间\ncreate tablespace tbs_data_hot add datafile '/hot_data/tbs_data_hot01.dbf' max_size 20G;\n#创建核心业务表存储在热数据表空间\ncreate table booking(id bigint not null primary key auto_increment, &hellip;&hellip; ) tablespace tbs_data_hot;\n#创建冷数据表空间\ncreate tablespace tbs_data_cold add datafile '/hot_data/tbs_data_cold01.dbf' max_size 20G;\n#创建日志，流水，备份类的表存储在冷数据表空间\ncreate table payment_log(id bigint not null primary key auto_increment, &hellip;&hellip; ) tablespace tbs_data_cold;\n#可以移动表到另一个表空间\nalter table payment_log tablespace tbs_data_hot;\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n</ul>\n<h2><a name=\"t3\"></a><a name=\"t3\"></a><a id=\"Inndob_69\"></a>Inndob存储分布</h2>\n<h3><a name=\"t4\"></a><a name=\"t4\"></a><a id=\"_71\"></a>创建空表查看空间变化</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; create table user(id bigint not null primary key auto_increment, \n    -&gt; name varchar(20) not null default '' comment '姓名', \n    -&gt; age tinyint not null default 0 comment 'age', \n    -&gt; gender char(1) not null default 'M'  comment '性别',\n    -&gt; phone varchar(16) not null default '' comment '手机号',\n    -&gt; create_time datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n    -&gt; update_time datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间'\n    -&gt; ) engine = InnoDB DEFAULT CHARSET=utf8mb4 COMMENT '用户信息表';\nQuery OK, 0 rows affected (0.26 sec)\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n</ul>\n<pre class=\"prettyprint\"><code class=\"prism language-bash has-numbering\"><span class=\"token comment\"># ls -lh user1.ibd </span>\n-rw-r----- 1 mysql mysql 96K Nov  6 12:48 user.ibd\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n</ul>\n<p>设置参数innodb_file_per_table=1时，创建表时会自动创建一个segment，同时分配一个extent，包含32个data page的来存储数据，这样创建的空表默认大小就是96KB，extent使用完之后会申请64个连接页，这样对于一些小表，或者undo segment，可以在开始时申请较少的空间，节省磁盘容量的开销。</p>\n<pre class=\"prettyprint\"><code class=\"prism language-shell has-numbering\"><span class=\"token comment\"># python2 py_innodb_page_info.py -v /data2/mysql/test/user.ibd</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>File Space Header<span class=\"token operator\">&gt;</span>\npage offset 00000001, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Insert Buffer Bitmap<span class=\"token operator\">&gt;</span>\npage offset 00000002, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>File Segment inode<span class=\"token operator\">&gt;</span>\npage offset 00000003, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>B-tree Node<span class=\"token operator\">&gt;</span>, page level <span class=\"token operator\">&lt;</span>0000<span class=\"token operator\">&gt;</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Freshly Allocated Page<span class=\"token operator\">&gt;</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Freshly Allocated Page<span class=\"token operator\">&gt;</span>\nTotal number of page: 6:      <span class=\"token comment\">#总共分配的页数</span>\nFreshly Allocated Page: 2     <span class=\"token comment\">#可用的数据页</span>\nInsert Buffer Bitmap: 1       <span class=\"token comment\">#插入缓冲页</span>\nFile Space Header: 1          <span class=\"token comment\">#文件空间头</span>\nB-tree Node: 1                <span class=\"token comment\">#数据页</span>\nFile Segment inode: 1         <span class=\"token comment\">#文件端inonde，如果是在ibdata1.ibd上会有多个inode。</span>\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n</ul>\n<h3><a name=\"t5\"></a><a name=\"t5\"></a><a id=\"_108\"></a>插入数据后的空间变化</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; DELIMITER $$\nmysql&gt; CREATE PROCEDURE insert_user_data(num INTEGER) \n    -&gt; BEGIN\n    -&gt;     DECLARE v_i int unsigned DEFAULT 0;\n    -&gt; set autocommit= 0;\n    -&gt; WHILE v_i &lt; num DO\n    -&gt;    insert into user(`name`, age, gender, phone) values (CONCAT('lyn',v_i), mod(v_i,120), 'M', CONCAT('152',ROUND(RAND(1)*100000000)));\n    -&gt;  SET v_i = v_i+1;\n    -&gt; END WHILE;\n    -&gt; commit;\n    -&gt; END $$\nQuery OK, 0 rows affected (0.01 sec)\nmysql&gt; DELIMITER ;\n\n#插入10w数据\nmysql&gt; call insert_user_data(100000);\nQuery OK, 0 rows affected (6.69 sec)\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n</ul>\n<pre class=\"prettyprint\"><code class=\"prism language-shell has-numbering\"><span class=\"token comment\"># ls -lh user.ibd</span>\n-rw-r----- 1 mysql mysql 14M Nov 6 10:58 /data2/mysql/test/user.ibd\n\n<span class=\"token comment\"># python2 py_innodb_page_info.py -v /data2/mysql/test/user.ibd</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>File Space Header<span class=\"token operator\">&gt;</span>\npage offset 00000001, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Insert Buffer Bitmap<span class=\"token operator\">&gt;</span>\npage offset 00000002, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>File Segment inode<span class=\"token operator\">&gt;</span>\npage offset 00000003, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>B-tree Node<span class=\"token operator\">&gt;</span>, page level <span class=\"token operator\">&lt;</span>0001<span class=\"token operator\">&gt;</span>   <span class=\"token comment\">#增加了一个非叶子节点，树的高度从1变为2.</span>\n<span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Freshly Allocated Page<span class=\"token operator\">&gt;</span>\nTotal number of page: 896:\nFreshly Allocated Page: 493\nInsert Buffer Bitmap: 1\nFile Space Header: 1\nB-tree Node: 400\nFile Segment inode: 1\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n</ul>\n<h3><a name=\"t6\"></a><a name=\"t6\"></a><a id=\"delete_149\"></a>delete数据后的空间变化</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; select min(id),max(id),count(*) from user;\n+---------+---------+----------+\n| min(id) | max(id) | count(*) |\n+---------+---------+----------+\n|       1 |  100000 |   100000 |\n+---------+---------+----------+\n1 row in set (0.05 sec)\n#删除50000条数据，理论上空间应该从14MB变长7MB左右。\nmysql&gt; delete from user limit 50000;\nQuery OK, 50000 rows affected (0.25 sec)\n\n#数据文件大小依然是14MB，没有缩小。\n# ls -lh /data2/mysql/test/user1.ibd \n-rw-r----- 1 mysql mysql 14M Nov  6 13:22 /data2/mysql/test/user.ibd\n\n#数据页没有被回收。\n# python2 py_innodb_page_info.py -v /data2/mysql/test/user.ibd\npage offset 00000000, page type &lt;File Space Header&gt;\npage offset 00000001, page type &lt;Insert Buffer Bitmap&gt;\npage offset 00000002, page type &lt;File Segment inode&gt;\npage offset 00000003, page type &lt;B-tree Node&gt;, page level &lt;0001&gt;\n........................................................\npage offset 00000000, page type &lt;Freshly Allocated Page&gt;\nTotal number of page: 896:\nFreshly Allocated Page: 493\nInsert Buffer Bitmap: 1\nFile Space Header: 1\nB-tree Node: 400\nFile Segment inode: 1\n#在MySQL内部是标记删除，\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n</ul>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; use information_schema;\n\nDatabase changed\nmysql&gt; SELECT A.SPACE AS TBL_SPACEID, A.TABLE_ID, A.NAME AS TABLE_NAME, FILE_FORMAT, ROW_FORMAT, SPACE_TYPE,  B.INDEX_ID , B.NAME AS INDEX_NAME, PAGE_NO, B.TYPE AS INDEX_TYPE FROM INNODB_SYS_TABLES A LEFT JOIN INNODB_SYS_INDEXES B ON A.TABLE_ID =B.TABLE_ID WHERE A.NAME = 'test/user1';\n+-------------+----------+------------+-------------+------------+------------+----------+------------+---------+------------+\n| TBL_SPACEID | TABLE_ID | TABLE_NAME | FILE_FORMAT | ROW_FORMAT | SPACE_TYPE | INDEX_ID | INDEX_NAME | PAGE_NO | INDEX_TYPE |\n+-------------+----------+------------+-------------+------------+------------+----------+------------+---------+------------+\n|        1283 |     1207 | test/user | Barracuda   | Dynamic    | Single     |     2236 | PRIMARY    |       3 |          3 |\n+-------------+----------+------------+-------------+------------+------------+----------+------------+---------+------------+\n1 row in set (0.01 sec)\n\nPAGE_NO = 3 标识B-tree的root page是3号页，INDEX_TYPE = 3是聚集索引。 INDEX_TYPE取值如下：\n0 = nonunique secondary index; \n1 = automatically generated clustered index (GEN_CLUST_INDEX); \n2 = unique nonclustered index; \n3 = clustered index; \n32 = full-text index;\n#收缩空间再后进行观察\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n</ul>\n<p>MySQL内部不会真正删除空间，而且做标记删除，即将delflag:N修改为delflag:Y，commit之后会会被purge进入删除链表，如果下一次insert更大的记录，delete之后的空间不会被重用，如果插入的记录小于等于delete的记录空会被重用，这块内容可以通过知数堂的innblock工具进行分析。</p>\n<h2><a name=\"t7\"></a><a name=\"t7\"></a><a id=\"Innodb_207\"></a>Innodb中的碎片</h2>\n<h3><a name=\"t8\"></a><a name=\"t8\"></a><a id=\"_209\"></a>碎片的产生</h3>\n<p>我们知道数据存储在文件系统上的，总是不能100%利用分配给它的物理空间，删除数据会在页面上留下一些&rdquo;空洞&rdquo;，或者随机写入（聚集索引非线性增加）会导致页分裂，页分裂导致页面的利用空间少于50%，另外对表进行增删改会引起对应的二级索引值的随机的增删改，也会导致索引结构中的数据页面上留下一些\"空洞\"，虽然这些空洞有可能会被重复利用，但终究会导致部分物理空间未被使用，也就是碎片。</p>\n<p>同时，即便是设置了填充因子为100%，Innodb也会主动留下page页面1/16的空间作为预留使用（An innodb_fill_factor setting of 100 leaves 1/16 of the space in clustered index pages free for future index growth）防止update带来的行溢出。</p>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; select table_schema,\n    -&gt;        table_name,ENGINE,\n    -&gt;        round(DATA_LENGTH/1024/1024+ INDEX_LENGTH/1024/1024) total_mb,TABLE_ROWS,\n    -&gt;        round(DATA_LENGTH/1024/1024) data_mb, round(INDEX_LENGTH/1024/1024) index_mb, round(DATA_FREE/1024/1024) free_mb, round(DATA_FREE/DATA_LENGTH*100,2) free_ratio\n    -&gt; from information_schema.TABLES where  TABLE_SCHEMA= 'test'\n    -&gt; and TABLE_NAME= 'user';\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n| table_schema | table_name | ENGINE | total_mb | TABLE_ROWS | data_mb | index_mb | free_mb | free_ratio |\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n| test         | user      | InnoDB |        4 |      50000 |       4 |        0 |       6 |     149.42 |\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n1 row in set (0.00 sec)\n\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n</ul>\n<p>其中data_free是分配了未使用的字节数，并不能说明完全是碎片空间。</p>\n<h3><a name=\"t9\"></a><a name=\"t9\"></a><a id=\"_233\"></a>碎片的回收</h3>\n<p>对于InnoDB的表，可以通过以下命令来回收碎片，释放空间，这个是随机读IO操作，会比较耗时，也会阻塞表上正常的DML运行，同时需要占用额外更多的磁盘空间，对于RDS来说，可能会导致磁盘空间瞬间爆满，实例瞬间被锁定，应用无法做DML操作，所以禁止在线上环境去执行。</p>\n<pre class=\"prettyprint\"><code class=\"prism language-shell has-numbering\"><span class=\"token comment\">#执行InnoDB的碎片回收</span>\nmysql<span class=\"token operator\">&gt;</span> alter table user engine<span class=\"token operator\">=</span>InnoDB<span class=\"token punctuation\">;</span>\nQuery OK, 0 rows affected <span class=\"token punctuation\">(</span>9.00 sec<span class=\"token punctuation\">)</span>\nRecords: 0  Duplicates: 0  Warnings: 0\n\n<span class=\"token comment\">##执行完之后，数据文件大小从14MB降低到10M。</span>\n<span class=\"token comment\"># ls -lh /data2/mysql/test/user1.ibd </span>\n-rw-r----- 1 mysql mysql 10M Nov 6 16:18 /data2/mysql/test/user.ibd\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n</ul>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; select table_schema,        table_name,ENGINE,        round(DATA_LENGTH/1024/1024+ INDEX_LENGTH/1024/1024) total_mb,TABLE_ROWS,        round(DATA_LENGTH/1024/1024) data_mb, round(INDEX_LENGTH/1024/1024) index_mb, round(DATA_FREE/1024/1024) free_mb, round(DATA_FREE/DATA_LENGTH*100,2) free_ratio from information_schema.TABLES where  TABLE_SCHEMA= 'test' and TABLE_NAME= 'user';\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n| table_schema | table_name | ENGINE | total_mb | TABLE_ROWS | data_mb | index_mb | free_mb | free_ratio |\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n| test         | user      | InnoDB |        5 |      50000 |       5 |        0 |       2 |      44.29 |\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n1 row in set (0.00 sec)\n\n\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n</ul>\n<h2><a name=\"t10\"></a><a name=\"t10\"></a><a id=\"deleteSQL_260\"></a>delete对SQL的影响</h2>\n<h3><a name=\"t11\"></a><a name=\"t11\"></a><a id=\"SQL_262\"></a>未删除前的SQL执行情况</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#插入100W数据\nmysql&gt; call insert_user_data(1000000);\nQuery OK, 0 rows affected (35.99 sec)\n\n#添加相关索引\nmysql&gt; alter table user add index idx_name(name), add index idx_phone(phone);\nQuery OK, 0 rows affected (6.00 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\n#表上索引统计信息\nmysql&gt; show index from user;\n+-------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+\n| Table | Non_unique | Key_name  | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |\n+-------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+\n| user  |          0 | PRIMARY   |            1 | id          | A         |      996757 |     NULL | NULL   |      | BTREE      |         |               |\n| user  |          1 | idx_name  |            1 | name        | A         |      996757 |     NULL | NULL   |      | BTREE      |         |               |\n| user  |          1 | idx_phone |            1 | phone       | A         |           2 |     NULL | NULL   |      | BTREE      |         |               |\n+-------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+\n3 rows in set (0.00 sec)\n\n#重置状态变量计数\nmysql&gt; flush status;\nQuery OK, 0 rows affected (0.00 sec)\n\n#执行SQL语句\nmysql&gt; select id, age ,phone from user where name like 'lyn12%';\n+--------+-----+-------------+\n| id     | age | phone       |\n+--------+-----+-------------+\n|    124 |   3 | 15240540354 |\n|   1231 |  30 | 15240540354 |\n|  12301 |  60 | 15240540354 |\n.............................\n| 129998 |  37 | 15240540354 |\n| 129999 |  38 | 15240540354 |\n| 130000 |  39 | 15240540354 |\n+--------+-----+-------------+\n11111 rows in set (0.03 sec)\n\nmysql&gt; explain select id, age ,phone from user where name like 'lyn12%';\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n| id | select_type | table | type  | possible_keys | key      | key_len | ref  | rows  | Extra                 |\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n|  1 | SIMPLE      | user  | range | idx_name      | idx_name | 82      | NULL | 22226 | Using index condition |\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n1 row in set (0.00 sec)\n\n#查看相关状态呢变量\nmysql&gt; select * from information_schema.session_status where variable_name in('Last_query_cost','Handler_read_next','Innodb_pages_read','Innodb_data_reads','Innodb_pages_read');\n+-------------------+----------------+\n| VARIABLE_NAME     | VARIABLE_VALUE |\n+-------------------+----------------+\n| HANDLER_READ_NEXT | 11111          |    #请求读的行数\n| INNODB_DATA_READS | 7868409        |    #数据物理读的总数\n| INNODB_PAGES_READ | 7855239        |    #逻辑读的总数\n| LAST_QUERY_COST   | 10.499000      |    #SQL语句的成本COST，主要包括IO_COST和CPU_COST。\n+-------------------+----------------+\n4 rows in set (0.00 sec)\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n<li>31</li>\n<li>32</li>\n<li>33</li>\n<li>34</li>\n<li>35</li>\n<li>36</li>\n<li>37</li>\n<li>38</li>\n<li>39</li>\n<li>40</li>\n<li>41</li>\n<li>42</li>\n<li>43</li>\n<li>44</li>\n<li>45</li>\n<li>46</li>\n<li>47</li>\n<li>48</li>\n<li>49</li>\n<li>50</li>\n<li>51</li>\n<li>52</li>\n<li>53</li>\n<li>54</li>\n<li>55</li>\n<li>56</li>\n<li>57</li>\n<li>58</li>\n</ul>\n<h3><a name=\"t12\"></a><a name=\"t12\"></a><a id=\"SQL_325\"></a>删除后的SQL执行情况</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#删除50w数据\nmysql&gt; delete from user limit 500000;\nQuery OK, 500000 rows affected (3.70 sec)\n\n#分析表统计信息\nmysql&gt; analyze table user;\n+-----------+---------+----------+----------+\n| Table     | Op      | Msg_type | Msg_text |\n+-----------+---------+----------+----------+\n| test.user | analyze | status   | OK       |\n+-----------+---------+----------+----------+\n1 row in set (0.01 sec)\n\n#重置状态变量计数\nmysql&gt; flush status;\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql&gt; select id, age ,phone from user where name like 'lyn12%';\nEmpty set (0.05 sec)\n\nmysql&gt; explain select id, age ,phone from user where name like 'lyn12%';\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n| id | select_type | table | type  | possible_keys | key      | key_len | ref  | rows  | Extra                 |\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n|  1 | SIMPLE      | user  | range | idx_name      | idx_name | 82      | NULL | 22226 | Using index condition |\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n1 row in set (0.00 sec)\n\nmysql&gt; select * from information_schema.session_status where variable_name in('Last_query_cost','Handler_read_next','Innodb_pages_read','Innodb_data_reads','Innodb_pages_read');\n+-------------------+----------------+\n| VARIABLE_NAME     | VARIABLE_VALUE |\n+-------------------+----------------+\n| HANDLER_READ_NEXT | 0              |\n| INNODB_DATA_READS | 7868409        |\n| INNODB_PAGES_READ | 7855239        |\n| LAST_QUERY_COST   | 10.499000      |\n+-------------------+----------------+\n4 rows in set (0.00 sec)\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n<li>31</li>\n<li>32</li>\n<li>33</li>\n<li>34</li>\n<li>35</li>\n<li>36</li>\n<li>37</li>\n<li>38</li>\n</ul>\n<h3><a name=\"t13\"></a><a name=\"t13\"></a><a id=\"_368\"></a>结果统计分析</h3>\n<div class=\"table-box\">\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>COST</th>\n<th>物理读次数</th>\n<th>逻辑读次数</th>\n<th>扫描行数</th>\n<th>返回行数</th>\n<th>执行时间</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>初始化插入100W</td>\n<td>10.499000</td>\n<td>7868409</td>\n<td>7855239</td>\n<td>22226</td>\n<td>11111</td>\n<td>30ms</td>\n</tr>\n<tr>\n<td>100W随机删除50W</td>\n<td>10.499000</td>\n<td>7868409</td>\n<td>7855239</td>\n<td>22226</td>\n<td>0</td>\n<td>50ms</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>这也说明对普通的大表，想要通过delete数据来对表进行瘦身是不现实的，所以在任何时候不要用delete去删除数据，应该使用优雅的标记删除。</p>\n<h2><a name=\"t14\"></a><a name=\"t14\"></a><a id=\"delete_377\"></a>delete优化建议</h2>\n<h3><a name=\"t15\"></a><a name=\"t15\"></a><a id=\"_379\"></a>控制业务账号权限</h3>\n<p>对于一个大的系统来说，需要根据业务特点去拆分子系统，每个子系统可以看做是一个service，例如美团APP，上面有很多服务，核心的服务有用户服务user-service，搜索服务search-service，商品product-service，位置服务location-service，价格服务price-service等。每个服务对应一个数据库，为该数据库创建单独账号，同时只授予DML权限且没有delete权限，同时禁止跨库访问。</p>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#创建用户数据库并授权\ncreate database mt_user charset utf8mb4;\ngrant USAGE, SELECT, INSERT, UPDATE ON mt_user.*  to 'w_user'@'%' identified by 't$W*g@gaHTGi123456';\nflush privileges;\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n</ul>\n<h3><a name=\"t16\"></a><a name=\"t16\"></a><a id=\"delete_390\"></a>delete改为标记删除</h3>\n<p>在MySQL数据库建模规范中有4个公共字段，基本上每个表必须有的，同时在create_time列要创建索引，有两方面的好处：</p>\n<ol>\n<li>一些查询业务场景都会有一个默认的时间段，比如7天或者一个月，都是通过create_time去过滤，走索引扫描更快。</li>\n<li>一些核心的业务表需要以T +1的方式抽取数据仓库中，比如每天晚上00:30抽取前一天的数据，都是通过create_time过滤的。</li>\n</ol>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">`id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键id',\n`is_deleted` tinyint(4) NOT NULL DEFAULT '0' COMMENT '是否逻辑删除：0：未删除，1：已删除',\n`create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n`update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间'\n\n#有了删除标记，业务接口的delete操作就可以转换为update\nupdate user set is_deleted = 1 where user_id = 1213;\n\n#查询的时候需要带上is_deleted过滤\nselect id, age ,phone from user where is_deleted = 0 and name like 'lyn12%';\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n</ul>\n<h2><a name=\"t17\"></a><a name=\"t17\"></a><a id=\"_410\"></a>数据归档方式</h2>\n<h3><a name=\"t18\"></a><a name=\"t18\"></a><a id=\"_412\"></a>通用数据归档方法</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#1. 创建归档表，一般在原表名后面添加_bak。\nCREATE TABLE `ota_order_bak` (\n  `id` bigint(11) NOT NULL AUTO_INCREMENT COMMENT '主键',\n  `order_id` varchar(255) DEFAULT NULL COMMENT '订单id',\n  `ota_id` varchar(255) DEFAULT NULL COMMENT 'ota',\n  `check_in_date` varchar(255) DEFAULT NULL COMMENT '入住日期',\n  `check_out_date` varchar(255) DEFAULT NULL COMMENT '离店日期',\n  `hotel_id` varchar(255) DEFAULT NULL COMMENT '酒店ID',\n  `guest_name` varchar(255) DEFAULT NULL COMMENT '顾客',\n  `purcharse_time` timestamp NULL DEFAULT NULL COMMENT '购买时间',\n  `create_time` datetime DEFAULT NULL,\n  `update_time` datetime DEFAULT NULL,\n  `create_user` varchar(255) DEFAULT NULL,\n  `update_user` varchar(255) DEFAULT NULL,\n  `status` int(4) DEFAULT '1' COMMENT '状态 ： 1 正常 ， 0 删除',\n  `hotel_name` varchar(255) DEFAULT NULL,\n  `price` decimal(10,0) DEFAULT NULL,\n  `remark` longtext,\n  PRIMARY KEY (`id`),\n  KEY `IDX_order_id` (`order_id`) USING BTREE,\n  KEY `hotel_name` (`hotel_name`) USING BTREE,\n  KEY `ota_id` (`ota_id`) USING BTREE,\n  KEY `IDX_purcharse_time` (`purcharse_time`) USING BTREE,\n  KEY `IDX_create_time` (`create_time`) USING BTREE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8\nPARTITION BY RANGE (to_days(create_time)) ( \nPARTITION p201808 VALUES LESS THAN (to_days('2018-09-01')), \nPARTITION p201809 VALUES LESS THAN (to_days('2018-10-01')), \nPARTITION p201810 VALUES LESS THAN (to_days('2018-11-01')), \nPARTITION p201811 VALUES LESS THAN (to_days('2018-12-01')), \nPARTITION p201812 VALUES LESS THAN (to_days('2019-01-01')), \nPARTITION p201901 VALUES LESS THAN (to_days('2019-02-01')), \nPARTITION p201902 VALUES LESS THAN (to_days('2019-03-01')), \nPARTITION p201903 VALUES LESS THAN (to_days('2019-04-01')), \nPARTITION p201904 VALUES LESS THAN (to_days('2019-05-01')), \nPARTITION p201905 VALUES LESS THAN (to_days('2019-06-01')), \nPARTITION p201906 VALUES LESS THAN (to_days('2019-07-01')), \nPARTITION p201907 VALUES LESS THAN (to_days('2019-08-01')), \nPARTITION p201908 VALUES LESS THAN (to_days('2019-09-01')), \nPARTITION p201909 VALUES LESS THAN (to_days('2019-10-01')), \nPARTITION p201910 VALUES LESS THAN (to_days('2019-11-01')), \nPARTITION p201911 VALUES LESS THAN (to_days('2019-12-01')), \nPARTITION p201912 VALUES LESS THAN (to_days('2020-01-01')));\n\n#2. 插入原表中无效的数据（需要跟开发同学确认数据保留范围）\ncreate table tbl_p201808 as select * from ota_order where create_time between '2018-08-01 00:00:00' and '2018-08-31 23:59:59';\n\n#3. 跟归档表分区做分区交换\nalter table ota_order_bak exchange partition p201808 with table tbl_p201808; \n\n#4. 删除原表中已经规范的数据\ndelete from ota_order where create_time between '2018-08-01 00:00:00' and '2018-08-31 23:59:59' limit 3000;\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n<li>31</li>\n<li>32</li>\n<li>33</li>\n<li>34</li>\n<li>35</li>\n<li>36</li>\n<li>37</li>\n<li>38</li>\n<li>39</li>\n<li>40</li>\n<li>41</li>\n<li>42</li>\n<li>43</li>\n<li>44</li>\n<li>45</li>\n<li>46</li>\n<li>47</li>\n<li>48</li>\n<li>49</li>\n<li>50</li>\n<li>51</li>\n<li>52</li>\n</ul>\n<h3><a name=\"t19\"></a><a name=\"t19\"></a><a id=\"_469\"></a>优化后的归档方式</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#1. 创建中间表\nCREATE TABLE `ota_order_2020` (........) ENGINE=InnoDB DEFAULT CHARSET=utf8\nPARTITION BY RANGE (to_days(create_time)) ( \nPARTITION p201808 VALUES LESS THAN (to_days('2018-09-01')), \nPARTITION p201809 VALUES LESS THAN (to_days('2018-10-01')), \nPARTITION p201810 VALUES LESS THAN (to_days('2018-11-01')), \nPARTITION p201811 VALUES LESS THAN (to_days('2018-12-01')), \nPARTITION p201812 VALUES LESS THAN (to_days('2019-01-01')), \nPARTITION p201901 VALUES LESS THAN (to_days('2019-02-01')), \nPARTITION p201902 VALUES LESS THAN (to_days('2019-03-01')), \nPARTITION p201903 VALUES LESS THAN (to_days('2019-04-01')), \nPARTITION p201904 VALUES LESS THAN (to_days('2019-05-01')), \nPARTITION p201905 VALUES LESS THAN (to_days('2019-06-01')), \nPARTITION p201906 VALUES LESS THAN (to_days('2019-07-01')), \nPARTITION p201907 VALUES LESS THAN (to_days('2019-08-01')), \nPARTITION p201908 VALUES LESS THAN (to_days('2019-09-01')), \nPARTITION p201909 VALUES LESS THAN (to_days('2019-10-01')), \nPARTITION p201910 VALUES LESS THAN (to_days('2019-11-01')), \nPARTITION p201911 VALUES LESS THAN (to_days('2019-12-01')), \nPARTITION p201912 VALUES LESS THAN (to_days('2020-01-01')));\n\n#2. 插入原表中有效的数据，如果数据量在100W左右可以在业务低峰期直接插入，如果比较大，建议采用dataX来做，可以控制频率和大小，之前我这边用Go封装了dataX可以实现自动生成json文件，自定义大小去执行。\ninsert into ota_order_2020 select * from ota_order where create_time between '2020-08-01 00:00:00' and '2020-08-31 23:59:59';\n\n#3. 表重命名\nalter table ota_order rename to ota_order_bak;  \nalter table ota_order_2020 rename to ota_order;\n#4. 插入差异数据\ninsert into ota_order select * from ota_order_bak a where not exists (select 1 from ota_order b where a.id = b.id);\n#5. ota_order_bak改造成分区表，如果表比较大不建议直接改造，可以先创建好分区表，通过dataX把导入进去即可。\n\n#6. 后续的归档方法\n#创建中间普遍表\ncreate table ota_order_mid like ota_order;\n#交换原表无效数据分区到普通表\nalter table ota_order exchange partition p201808 with table ota_order_mid; \n##交换普通表数据到归档表的相应分区\nalter table ota_order_bak exchange partition p201808 with table ota_order_mid; \n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n<li>31</li>\n<li>32</li>\n<li>33</li>\n<li>34</li>\n<li>35</li>\n<li>36</li>\n<li>37</li>\n<li>38</li>\n</ul>\n<p>这样原表和归档表都是按月的分区表，只需要创建一个中间普通表，在业务低峰期做两次分区交换，既可以删除无效数据，又能回收空，而且没有空间碎片，不会影响表上的索引及SQL的执行计划。</p>\n<h2><a name=\"t20\"></a><a name=\"t20\"></a><a id=\"_514\"></a>总结</h2>\n<p>通过从InnoDB存储空间分布，delete对性能的影响可以看到，delete物理删除既不能释放磁盘空间，而且会产生大量的碎片，导致索引频繁分裂，影响SQL执行计划的稳定性；</p>\n<p>同时在碎片回收时，会耗用大量的CPU，磁盘空间，影响表上正常的DML操作。</p>\n<p>在业务代码层面，应该做逻辑标记删除，避免物理删除；为了实现数据归档需求，可以用采用MySQL分区表特性来实现，都是DDL操作，没有碎片产生。</p>\n<p>另外一个比较好的方案采用Clickhouse，对有生命周期的数据表可以使用Clickhouse存储，利用其TTL特性实现无效数据自动清理。</p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1330877080455553024","blogRead":0,"blogRemark":"MySQL","blogTitle":"面试官不讲武德问我：为什么MySQL不建议使用delete删除数据？","blogType":1,"createdTime":1606111996000,"version":3},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:46:43.333 DEBUG [http-nio-8899-exec-10]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:47:46.215 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:47:46.216 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /BlAdmin/info(String), [](String), 1(Integer), null, GET(String), 2(Long), {"code":20000,"data":{"name":"田起凯","password":"","signature":"hold on","username":"admin"},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:47:46.298 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:47:46.589 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlTypeMapper.selectByExample.debug:159 -==>  Preparing: SELECT type_id,type_name,type_blog_count,enable,deleted FROM bl_type WHERE ( enable = ? and deleted = ? ) 
2020-12-24 23:47:46.590 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlTypeMapper.selectByExample.debug:159 -==> Parameters: 1(Integer), 0(Integer)
2020-12-24 23:47:46.626 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlTypeMapper.selectByExample.debug:159 -<==      Total: 7
2020-12-24 23:47:46.663 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:47:46.664 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /type/getList(String), [](String), 1(Integer), null, GET(String), 79(Long), {"code":20000,"data":[{"deleted":0,"enable":1,"typeBlogCount":105,"typeId":1,"typeName":"Java"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"Python"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":6,"typeName":"going"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":7,"typeName":"Spring"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"nginx"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Redis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":10,"typeName":"Docker"}],"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:47:46.741 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:47:46.923 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -==>  Preparing: select blog_id, blog_title, blog_image, blog_goods, blog_read, blog_collection, blog_remark, blog_comment, blog_source, created_time, update_time,type_name from bl_blog as b inner join bl_type as t on type_id = blog_type where t.deleted = 0 and b.deleted = 0 limit ?, ? 
2020-12-24 23:47:46.925 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -==> Parameters: 0(Integer), 10(Integer)
2020-12-24 23:47:46.983 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -<==      Total: 3
2020-12-24 23:47:46.984 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -==>  Preparing: select count(*) from bl_blog as b inner join bl_type as t on type_id = blog_type where t.deleted = 0 and b.deleted = 0 
2020-12-24 23:47:46.985 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -==> Parameters: 
2020-12-24 23:47:47.023 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -<==      Total: 1
2020-12-24 23:47:47.455 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:47:47.456 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/getByPage(String), [Page(currentPage=1, pageSize=10, totalPage=0, totalCount=0, list=[], params={}, sortColumn=null, sortMethod=asc)](String), 1(Integer), null, POST(String), 565(Long), {"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1324038097171820544","blogImage":"Java","blogRead":0,"blogRemark":"BeanUtils它提供了对java反射和自省API的包装。它里面还有很多工具类，这里我们介绍一下copyProperties。","blogSource":"百度","blogTitle":"BeanUtils.copyProperties的用法","createdTime":"2020-11-04 17:17:33","typeName":"Java","updateTime":"2020-11-22 13:04:15"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1330877080455553024","blogRead":0,"blogRemark":"MySQL","blogTitle":"面试官不讲武德问我：为什么MySQL不建议使用delete删除数据？","createdTime":"2020-11-23 14:13:16","typeName":"Java","updateTime":"2020-11-23 14:23:06"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1330879440221315072","blogRead":0,"blogRemark":"面试必备","blogTitle":"Java岗四面字节跳动成功之前，我都刷了那些面试题以及做了那些准备！","createdTime":"2020-11-23 14:22:39","typeName":"Java","updateTime":"2020-11-23 14:22:39"}],"pageSize":10,"params":{},"sortMethod":"asc","totalCount":3,"totalPage":1},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:47:47.636 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:47:49.566 DEBUG [http-nio-8899-exec-4]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==>  Preparing: select blog_id, blog_title, blog_content, blog_goods, blog_image, blog_read, blog_collection, blog_type, blog_remark, blog_comment, blog_source, created_time, version from bl_blog where blog_id = ? and deleted = 0 
2020-12-24 23:47:49.566 DEBUG [http-nio-8899-exec-4]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==> Parameters: 1324038097171820544(String)
2020-12-24 23:47:49.602 DEBUG [http-nio-8899-exec-4]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -<==      Total: 1
2020-12-24 23:47:49.644 DEBUG [http-nio-8899-exec-4]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:47:49.645 DEBUG [http-nio-8899-exec-4]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/get/1324038097171820544(String), [1324038097171820544](String), 1(Integer), null, GET(String), 86(Long), {"code":20000,"data":{"blogCollection":0,"blogComment":0,"blogContent":"BeanUtils.copyProperties(a, b);b中的存在的属性，a中一定要有，但是a中可以有多余的属性；a中与b中相同的属性都会被替换，不管是否有值；a、 b中的属性要名字相同，才能被赋值，不然的话需要手动赋值；Spring的BeanUtils的CopyProperties方法需要对应的属性有getter和setter方法；如果存在属性完全相同的内部类，但是不是同一个内部类，即分别属于各自的内部类，则spring会认为属性不同，不会copy；spring和apache的copy属性的方法源和目的参数的位置正好相反，所以导包和调用的时候都要注意一下。","blogGoods":0,"blogId":"1324038097171820544","blogImage":"Java","blogRead":0,"blogRemark":"BeanUtils它提供了对java反射和自省API的包装。它里面还有很多工具类，这里我们介绍一下copyProperties。","blogSource":"百度","blogTitle":"BeanUtils.copyProperties的用法","blogType":1,"createdTime":1604481453000,"version":2},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:47:49.729 DEBUG [http-nio-8899-exec-4]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:47:54.843 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==>  Preparing: select blog_id, blog_title, blog_content, blog_goods, blog_image, blog_read, blog_collection, blog_type, blog_remark, blog_comment, blog_source, created_time, version from bl_blog where blog_id = ? and deleted = 0 
2020-12-24 23:47:54.843 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==> Parameters: 1324038097171820544(String)
2020-12-24 23:47:54.881 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -<==      Total: 1
2020-12-24 23:47:54.921 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:47:54.922 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/get/1324038097171820544(String), [1324038097171820544](String), 1(Integer), null, GET(String), 77(Long), {"code":20000,"data":{"blogCollection":0,"blogComment":0,"blogContent":"BeanUtils.copyProperties(a, b);b中的存在的属性，a中一定要有，但是a中可以有多余的属性；a中与b中相同的属性都会被替换，不管是否有值；a、 b中的属性要名字相同，才能被赋值，不然的话需要手动赋值；Spring的BeanUtils的CopyProperties方法需要对应的属性有getter和setter方法；如果存在属性完全相同的内部类，但是不是同一个内部类，即分别属于各自的内部类，则spring会认为属性不同，不会copy；spring和apache的copy属性的方法源和目的参数的位置正好相反，所以导包和调用的时候都要注意一下。","blogGoods":0,"blogId":"1324038097171820544","blogImage":"Java","blogRead":0,"blogRemark":"BeanUtils它提供了对java反射和自省API的包装。它里面还有很多工具类，这里我们介绍一下copyProperties。","blogSource":"百度","blogTitle":"BeanUtils.copyProperties的用法","blogType":1,"createdTime":1604481453000,"version":2},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:47:55.003 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:48:05.290 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlBlogMapper.save.debug:159 -==>  Preparing: insert into bl_blog( blog_id, blog_title,blog_image, blog_content, blog_type, blog_remark, blog_source ) values ( ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:48:05.291 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlBlogMapper.save.debug:159 -==> Parameters: 1342134962123595776(String), (String), null, null, null, null, null
2020-12-24 23:48:05.568 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:48:05.570 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/save(String), [com.tqk.blog.pojo.BlBlog@46cfb413](String), 0(Integer), org.springframework.dao.DataIntegrityViolationException: 
### Error updating database.  Cause: java.sql.SQLIntegrityConstraintViolationException: Column 'blog_content' cannot be null
### The error may involve com.tqk.blog.mapper.BlBlogMapper.save-Inline
### Cause: java.sql.SQLIntegrityConstraintViolationException: Column 'blog_content' cannot be null
; Column 'blog_content' cannot be null; nested exception is java.sql.SQLIntegrityConstraintViolationException: Column 'blog_content' cannot be null
	at com.tqk.blog.service.impl.BlogServiceImpl.save(BlogServiceImpl.java:52)
	at com.tqk.blog.service.impl.BlogServiceImpl$$FastClassBySpringCGLIB$$c89e2edd.invoke(<generated>)
	at com.tqk.blog.service.impl.BlogServiceImpl$$EnhancerBySpringCGLIB$$e40d0c11.save(<generated>)
	at com.tqk.blog.service.impl.BlogServiceImpl$$FastClassBySpringCGLIB$$c89e2edd.invoke(<generated>)
	at com.tqk.blog.service.impl.BlogServiceImpl$$EnhancerBySpringCGLIB$$7c340e8d.save(<generated>)
	at com.tqk.blog.controller.BlogController.save(BlogController.java:39)
	at com.tqk.blog.controller.BlogController$$FastClassBySpringCGLIB$$a4fc5e31.invoke(<generated>)
	at com.tqk.blog.aspect.RequestAspect.doAround(RequestAspect.java:65)
	at com.tqk.blog.controller.BlogController$$EnhancerBySpringCGLIB$$7e46265a.save(<generated>)
Caused by: java.sql.SQLIntegrityConstraintViolationException: Column 'blog_content' cannot be null
(String), POST(String), 0(Long), {"code":20000,"data":{"blogCollection":0,"blogComment":0,"blogContent":"<h2>前言</h2>\n<p>我负责的有几个系统随着业务量的增长，存储在MySQL中的数据日益剧增，我当时就想现在的业务方不讲武德，搞偷袭，趁我没反应过来把很多表，很快，很快啊都打到了亿级别，我大意了，没有闪，这就导致跟其Join的表的SQL变得很慢，对的应用接口的response time也变长了，影响了用户体验。</p>\n<p>事后我找到业务方，我批评了他们跟他们说要讲武德，连忙跟我道歉，这个事情才就此作罢，走的时候我对他们说下次不要这样了，耗子尾汁，好好反思。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/3c93aececcb9e763f5476362c4e88710.png\" alt=\"\" /></p>\n<p>骂归骂，事情还是得解决，时候我分析原因发现，发现有些表的数据量增长很快，对应SQL扫描了很多无效数据，导致SQL慢了下来，通过确认之后，这些大表都是一些流水、记录、日志类型数据，只需要保留1到3个月，此时需要对表做数据清理实现瘦身，一般都会想到用insert + delete的方式去清理。</p>\n<p>这篇文章我会从InnoDB存储空间分布，delete对性能的影响，以及优化建议方面解释为什么不建议delete删除数据。</p>\n<h2><a name=\"t1\"></a><a name=\"t1\"></a><a id=\"InnoDB_16\"></a>InnoDB存储架构</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/5c66ffe9749c58e1613d2519f7ea7211.png\" alt=\"\" /></p>\n<p>从这张图可以看到，InnoDB存储结构主要包括两部分：逻辑存储结构和物理存储结构。</p>\n<p>逻辑上是由表空间tablespace &mdash;&gt; 段segment或者inode &mdash;&gt; 区Extent &mdash;&mdash;&gt;数据页Page构成，Innodb逻辑管理单位是segment，空间分配的最小单位是extent，每个segment都会从表空间FREE_PAGE中分配32个page，当这32个page不够用时，会按照以下原则进行扩展：如果当前小于1个extent，则扩展到1个extent；当表空间小于32MB时，每次扩展一个extent；表空间大于32MB，每次扩展4个extent。</p>\n<p>物理上主要由系统用户数据文件，日志文件组成，数据文件主要存储MySQL字典数据和用户数据，日志文件记录的是data page的变更记录，用于MySQL Crash时的恢复。</p>\n<h2><a name=\"t2\"></a><a name=\"t2\"></a><a id=\"Innodb_26\"></a>Innodb表空间</h2>\n<p>InnoDB存储包括三类表空间：系统表空间，用户表空间，Undo表空间。</p>\n<p><strong>系统表空间：</strong>&nbsp;主要存储MySQL内部的数据字典数据，如information_schema下的数据。</p>\n<p><strong>用户表空间：</strong>&nbsp;当开启innodb_file_per_table=1时，数据表从系统表空间独立出来存储在以table_name.ibd命令的数据文件中，结构信息存储在table_name.frm文件中。</p>\n<p><strong>Undo表空间：</strong>&nbsp;存储Undo信息，如快照一致读和flashback都是利用undo信息。</p>\n<p>从MySQL 8.0开始允许用户自定义表空间，具体语法如下：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">CREATE TABLESPACE tablespace_name\n    ADD DATAFILE 'file_name'               #数据文件名\n    USE LOGFILE GROUP logfile_group        #自定义日志文件组，一般每组2个logfile。\n    [EXTENT_SIZE [=] extent_size]          #区大小\n    [INITIAL_SIZE [=] initial_size]        #初始化大小 \n    [AUTOEXTEND_SIZE [=] autoextend_size]  #自动扩宽尺寸\n    [MAX_SIZE [=] max_size]                #单个文件最大size，最大是32G。\n    [NODEGROUP [=] nodegroup_id]           #节点组\n    [WAIT]\n    [COMMENT [=] comment_text]\n    ENGINE [=] engine_name\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n</ul>\n<p>这样的好处是可以做到数据的冷热分离，分别用HDD和SSD来存储，既能实现数据的高效访问，又能节约成本，比如可以添加两块500G硬盘，经过创建卷组vg，划分逻辑卷lv，创建数据目录并mount相应的lv，假设划分的两个目录分别是/hot_data 和 /cold_data。</p>\n<p>这样就可以将核心的业务表如用户表，订单表存储在高性能SSD盘上，一些日志，流水表存储在普通的HDD上，主要的操作步骤如下：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#创建热数据表空间\ncreate tablespace tbs_data_hot add datafile '/hot_data/tbs_data_hot01.dbf' max_size 20G;\n#创建核心业务表存储在热数据表空间\ncreate table booking(id bigint not null primary key auto_increment, &hellip;&hellip; ) tablespace tbs_data_hot;\n#创建冷数据表空间\ncreate tablespace tbs_data_cold add datafile '/hot_data/tbs_data_cold01.dbf' max_size 20G;\n#创建日志，流水，备份类的表存储在冷数据表空间\ncreate table payment_log(id bigint not null primary key auto_increment, &hellip;&hellip; ) tablespace tbs_data_cold;\n#可以移动表到另一个表空间\nalter table payment_log tablespace tbs_data_hot;\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n</ul>\n<h2><a name=\"t3\"></a><a name=\"t3\"></a><a id=\"Inndob_69\"></a>Inndob存储分布</h2>\n<h3><a name=\"t4\"></a><a name=\"t4\"></a><a id=\"_71\"></a>创建空表查看空间变化</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; create table user(id bigint not null primary key auto_increment, \n    -&gt; name varchar(20) not null default '' comment '姓名', \n    -&gt; age tinyint not null default 0 comment 'age', \n    -&gt; gender char(1) not null default 'M'  comment '性别',\n    -&gt; phone varchar(16) not null default '' comment '手机号',\n    -&gt; create_time datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n    -&gt; update_time datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间'\n    -&gt; ) engine = InnoDB DEFAULT CHARSET=utf8mb4 COMMENT '用户信息表';\nQuery OK, 0 rows affected (0.26 sec)\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n</ul>\n<pre class=\"prettyprint\"><code class=\"prism language-bash has-numbering\"><span class=\"token comment\"># ls -lh user1.ibd </span>\n-rw-r----- 1 mysql mysql 96K Nov  6 12:48 user.ibd\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n</ul>\n<p>设置参数innodb_file_per_table=1时，创建表时会自动创建一个segment，同时分配一个extent，包含32个data page的来存储数据，这样创建的空表默认大小就是96KB，extent使用完之后会申请64个连接页，这样对于一些小表，或者undo segment，可以在开始时申请较少的空间，节省磁盘容量的开销。</p>\n<pre class=\"prettyprint\"><code class=\"prism language-shell has-numbering\"><span class=\"token comment\"># python2 py_innodb_page_info.py -v /data2/mysql/test/user.ibd</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>File Space Header<span class=\"token operator\">&gt;</span>\npage offset 00000001, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Insert Buffer Bitmap<span class=\"token operator\">&gt;</span>\npage offset 00000002, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>File Segment inode<span class=\"token operator\">&gt;</span>\npage offset 00000003, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>B-tree Node<span class=\"token operator\">&gt;</span>, page level <span class=\"token operator\">&lt;</span>0000<span class=\"token operator\">&gt;</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Freshly Allocated Page<span class=\"token operator\">&gt;</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Freshly Allocated Page<span class=\"token operator\">&gt;</span>\nTotal number of page: 6:      <span class=\"token comment\">#总共分配的页数</span>\nFreshly Allocated Page: 2     <span class=\"token comment\">#可用的数据页</span>\nInsert Buffer Bitmap: 1       <span class=\"token comment\">#插入缓冲页</span>\nFile Space Header: 1          <span class=\"token comment\">#文件空间头</span>\nB-tree Node: 1                <span class=\"token comment\">#数据页</span>\nFile Segment inode: 1         <span class=\"token comment\">#文件端inonde，如果是在ibdata1.ibd上会有多个inode。</span>\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n</ul>\n<h3><a name=\"t5\"></a><a name=\"t5\"></a><a id=\"_108\"></a>插入数据后的空间变化</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; DELIMITER $$\nmysql&gt; CREATE PROCEDURE insert_user_data(num INTEGER) \n    -&gt; BEGIN\n    -&gt;     DECLARE v_i int unsigned DEFAULT 0;\n    -&gt; set autocommit= 0;\n    -&gt; WHILE v_i &lt; num DO\n    -&gt;    insert into user(`name`, age, gender, phone) values (CONCAT('lyn',v_i), mod(v_i,120), 'M', CONCAT('152',ROUND(RAND(1)*100000000)));\n    -&gt;  SET v_i = v_i+1;\n    -&gt; END WHILE;\n    -&gt; commit;\n    -&gt; END $$\nQuery OK, 0 rows affected (0.01 sec)\nmysql&gt; DELIMITER ;\n\n#插入10w数据\nmysql&gt; call insert_user_data(100000);\nQuery OK, 0 rows affected (6.69 sec)\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n</ul>\n<pre class=\"prettyprint\"><code class=\"prism language-shell has-numbering\"><span class=\"token comment\"># ls -lh user.ibd</span>\n-rw-r----- 1 mysql mysql 14M Nov 6 10:58 /data2/mysql/test/user.ibd\n\n<span class=\"token comment\"># python2 py_innodb_page_info.py -v /data2/mysql/test/user.ibd</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>File Space Header<span class=\"token operator\">&gt;</span>\npage offset 00000001, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Insert Buffer Bitmap<span class=\"token operator\">&gt;</span>\npage offset 00000002, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>File Segment inode<span class=\"token operator\">&gt;</span>\npage offset 00000003, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>B-tree Node<span class=\"token operator\">&gt;</span>, page level <span class=\"token operator\">&lt;</span>0001<span class=\"token operator\">&gt;</span>   <span class=\"token comment\">#增加了一个非叶子节点，树的高度从1变为2.</span>\n<span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Freshly Allocated Page<span class=\"token operator\">&gt;</span>\nTotal number of page: 896:\nFreshly Allocated Page: 493\nInsert Buffer Bitmap: 1\nFile Space Header: 1\nB-tree Node: 400\nFile Segment inode: 1\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n</ul>\n<h3><a name=\"t6\"></a><a name=\"t6\"></a><a id=\"delete_149\"></a>delete数据后的空间变化</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; select min(id),max(id),count(*) from user;\n+---------+---------+----------+\n| min(id) | max(id) | count(*) |\n+---------+---------+----------+\n|       1 |  100000 |   100000 |\n+---------+---------+----------+\n1 row in set (0.05 sec)\n#删除50000条数据，理论上空间应该从14MB变长7MB左右。\nmysql&gt; delete from user limit 50000;\nQuery OK, 50000 rows affected (0.25 sec)\n\n#数据文件大小依然是14MB，没有缩小。\n# ls -lh /data2/mysql/test/user1.ibd \n-rw-r----- 1 mysql mysql 14M Nov  6 13:22 /data2/mysql/test/user.ibd\n\n#数据页没有被回收。\n# python2 py_innodb_page_info.py -v /data2/mysql/test/user.ibd\npage offset 00000000, page type &lt;File Space Header&gt;\npage offset 00000001, page type &lt;Insert Buffer Bitmap&gt;\npage offset 00000002, page type &lt;File Segment inode&gt;\npage offset 00000003, page type &lt;B-tree Node&gt;, page level &lt;0001&gt;\n........................................................\npage offset 00000000, page type &lt;Freshly Allocated Page&gt;\nTotal number of page: 896:\nFreshly Allocated Page: 493\nInsert Buffer Bitmap: 1\nFile Space Header: 1\nB-tree Node: 400\nFile Segment inode: 1\n#在MySQL内部是标记删除，\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n</ul>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; use information_schema;\n\nDatabase changed\nmysql&gt; SELECT A.SPACE AS TBL_SPACEID, A.TABLE_ID, A.NAME AS TABLE_NAME, FILE_FORMAT, ROW_FORMAT, SPACE_TYPE,  B.INDEX_ID , B.NAME AS INDEX_NAME, PAGE_NO, B.TYPE AS INDEX_TYPE FROM INNODB_SYS_TABLES A LEFT JOIN INNODB_SYS_INDEXES B ON A.TABLE_ID =B.TABLE_ID WHERE A.NAME = 'test/user1';\n+-------------+----------+------------+-------------+------------+------------+----------+------------+---------+------------+\n| TBL_SPACEID | TABLE_ID | TABLE_NAME | FILE_FORMAT | ROW_FORMAT | SPACE_TYPE | INDEX_ID | INDEX_NAME | PAGE_NO | INDEX_TYPE |\n+-------------+----------+------------+-------------+------------+------------+----------+------------+---------+------------+\n|        1283 |     1207 | test/user | Barracuda   | Dynamic    | Single     |     2236 | PRIMARY    |       3 |          3 |\n+-------------+----------+------------+-------------+------------+------------+----------+------------+---------+------------+\n1 row in set (0.01 sec)\n\nPAGE_NO = 3 标识B-tree的root page是3号页，INDEX_TYPE = 3是聚集索引。 INDEX_TYPE取值如下：\n0 = nonunique secondary index; \n1 = automatically generated clustered index (GEN_CLUST_INDEX); \n2 = unique nonclustered index; \n3 = clustered index; \n32 = full-text index;\n#收缩空间再后进行观察\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n</ul>\n<p>MySQL内部不会真正删除空间，而且做标记删除，即将delflag:N修改为delflag:Y，commit之后会会被purge进入删除链表，如果下一次insert更大的记录，delete之后的空间不会被重用，如果插入的记录小于等于delete的记录空会被重用，这块内容可以通过知数堂的innblock工具进行分析。</p>\n<h2><a name=\"t7\"></a><a name=\"t7\"></a><a id=\"Innodb_207\"></a>Innodb中的碎片</h2>\n<h3><a name=\"t8\"></a><a name=\"t8\"></a><a id=\"_209\"></a>碎片的产生</h3>\n<p>我们知道数据存储在文件系统上的，总是不能100%利用分配给它的物理空间，删除数据会在页面上留下一些&rdquo;空洞&rdquo;，或者随机写入（聚集索引非线性增加）会导致页分裂，页分裂导致页面的利用空间少于50%，另外对表进行增删改会引起对应的二级索引值的随机的增删改，也会导致索引结构中的数据页面上留下一些\"空洞\"，虽然这些空洞有可能会被重复利用，但终究会导致部分物理空间未被使用，也就是碎片。</p>\n<p>同时，即便是设置了填充因子为100%，Innodb也会主动留下page页面1/16的空间作为预留使用（An innodb_fill_factor setting of 100 leaves 1/16 of the space in clustered index pages free for future index growth）防止update带来的行溢出。</p>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; select table_schema,\n    -&gt;        table_name,ENGINE,\n    -&gt;        round(DATA_LENGTH/1024/1024+ INDEX_LENGTH/1024/1024) total_mb,TABLE_ROWS,\n    -&gt;        round(DATA_LENGTH/1024/1024) data_mb, round(INDEX_LENGTH/1024/1024) index_mb, round(DATA_FREE/1024/1024) free_mb, round(DATA_FREE/DATA_LENGTH*100,2) free_ratio\n    -&gt; from information_schema.TABLES where  TABLE_SCHEMA= 'test'\n    -&gt; and TABLE_NAME= 'user';\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n| table_schema | table_name | ENGINE | total_mb | TABLE_ROWS | data_mb | index_mb | free_mb | free_ratio |\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n| test         | user      | InnoDB |        4 |      50000 |       4 |        0 |       6 |     149.42 |\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n1 row in set (0.00 sec)\n\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n</ul>\n<p>其中data_free是分配了未使用的字节数，并不能说明完全是碎片空间。</p>\n<h3><a name=\"t9\"></a><a name=\"t9\"></a><a id=\"_233\"></a>碎片的回收</h3>\n<p>对于InnoDB的表，可以通过以下命令来回收碎片，释放空间，这个是随机读IO操作，会比较耗时，也会阻塞表上正常的DML运行，同时需要占用额外更多的磁盘空间，对于RDS来说，可能会导致磁盘空间瞬间爆满，实例瞬间被锁定，应用无法做DML操作，所以禁止在线上环境去执行。</p>\n<pre class=\"prettyprint\"><code class=\"prism language-shell has-numbering\"><span class=\"token comment\">#执行InnoDB的碎片回收</span>\nmysql<span class=\"token operator\">&gt;</span> alter table user engine<span class=\"token operator\">=</span>InnoDB<span class=\"token punctuation\">;</span>\nQuery OK, 0 rows affected <span class=\"token punctuation\">(</span>9.00 sec<span class=\"token punctuation\">)</span>\nRecords: 0  Duplicates: 0  Warnings: 0\n\n<span class=\"token comment\">##执行完之后，数据文件大小从14MB降低到10M。</span>\n<span class=\"token comment\"># ls -lh /data2/mysql/test/user1.ibd </span>\n-rw-r----- 1 mysql mysql 10M Nov 6 16:18 /data2/mysql/test/user.ibd\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n</ul>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; select table_schema,        table_name,ENGINE,        round(DATA_LENGTH/1024/1024+ INDEX_LENGTH/1024/1024) total_mb,TABLE_ROWS,        round(DATA_LENGTH/1024/1024) data_mb, round(INDEX_LENGTH/1024/1024) index_mb, round(DATA_FREE/1024/1024) free_mb, round(DATA_FREE/DATA_LENGTH*100,2) free_ratio from information_schema.TABLES where  TABLE_SCHEMA= 'test' and TABLE_NAME= 'user';\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n| table_schema | table_name | ENGINE | total_mb | TABLE_ROWS | data_mb | index_mb | free_mb | free_ratio |\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n| test         | user      | InnoDB |        5 |      50000 |       5 |        0 |       2 |      44.29 |\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n1 row in set (0.00 sec)\n\n\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n</ul>\n<h2><a name=\"t10\"></a><a name=\"t10\"></a><a id=\"deleteSQL_260\"></a>delete对SQL的影响</h2>\n<h3><a name=\"t11\"></a><a name=\"t11\"></a><a id=\"SQL_262\"></a>未删除前的SQL执行情况</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#插入100W数据\nmysql&gt; call insert_user_data(1000000);\nQuery OK, 0 rows affected (35.99 sec)\n\n#添加相关索引\nmysql&gt; alter table user add index idx_name(name), add index idx_phone(phone);\nQuery OK, 0 rows affected (6.00 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\n#表上索引统计信息\nmysql&gt; show index from user;\n+-------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+\n| Table | Non_unique | Key_name  | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |\n+-------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+\n| user  |          0 | PRIMARY   |            1 | id          | A         |      996757 |     NULL | NULL   |      | BTREE      |         |               |\n| user  |          1 | idx_name  |            1 | name        | A         |      996757 |     NULL | NULL   |      | BTREE      |         |               |\n| user  |          1 | idx_phone |            1 | phone       | A         |           2 |     NULL | NULL   |      | BTREE      |         |               |\n+-------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+\n3 rows in set (0.00 sec)\n\n#重置状态变量计数\nmysql&gt; flush status;\nQuery OK, 0 rows affected (0.00 sec)\n\n#执行SQL语句\nmysql&gt; select id, age ,phone from user where name like 'lyn12%';\n+--------+-----+-------------+\n| id     | age | phone       |\n+--------+-----+-------------+\n|    124 |   3 | 15240540354 |\n|   1231 |  30 | 15240540354 |\n|  12301 |  60 | 15240540354 |\n.............................\n| 129998 |  37 | 15240540354 |\n| 129999 |  38 | 15240540354 |\n| 130000 |  39 | 15240540354 |\n+--------+-----+-------------+\n11111 rows in set (0.03 sec)\n\nmysql&gt; explain select id, age ,phone from user where name like 'lyn12%';\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n| id | select_type | table | type  | possible_keys | key      | key_len | ref  | rows  | Extra                 |\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n|  1 | SIMPLE      | user  | range | idx_name      | idx_name | 82      | NULL | 22226 | Using index condition |\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n1 row in set (0.00 sec)\n\n#查看相关状态呢变量\nmysql&gt; select * from information_schema.session_status where variable_name in('Last_query_cost','Handler_read_next','Innodb_pages_read','Innodb_data_reads','Innodb_pages_read');\n+-------------------+----------------+\n| VARIABLE_NAME     | VARIABLE_VALUE |\n+-------------------+----------------+\n| HANDLER_READ_NEXT | 11111          |    #请求读的行数\n| INNODB_DATA_READS | 7868409        |    #数据物理读的总数\n| INNODB_PAGES_READ | 7855239        |    #逻辑读的总数\n| LAST_QUERY_COST   | 10.499000      |    #SQL语句的成本COST，主要包括IO_COST和CPU_COST。\n+-------------------+----------------+\n4 rows in set (0.00 sec)\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n<li>31</li>\n<li>32</li>\n<li>33</li>\n<li>34</li>\n<li>35</li>\n<li>36</li>\n<li>37</li>\n<li>38</li>\n<li>39</li>\n<li>40</li>\n<li>41</li>\n<li>42</li>\n<li>43</li>\n<li>44</li>\n<li>45</li>\n<li>46</li>\n<li>47</li>\n<li>48</li>\n<li>49</li>\n<li>50</li>\n<li>51</li>\n<li>52</li>\n<li>53</li>\n<li>54</li>\n<li>55</li>\n<li>56</li>\n<li>57</li>\n<li>58</li>\n</ul>\n<h3><a name=\"t12\"></a><a name=\"t12\"></a><a id=\"SQL_325\"></a>删除后的SQL执行情况</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#删除50w数据\nmysql&gt; delete from user limit 500000;\nQuery OK, 500000 rows affected (3.70 sec)\n\n#分析表统计信息\nmysql&gt; analyze table user;\n+-----------+---------+----------+----------+\n| Table     | Op      | Msg_type | Msg_text |\n+-----------+---------+----------+----------+\n| test.user | analyze | status   | OK       |\n+-----------+---------+----------+----------+\n1 row in set (0.01 sec)\n\n#重置状态变量计数\nmysql&gt; flush status;\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql&gt; select id, age ,phone from user where name like 'lyn12%';\nEmpty set (0.05 sec)\n\nmysql&gt; explain select id, age ,phone from user where name like 'lyn12%';\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n| id | select_type | table | type  | possible_keys | key      | key_len | ref  | rows  | Extra                 |\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n|  1 | SIMPLE      | user  | range | idx_name      | idx_name | 82      | NULL | 22226 | Using index condition |\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n1 row in set (0.00 sec)\n\nmysql&gt; select * from information_schema.session_status where variable_name in('Last_query_cost','Handler_read_next','Innodb_pages_read','Innodb_data_reads','Innodb_pages_read');\n+-------------------+----------------+\n| VARIABLE_NAME     | VARIABLE_VALUE |\n+-------------------+----------------+\n| HANDLER_READ_NEXT | 0              |\n| INNODB_DATA_READS | 7868409        |\n| INNODB_PAGES_READ | 7855239        |\n| LAST_QUERY_COST   | 10.499000      |\n+-------------------+----------------+\n4 rows in set (0.00 sec)\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n<li>31</li>\n<li>32</li>\n<li>33</li>\n<li>34</li>\n<li>35</li>\n<li>36</li>\n<li>37</li>\n<li>38</li>\n</ul>\n<h3><a name=\"t13\"></a><a name=\"t13\"></a><a id=\"_368\"></a>结果统计分析</h3>\n<div class=\"table-box\">\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>COST</th>\n<th>物理读次数</th>\n<th>逻辑读次数</th>\n<th>扫描行数</th>\n<th>返回行数</th>\n<th>执行时间</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>初始化插入100W</td>\n<td>10.499000</td>\n<td>7868409</td>\n<td>7855239</td>\n<td>22226</td>\n<td>11111</td>\n<td>30ms</td>\n</tr>\n<tr>\n<td>100W随机删除50W</td>\n<td>10.499000</td>\n<td>7868409</td>\n<td>7855239</td>\n<td>22226</td>\n<td>0</td>\n<td>50ms</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>这也说明对普通的大表，想要通过delete数据来对表进行瘦身是不现实的，所以在任何时候不要用delete去删除数据，应该使用优雅的标记删除。</p>\n<h2><a name=\"t14\"></a><a name=\"t14\"></a><a id=\"delete_377\"></a>delete优化建议</h2>\n<h3><a name=\"t15\"></a><a name=\"t15\"></a><a id=\"_379\"></a>控制业务账号权限</h3>\n<p>对于一个大的系统来说，需要根据业务特点去拆分子系统，每个子系统可以看做是一个service，例如美团APP，上面有很多服务，核心的服务有用户服务user-service，搜索服务search-service，商品product-service，位置服务location-service，价格服务price-service等。每个服务对应一个数据库，为该数据库创建单独账号，同时只授予DML权限且没有delete权限，同时禁止跨库访问。</p>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#创建用户数据库并授权\ncreate database mt_user charset utf8mb4;\ngrant USAGE, SELECT, INSERT, UPDATE ON mt_user.*  to 'w_user'@'%' identified by 't$W*g@gaHTGi123456';\nflush privileges;\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n</ul>\n<h3><a name=\"t16\"></a><a name=\"t16\"></a><a id=\"delete_390\"></a>delete改为标记删除</h3>\n<p>在MySQL数据库建模规范中有4个公共字段，基本上每个表必须有的，同时在create_time列要创建索引，有两方面的好处：</p>\n<ol>\n<li>一些查询业务场景都会有一个默认的时间段，比如7天或者一个月，都是通过create_time去过滤，走索引扫描更快。</li>\n<li>一些核心的业务表需要以T +1的方式抽取数据仓库中，比如每天晚上00:30抽取前一天的数据，都是通过create_time过滤的。</li>\n</ol>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">`id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键id',\n`is_deleted` tinyint(4) NOT NULL DEFAULT '0' COMMENT '是否逻辑删除：0：未删除，1：已删除',\n`create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n`update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间'\n\n#有了删除标记，业务接口的delete操作就可以转换为update\nupdate user set is_deleted = 1 where user_id = 1213;\n\n#查询的时候需要带上is_deleted过滤\nselect id, age ,phone from user where is_deleted = 0 and name like 'lyn12%';\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n</ul>\n<h2><a name=\"t17\"></a><a name=\"t17\"></a><a id=\"_410\"></a>数据归档方式</h2>\n<h3><a name=\"t18\"></a><a name=\"t18\"></a><a id=\"_412\"></a>通用数据归档方法</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#1. 创建归档表，一般在原表名后面添加_bak。\nCREATE TABLE `ota_order_bak` (\n  `id` bigint(11) NOT NULL AUTO_INCREMENT COMMENT '主键',\n  `order_id` varchar(255) DEFAULT NULL COMMENT '订单id',\n  `ota_id` varchar(255) DEFAULT NULL COMMENT 'ota',\n  `check_in_date` varchar(255) DEFAULT NULL COMMENT '入住日期',\n  `check_out_date` varchar(255) DEFAULT NULL COMMENT '离店日期',\n  `hotel_id` varchar(255) DEFAULT NULL COMMENT '酒店ID',\n  `guest_name` varchar(255) DEFAULT NULL COMMENT '顾客',\n  `purcharse_time` timestamp NULL DEFAULT NULL COMMENT '购买时间',\n  `create_time` datetime DEFAULT NULL,\n  `update_time` datetime DEFAULT NULL,\n  `create_user` varchar(255) DEFAULT NULL,\n  `update_user` varchar(255) DEFAULT NULL,\n  `status` int(4) DEFAULT '1' COMMENT '状态 ： 1 正常 ， 0 删除',\n  `hotel_name` varchar(255) DEFAULT NULL,\n  `price` decimal(10,0) DEFAULT NULL,\n  `remark` longtext,\n  PRIMARY KEY (`id`),\n  KEY `IDX_order_id` (`order_id`) USING BTREE,\n  KEY `hotel_name` (`hotel_name`) USING BTREE,\n  KEY `ota_id` (`ota_id`) USING BTREE,\n  KEY `IDX_purcharse_time` (`purcharse_time`) USING BTREE,\n  KEY `IDX_create_time` (`create_time`) USING BTREE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8\nPARTITION BY RANGE (to_days(create_time)) ( \nPARTITION p201808 VALUES LESS THAN (to_days('2018-09-01')), \nPARTITION p201809 VALUES LESS THAN (to_days('2018-10-01')), \nPARTITION p201810 VALUES LESS THAN (to_days('2018-11-01')), \nPARTITION p201811 VALUES LESS THAN (to_days('2018-12-01')), \nPARTITION p201812 VALUES LESS THAN (to_days('2019-01-01')), \nPARTITION p201901 VALUES LESS THAN (to_days('2019-02-01')), \nPARTITION p201902 VALUES LESS THAN (to_days('2019-03-01')), \nPARTITION p201903 VALUES LESS THAN (to_days('2019-04-01')), \nPARTITION p201904 VALUES LESS THAN (to_days('2019-05-01')), \nPARTITION p201905 VALUES LESS THAN (to_days('2019-06-01')), \nPARTITION p201906 VALUES LESS THAN (to_days('2019-07-01')), \nPARTITION p201907 VALUES LESS THAN (to_days('2019-08-01')), \nPARTITION p201908 VALUES LESS THAN (to_days('2019-09-01')), \nPARTITION p201909 VALUES LESS THAN (to_days('2019-10-01')), \nPARTITION p201910 VALUES LESS THAN (to_days('2019-11-01')), \nPARTITION p201911 VALUES LESS THAN (to_days('2019-12-01')), \nPARTITION p201912 VALUES LESS THAN (to_days('2020-01-01')));\n\n#2. 插入原表中无效的数据（需要跟开发同学确认数据保留范围）\ncreate table tbl_p201808 as select * from ota_order where create_time between '2018-08-01 00:00:00' and '2018-08-31 23:59:59';\n\n#3. 跟归档表分区做分区交换\nalter table ota_order_bak exchange partition p201808 with table tbl_p201808; \n\n#4. 删除原表中已经规范的数据\ndelete from ota_order where create_time between '2018-08-01 00:00:00' and '2018-08-31 23:59:59' limit 3000;\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n<li>31</li>\n<li>32</li>\n<li>33</li>\n<li>34</li>\n<li>35</li>\n<li>36</li>\n<li>37</li>\n<li>38</li>\n<li>39</li>\n<li>40</li>\n<li>41</li>\n<li>42</li>\n<li>43</li>\n<li>44</li>\n<li>45</li>\n<li>46</li>\n<li>47</li>\n<li>48</li>\n<li>49</li>\n<li>50</li>\n<li>51</li>\n<li>52</li>\n</ul>\n<h3><a name=\"t19\"></a><a name=\"t19\"></a><a id=\"_469\"></a>优化后的归档方式</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#1. 创建中间表\nCREATE TABLE `ota_order_2020` (........) ENGINE=InnoDB DEFAULT CHARSET=utf8\nPARTITION BY RANGE (to_days(create_time)) ( \nPARTITION p201808 VALUES LESS THAN (to_days('2018-09-01')), \nPARTITION p201809 VALUES LESS THAN (to_days('2018-10-01')), \nPARTITION p201810 VALUES LESS THAN (to_days('2018-11-01')), \nPARTITION p201811 VALUES LESS THAN (to_days('2018-12-01')), \nPARTITION p201812 VALUES LESS THAN (to_days('2019-01-01')), \nPARTITION p201901 VALUES LESS THAN (to_days('2019-02-01')), \nPARTITION p201902 VALUES LESS THAN (to_days('2019-03-01')), \nPARTITION p201903 VALUES LESS THAN (to_days('2019-04-01')), \nPARTITION p201904 VALUES LESS THAN (to_days('2019-05-01')), \nPARTITION p201905 VALUES LESS THAN (to_days('2019-06-01')), \nPARTITION p201906 VALUES LESS THAN (to_days('2019-07-01')), \nPARTITION p201907 VALUES LESS THAN (to_days('2019-08-01')), \nPARTITION p201908 VALUES LESS THAN (to_days('2019-09-01')), \nPARTITION p201909 VALUES LESS THAN (to_days('2019-10-01')), \nPARTITION p201910 VALUES LESS THAN (to_days('2019-11-01')), \nPARTITION p201911 VALUES LESS THAN (to_days('2019-12-01')), \nPARTITION p201912 VALUES LESS THAN (to_days('2020-01-01')));\n\n#2. 插入原表中有效的数据，如果数据量在100W左右可以在业务低峰期直接插入，如果比较大，建议采用dataX来做，可以控制频率和大小，之前我这边用Go封装了dataX可以实现自动生成json文件，自定义大小去执行。\ninsert into ota_order_2020 select * from ota_order where create_time between '2020-08-01 00:00:00' and '2020-08-31 23:59:59';\n\n#3. 表重命名\nalter table ota_order rename to ota_order_bak;  \nalter table ota_order_2020 rename to ota_order;\n#4. 插入差异数据\ninsert into ota_order select * from ota_order_bak a where not exists (select 1 from ota_order b where a.id = b.id);\n#5. ota_order_bak改造成分区表，如果表比较大不建议直接改造，可以先创建好分区表，通过dataX把导入进去即可。\n\n#6. 后续的归档方法\n#创建中间普遍表\ncreate table ota_order_mid like ota_order;\n#交换原表无效数据分区到普通表\nalter table ota_order exchange partition p201808 with table ota_order_mid; \n##交换普通表数据到归档表的相应分区\nalter table ota_order_bak exchange partition p201808 with table ota_order_mid; \n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n<li>31</li>\n<li>32</li>\n<li>33</li>\n<li>34</li>\n<li>35</li>\n<li>36</li>\n<li>37</li>\n<li>38</li>\n</ul>\n<p>这样原表和归档表都是按月的分区表，只需要创建一个中间普通表，在业务低峰期做两次分区交换，既可以删除无效数据，又能回收空，而且没有空间碎片，不会影响表上的索引及SQL的执行计划。</p>\n<h2><a name=\"t20\"></a><a name=\"t20\"></a><a id=\"_514\"></a>总结</h2>\n<p>通过从InnoDB存储空间分布，delete对性能的影响可以看到，delete物理删除既不能释放磁盘空间，而且会产生大量的碎片，导致索引频繁分裂，影响SQL执行计划的稳定性；</p>\n<p>同时在碎片回收时，会耗用大量的CPU，磁盘空间，影响表上正常的DML操作。</p>\n<p>在业务代码层面，应该做逻辑标记删除，避免物理删除；为了实现数据归档需求，可以用采用MySQL分区表特性来实现，都是DDL操作，没有碎片产生。</p>\n<p>另外一个比较好的方案采用Clickhouse，对有生命周期的数据表可以使用Clickhouse存储，利用其TTL特性实现无效数据自动清理。</p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1330877080455553024","blogRead":0,"blogRemark":"MySQL","blogTitle":"面试官不讲武德问我：为什么MySQL不建议使用delete删除数据？","blogType":1,"createdTime":1606111996000,"version":3},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:48:05.800 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:48:17.062 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -==>  Preparing: select blog_id, blog_title, blog_image, blog_goods, blog_read, blog_collection, blog_remark, blog_comment, blog_source, created_time, update_time,type_name from bl_blog as b inner join bl_type as t on type_id = blog_type where t.deleted = 0 and b.deleted = 0 limit ?, ? 
2020-12-24 23:48:17.063 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -==> Parameters: 0(Integer), 10(Integer)
2020-12-24 23:48:17.100 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -<==      Total: 3
2020-12-24 23:48:17.101 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -==>  Preparing: select count(*) from bl_blog as b inner join bl_type as t on type_id = blog_type where t.deleted = 0 and b.deleted = 0 
2020-12-24 23:48:17.102 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -==> Parameters: 
2020-12-24 23:48:17.143 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -<==      Total: 1
2020-12-24 23:48:17.258 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:48:17.259 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/getByPage(String), [Page(currentPage=1, pageSize=10, totalPage=1, totalCount=3, list=[BlogVo(blogId=1324038097171820544, blogTitle=BeanUtils.copyProperties的用法, blogImage=Java, blogContent=null, blogGoods=0, blogRead=0, blogCollection=0, typeName=Java, blogSource=百度, blogRemark=BeanUtils它提供了对java反射和自省API的包装。它里面还有很多工具类，这里我们介绍一下copyProperties。, blogComment=0, blogMonth=null, createdTime=2020-11-04 17:17:33, updateTime=2020-11-22 13:04:15), BlogVo(blogId=1330877080455553024, blogTitle=面试官不讲武德问我：为什么MySQL不建议使用delete删除数据？, blogImage=null, blogContent=null, blogGoods=0, blogRead=0, blogCollection=0, typeName=Java, blogSource=null, blogRemark=MySQL, blogComment=0, blogMonth=null, createdTime=2020-11-23 14:13:16, updateTime=2020-11-23 14:23:06), BlogVo(blogId=1330879440221315072, blogTitle=Java岗四面字节跳动成功之前，我都刷了那些面试题以及做了那些准备！, blogImage=null, blogContent=null, blogGoods=0, blogRead=0, blogCollection=0, typeName=Java, blogSource=null, blogRemark=面试必备, blogComment=0, blogMonth=null, createdTime=2020-11-23 14:22:39, updateTime=2020-11-23 14:22:39)], params={}, sortColumn=null, sortMethod=asc)](String), 1(Integer), null, POST(String), 252(Long), {"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1324038097171820544","blogImage":"Java","blogRead":0,"blogRemark":"BeanUtils它提供了对java反射和自省API的包装。它里面还有很多工具类，这里我们介绍一下copyProperties。","blogSource":"百度","blogTitle":"BeanUtils.copyProperties的用法","createdTime":"2020-11-04 17:17:33","typeName":"Java","updateTime":"2020-11-22 13:04:15"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1330877080455553024","blogRead":0,"blogRemark":"MySQL","blogTitle":"面试官不讲武德问我：为什么MySQL不建议使用delete删除数据？","createdTime":"2020-11-23 14:13:16","typeName":"Java","updateTime":"2020-11-23 14:23:06"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1330879440221315072","blogRead":0,"blogRemark":"面试必备","blogTitle":"Java岗四面字节跳动成功之前，我都刷了那些面试题以及做了那些准备！","createdTime":"2020-11-23 14:22:39","typeName":"Java","updateTime":"2020-11-23 14:22:39"}],"pageSize":10,"params":{},"sortMethod":"asc","totalCount":3,"totalPage":1},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:48:17.350 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:57:54.825 DEBUG [http-nio-8899-exec-8]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:57:54.826 DEBUG [http-nio-8899-exec-8]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /BlAdmin/info(String), [](String), 1(Integer), null, GET(String), 2(Long), {"code":20000,"data":{"name":"田起凯","password":"","signature":"hold on","username":"admin"},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:57:54.913 DEBUG [http-nio-8899-exec-8]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:57:55.199 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlTypeMapper.selectByExample.debug:159 -==>  Preparing: SELECT type_id,type_name,type_blog_count,enable,deleted FROM bl_type WHERE ( enable = ? and deleted = ? ) 
2020-12-24 23:57:55.200 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlTypeMapper.selectByExample.debug:159 -==> Parameters: 1(Integer), 0(Integer)
2020-12-24 23:57:55.233 DEBUG [http-nio-8899-exec-10]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -==>  Preparing: select blog_id, blog_title, blog_image, blog_goods, blog_read, blog_collection, blog_remark, blog_comment, blog_source, created_time, update_time,type_name from bl_blog as b inner join bl_type as t on type_id = blog_type where t.deleted = 0 and b.deleted = 0 limit ?, ? 
2020-12-24 23:57:55.234 DEBUG [http-nio-8899-exec-10]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -==> Parameters: 0(Integer), 10(Integer)
2020-12-24 23:57:55.237 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlTypeMapper.selectByExample.debug:159 -<==      Total: 7
2020-12-24 23:57:55.272 DEBUG [http-nio-8899-exec-10]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -<==      Total: 3
2020-12-24 23:57:55.273 DEBUG [http-nio-8899-exec-10]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -==>  Preparing: select count(*) from bl_blog as b inner join bl_type as t on type_id = blog_type where t.deleted = 0 and b.deleted = 0 
2020-12-24 23:57:55.273 DEBUG [http-nio-8899-exec-10]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -==> Parameters: 
2020-12-24 23:57:55.275 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:57:55.276 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /type/getList(String), [](String), 1(Integer), null, GET(String), 79(Long), {"code":20000,"data":[{"deleted":0,"enable":1,"typeBlogCount":105,"typeId":1,"typeName":"Java"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"Python"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":6,"typeName":"going"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":7,"typeName":"Spring"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"nginx"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Redis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":10,"typeName":"Docker"}],"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:57:55.308 DEBUG [http-nio-8899-exec-10]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -<==      Total: 1
2020-12-24 23:57:55.362 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:57:55.417 DEBUG [http-nio-8899-exec-10]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:57:55.419 DEBUG [http-nio-8899-exec-10]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/getByPage(String), [Page(currentPage=1, pageSize=10, totalPage=0, totalCount=0, list=[], params={}, sortColumn=null, sortMethod=asc)](String), 1(Integer), null, POST(String), 219(Long), {"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1324038097171820544","blogImage":"Java","blogRead":0,"blogRemark":"BeanUtils它提供了对java反射和自省API的包装。它里面还有很多工具类，这里我们介绍一下copyProperties。","blogSource":"百度","blogTitle":"BeanUtils.copyProperties的用法","createdTime":"2020-11-04 17:17:33","typeName":"Java","updateTime":"2020-11-22 13:04:15"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1330877080455553024","blogRead":0,"blogRemark":"MySQL","blogTitle":"面试官不讲武德问我：为什么MySQL不建议使用delete删除数据？","createdTime":"2020-11-23 14:13:16","typeName":"Java","updateTime":"2020-11-23 14:23:06"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1330879440221315072","blogRead":0,"blogRemark":"面试必备","blogTitle":"Java岗四面字节跳动成功之前，我都刷了那些面试题以及做了那些准备！","createdTime":"2020-11-23 14:22:39","typeName":"Java","updateTime":"2020-11-23 14:22:39"}],"pageSize":10,"params":{},"sortMethod":"asc","totalCount":3,"totalPage":1},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:57:55.512 DEBUG [http-nio-8899-exec-10]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:57:57.611 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==>  Preparing: select blog_id, blog_title, blog_content, blog_goods, blog_image, blog_read, blog_collection, blog_type, blog_remark, blog_comment, blog_source, created_time, version from bl_blog where blog_id = ? and deleted = 0 
2020-12-24 23:57:57.613 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==> Parameters: 1324038097171820544(String)
2020-12-24 23:57:57.651 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -<==      Total: 1
2020-12-24 23:57:57.693 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:57:57.695 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/get/1324038097171820544(String), [1324038097171820544](String), 1(Integer), null, GET(String), 86(Long), {"code":20000,"data":{"blogCollection":0,"blogComment":0,"blogContent":"BeanUtils.copyProperties(a, b);b中的存在的属性，a中一定要有，但是a中可以有多余的属性；a中与b中相同的属性都会被替换，不管是否有值；a、 b中的属性要名字相同，才能被赋值，不然的话需要手动赋值；Spring的BeanUtils的CopyProperties方法需要对应的属性有getter和setter方法；如果存在属性完全相同的内部类，但是不是同一个内部类，即分别属于各自的内部类，则spring会认为属性不同，不会copy；spring和apache的copy属性的方法源和目的参数的位置正好相反，所以导包和调用的时候都要注意一下。","blogGoods":0,"blogId":"1324038097171820544","blogImage":"Java","blogRead":0,"blogRemark":"BeanUtils它提供了对java反射和自省API的包装。它里面还有很多工具类，这里我们介绍一下copyProperties。","blogSource":"百度","blogTitle":"BeanUtils.copyProperties的用法","blogType":1,"createdTime":1604481453000,"version":2},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:57:57.779 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:58:00.155 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==>  Preparing: select blog_id, blog_title, blog_content, blog_goods, blog_image, blog_read, blog_collection, blog_type, blog_remark, blog_comment, blog_source, created_time, version from bl_blog where blog_id = ? and deleted = 0 
2020-12-24 23:58:00.156 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==> Parameters: 1330877080455553024(String)
2020-12-24 23:58:00.298 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -<==      Total: 1
2020-12-24 23:58:00.342 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:58:00.345 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/get/1330877080455553024(String), [1330877080455553024](String), 1(Integer), null, GET(String), 185(Long), {"code":20000,"data":{"blogCollection":0,"blogComment":0,"blogContent":"<h2>前言</h2>\n<p>我负责的有几个系统随着业务量的增长，存储在MySQL中的数据日益剧增，我当时就想现在的业务方不讲武德，搞偷袭，趁我没反应过来把很多表，很快，很快啊都打到了亿级别，我大意了，没有闪，这就导致跟其Join的表的SQL变得很慢，对的应用接口的response time也变长了，影响了用户体验。</p>\n<p>事后我找到业务方，我批评了他们跟他们说要讲武德，连忙跟我道歉，这个事情才就此作罢，走的时候我对他们说下次不要这样了，耗子尾汁，好好反思。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/3c93aececcb9e763f5476362c4e88710.png\" alt=\"\" /></p>\n<p>骂归骂，事情还是得解决，时候我分析原因发现，发现有些表的数据量增长很快，对应SQL扫描了很多无效数据，导致SQL慢了下来，通过确认之后，这些大表都是一些流水、记录、日志类型数据，只需要保留1到3个月，此时需要对表做数据清理实现瘦身，一般都会想到用insert + delete的方式去清理。</p>\n<p>这篇文章我会从InnoDB存储空间分布，delete对性能的影响，以及优化建议方面解释为什么不建议delete删除数据。</p>\n<h2><a name=\"t1\"></a><a name=\"t1\"></a><a id=\"InnoDB_16\"></a>InnoDB存储架构</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/5c66ffe9749c58e1613d2519f7ea7211.png\" alt=\"\" /></p>\n<p>从这张图可以看到，InnoDB存储结构主要包括两部分：逻辑存储结构和物理存储结构。</p>\n<p>逻辑上是由表空间tablespace &mdash;&gt; 段segment或者inode &mdash;&gt; 区Extent &mdash;&mdash;&gt;数据页Page构成，Innodb逻辑管理单位是segment，空间分配的最小单位是extent，每个segment都会从表空间FREE_PAGE中分配32个page，当这32个page不够用时，会按照以下原则进行扩展：如果当前小于1个extent，则扩展到1个extent；当表空间小于32MB时，每次扩展一个extent；表空间大于32MB，每次扩展4个extent。</p>\n<p>物理上主要由系统用户数据文件，日志文件组成，数据文件主要存储MySQL字典数据和用户数据，日志文件记录的是data page的变更记录，用于MySQL Crash时的恢复。</p>\n<h2><a name=\"t2\"></a><a name=\"t2\"></a><a id=\"Innodb_26\"></a>Innodb表空间</h2>\n<p>InnoDB存储包括三类表空间：系统表空间，用户表空间，Undo表空间。</p>\n<p><strong>系统表空间：</strong>&nbsp;主要存储MySQL内部的数据字典数据，如information_schema下的数据。</p>\n<p><strong>用户表空间：</strong>&nbsp;当开启innodb_file_per_table=1时，数据表从系统表空间独立出来存储在以table_name.ibd命令的数据文件中，结构信息存储在table_name.frm文件中。</p>\n<p><strong>Undo表空间：</strong>&nbsp;存储Undo信息，如快照一致读和flashback都是利用undo信息。</p>\n<p>从MySQL 8.0开始允许用户自定义表空间，具体语法如下：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">CREATE TABLESPACE tablespace_name\n    ADD DATAFILE 'file_name'               #数据文件名\n    USE LOGFILE GROUP logfile_group        #自定义日志文件组，一般每组2个logfile。\n    [EXTENT_SIZE [=] extent_size]          #区大小\n    [INITIAL_SIZE [=] initial_size]        #初始化大小 \n    [AUTOEXTEND_SIZE [=] autoextend_size]  #自动扩宽尺寸\n    [MAX_SIZE [=] max_size]                #单个文件最大size，最大是32G。\n    [NODEGROUP [=] nodegroup_id]           #节点组\n    [WAIT]\n    [COMMENT [=] comment_text]\n    ENGINE [=] engine_name\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n</ul>\n<p>这样的好处是可以做到数据的冷热分离，分别用HDD和SSD来存储，既能实现数据的高效访问，又能节约成本，比如可以添加两块500G硬盘，经过创建卷组vg，划分逻辑卷lv，创建数据目录并mount相应的lv，假设划分的两个目录分别是/hot_data 和 /cold_data。</p>\n<p>这样就可以将核心的业务表如用户表，订单表存储在高性能SSD盘上，一些日志，流水表存储在普通的HDD上，主要的操作步骤如下：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#创建热数据表空间\ncreate tablespace tbs_data_hot add datafile '/hot_data/tbs_data_hot01.dbf' max_size 20G;\n#创建核心业务表存储在热数据表空间\ncreate table booking(id bigint not null primary key auto_increment, &hellip;&hellip; ) tablespace tbs_data_hot;\n#创建冷数据表空间\ncreate tablespace tbs_data_cold add datafile '/hot_data/tbs_data_cold01.dbf' max_size 20G;\n#创建日志，流水，备份类的表存储在冷数据表空间\ncreate table payment_log(id bigint not null primary key auto_increment, &hellip;&hellip; ) tablespace tbs_data_cold;\n#可以移动表到另一个表空间\nalter table payment_log tablespace tbs_data_hot;\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n</ul>\n<h2><a name=\"t3\"></a><a name=\"t3\"></a><a id=\"Inndob_69\"></a>Inndob存储分布</h2>\n<h3><a name=\"t4\"></a><a name=\"t4\"></a><a id=\"_71\"></a>创建空表查看空间变化</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; create table user(id bigint not null primary key auto_increment, \n    -&gt; name varchar(20) not null default '' comment '姓名', \n    -&gt; age tinyint not null default 0 comment 'age', \n    -&gt; gender char(1) not null default 'M'  comment '性别',\n    -&gt; phone varchar(16) not null default '' comment '手机号',\n    -&gt; create_time datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n    -&gt; update_time datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间'\n    -&gt; ) engine = InnoDB DEFAULT CHARSET=utf8mb4 COMMENT '用户信息表';\nQuery OK, 0 rows affected (0.26 sec)\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n</ul>\n<pre class=\"prettyprint\"><code class=\"prism language-bash has-numbering\"><span class=\"token comment\"># ls -lh user1.ibd </span>\n-rw-r----- 1 mysql mysql 96K Nov  6 12:48 user.ibd\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n</ul>\n<p>设置参数innodb_file_per_table=1时，创建表时会自动创建一个segment，同时分配一个extent，包含32个data page的来存储数据，这样创建的空表默认大小就是96KB，extent使用完之后会申请64个连接页，这样对于一些小表，或者undo segment，可以在开始时申请较少的空间，节省磁盘容量的开销。</p>\n<pre class=\"prettyprint\"><code class=\"prism language-shell has-numbering\"><span class=\"token comment\"># python2 py_innodb_page_info.py -v /data2/mysql/test/user.ibd</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>File Space Header<span class=\"token operator\">&gt;</span>\npage offset 00000001, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Insert Buffer Bitmap<span class=\"token operator\">&gt;</span>\npage offset 00000002, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>File Segment inode<span class=\"token operator\">&gt;</span>\npage offset 00000003, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>B-tree Node<span class=\"token operator\">&gt;</span>, page level <span class=\"token operator\">&lt;</span>0000<span class=\"token operator\">&gt;</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Freshly Allocated Page<span class=\"token operator\">&gt;</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Freshly Allocated Page<span class=\"token operator\">&gt;</span>\nTotal number of page: 6:      <span class=\"token comment\">#总共分配的页数</span>\nFreshly Allocated Page: 2     <span class=\"token comment\">#可用的数据页</span>\nInsert Buffer Bitmap: 1       <span class=\"token comment\">#插入缓冲页</span>\nFile Space Header: 1          <span class=\"token comment\">#文件空间头</span>\nB-tree Node: 1                <span class=\"token comment\">#数据页</span>\nFile Segment inode: 1         <span class=\"token comment\">#文件端inonde，如果是在ibdata1.ibd上会有多个inode。</span>\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n</ul>\n<h3><a name=\"t5\"></a><a name=\"t5\"></a><a id=\"_108\"></a>插入数据后的空间变化</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; DELIMITER $$\nmysql&gt; CREATE PROCEDURE insert_user_data(num INTEGER) \n    -&gt; BEGIN\n    -&gt;     DECLARE v_i int unsigned DEFAULT 0;\n    -&gt; set autocommit= 0;\n    -&gt; WHILE v_i &lt; num DO\n    -&gt;    insert into user(`name`, age, gender, phone) values (CONCAT('lyn',v_i), mod(v_i,120), 'M', CONCAT('152',ROUND(RAND(1)*100000000)));\n    -&gt;  SET v_i = v_i+1;\n    -&gt; END WHILE;\n    -&gt; commit;\n    -&gt; END $$\nQuery OK, 0 rows affected (0.01 sec)\nmysql&gt; DELIMITER ;\n\n#插入10w数据\nmysql&gt; call insert_user_data(100000);\nQuery OK, 0 rows affected (6.69 sec)\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n</ul>\n<pre class=\"prettyprint\"><code class=\"prism language-shell has-numbering\"><span class=\"token comment\"># ls -lh user.ibd</span>\n-rw-r----- 1 mysql mysql 14M Nov 6 10:58 /data2/mysql/test/user.ibd\n\n<span class=\"token comment\"># python2 py_innodb_page_info.py -v /data2/mysql/test/user.ibd</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>File Space Header<span class=\"token operator\">&gt;</span>\npage offset 00000001, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Insert Buffer Bitmap<span class=\"token operator\">&gt;</span>\npage offset 00000002, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>File Segment inode<span class=\"token operator\">&gt;</span>\npage offset 00000003, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>B-tree Node<span class=\"token operator\">&gt;</span>, page level <span class=\"token operator\">&lt;</span>0001<span class=\"token operator\">&gt;</span>   <span class=\"token comment\">#增加了一个非叶子节点，树的高度从1变为2.</span>\n<span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span>\npage offset 00000000, page <span class=\"token function\">type</span> <span class=\"token operator\">&lt;</span>Freshly Allocated Page<span class=\"token operator\">&gt;</span>\nTotal number of page: 896:\nFreshly Allocated Page: 493\nInsert Buffer Bitmap: 1\nFile Space Header: 1\nB-tree Node: 400\nFile Segment inode: 1\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n</ul>\n<h3><a name=\"t6\"></a><a name=\"t6\"></a><a id=\"delete_149\"></a>delete数据后的空间变化</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; select min(id),max(id),count(*) from user;\n+---------+---------+----------+\n| min(id) | max(id) | count(*) |\n+---------+---------+----------+\n|       1 |  100000 |   100000 |\n+---------+---------+----------+\n1 row in set (0.05 sec)\n#删除50000条数据，理论上空间应该从14MB变长7MB左右。\nmysql&gt; delete from user limit 50000;\nQuery OK, 50000 rows affected (0.25 sec)\n\n#数据文件大小依然是14MB，没有缩小。\n# ls -lh /data2/mysql/test/user1.ibd \n-rw-r----- 1 mysql mysql 14M Nov  6 13:22 /data2/mysql/test/user.ibd\n\n#数据页没有被回收。\n# python2 py_innodb_page_info.py -v /data2/mysql/test/user.ibd\npage offset 00000000, page type &lt;File Space Header&gt;\npage offset 00000001, page type &lt;Insert Buffer Bitmap&gt;\npage offset 00000002, page type &lt;File Segment inode&gt;\npage offset 00000003, page type &lt;B-tree Node&gt;, page level &lt;0001&gt;\n........................................................\npage offset 00000000, page type &lt;Freshly Allocated Page&gt;\nTotal number of page: 896:\nFreshly Allocated Page: 493\nInsert Buffer Bitmap: 1\nFile Space Header: 1\nB-tree Node: 400\nFile Segment inode: 1\n#在MySQL内部是标记删除，\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n</ul>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; use information_schema;\n\nDatabase changed\nmysql&gt; SELECT A.SPACE AS TBL_SPACEID, A.TABLE_ID, A.NAME AS TABLE_NAME, FILE_FORMAT, ROW_FORMAT, SPACE_TYPE,  B.INDEX_ID , B.NAME AS INDEX_NAME, PAGE_NO, B.TYPE AS INDEX_TYPE FROM INNODB_SYS_TABLES A LEFT JOIN INNODB_SYS_INDEXES B ON A.TABLE_ID =B.TABLE_ID WHERE A.NAME = 'test/user1';\n+-------------+----------+------------+-------------+------------+------------+----------+------------+---------+------------+\n| TBL_SPACEID | TABLE_ID | TABLE_NAME | FILE_FORMAT | ROW_FORMAT | SPACE_TYPE | INDEX_ID | INDEX_NAME | PAGE_NO | INDEX_TYPE |\n+-------------+----------+------------+-------------+------------+------------+----------+------------+---------+------------+\n|        1283 |     1207 | test/user | Barracuda   | Dynamic    | Single     |     2236 | PRIMARY    |       3 |          3 |\n+-------------+----------+------------+-------------+------------+------------+----------+------------+---------+------------+\n1 row in set (0.01 sec)\n\nPAGE_NO = 3 标识B-tree的root page是3号页，INDEX_TYPE = 3是聚集索引。 INDEX_TYPE取值如下：\n0 = nonunique secondary index; \n1 = automatically generated clustered index (GEN_CLUST_INDEX); \n2 = unique nonclustered index; \n3 = clustered index; \n32 = full-text index;\n#收缩空间再后进行观察\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n</ul>\n<p>MySQL内部不会真正删除空间，而且做标记删除，即将delflag:N修改为delflag:Y，commit之后会会被purge进入删除链表，如果下一次insert更大的记录，delete之后的空间不会被重用，如果插入的记录小于等于delete的记录空会被重用，这块内容可以通过知数堂的innblock工具进行分析。</p>\n<h2><a name=\"t7\"></a><a name=\"t7\"></a><a id=\"Innodb_207\"></a>Innodb中的碎片</h2>\n<h3><a name=\"t8\"></a><a name=\"t8\"></a><a id=\"_209\"></a>碎片的产生</h3>\n<p>我们知道数据存储在文件系统上的，总是不能100%利用分配给它的物理空间，删除数据会在页面上留下一些&rdquo;空洞&rdquo;，或者随机写入（聚集索引非线性增加）会导致页分裂，页分裂导致页面的利用空间少于50%，另外对表进行增删改会引起对应的二级索引值的随机的增删改，也会导致索引结构中的数据页面上留下一些\"空洞\"，虽然这些空洞有可能会被重复利用，但终究会导致部分物理空间未被使用，也就是碎片。</p>\n<p>同时，即便是设置了填充因子为100%，Innodb也会主动留下page页面1/16的空间作为预留使用（An innodb_fill_factor setting of 100 leaves 1/16 of the space in clustered index pages free for future index growth）防止update带来的行溢出。</p>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; select table_schema,\n    -&gt;        table_name,ENGINE,\n    -&gt;        round(DATA_LENGTH/1024/1024+ INDEX_LENGTH/1024/1024) total_mb,TABLE_ROWS,\n    -&gt;        round(DATA_LENGTH/1024/1024) data_mb, round(INDEX_LENGTH/1024/1024) index_mb, round(DATA_FREE/1024/1024) free_mb, round(DATA_FREE/DATA_LENGTH*100,2) free_ratio\n    -&gt; from information_schema.TABLES where  TABLE_SCHEMA= 'test'\n    -&gt; and TABLE_NAME= 'user';\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n| table_schema | table_name | ENGINE | total_mb | TABLE_ROWS | data_mb | index_mb | free_mb | free_ratio |\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n| test         | user      | InnoDB |        4 |      50000 |       4 |        0 |       6 |     149.42 |\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n1 row in set (0.00 sec)\n\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n</ul>\n<p>其中data_free是分配了未使用的字节数，并不能说明完全是碎片空间。</p>\n<h3><a name=\"t9\"></a><a name=\"t9\"></a><a id=\"_233\"></a>碎片的回收</h3>\n<p>对于InnoDB的表，可以通过以下命令来回收碎片，释放空间，这个是随机读IO操作，会比较耗时，也会阻塞表上正常的DML运行，同时需要占用额外更多的磁盘空间，对于RDS来说，可能会导致磁盘空间瞬间爆满，实例瞬间被锁定，应用无法做DML操作，所以禁止在线上环境去执行。</p>\n<pre class=\"prettyprint\"><code class=\"prism language-shell has-numbering\"><span class=\"token comment\">#执行InnoDB的碎片回收</span>\nmysql<span class=\"token operator\">&gt;</span> alter table user engine<span class=\"token operator\">=</span>InnoDB<span class=\"token punctuation\">;</span>\nQuery OK, 0 rows affected <span class=\"token punctuation\">(</span>9.00 sec<span class=\"token punctuation\">)</span>\nRecords: 0  Duplicates: 0  Warnings: 0\n\n<span class=\"token comment\">##执行完之后，数据文件大小从14MB降低到10M。</span>\n<span class=\"token comment\"># ls -lh /data2/mysql/test/user1.ibd </span>\n-rw-r----- 1 mysql mysql 10M Nov 6 16:18 /data2/mysql/test/user.ibd\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n</ul>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">mysql&gt; select table_schema,        table_name,ENGINE,        round(DATA_LENGTH/1024/1024+ INDEX_LENGTH/1024/1024) total_mb,TABLE_ROWS,        round(DATA_LENGTH/1024/1024) data_mb, round(INDEX_LENGTH/1024/1024) index_mb, round(DATA_FREE/1024/1024) free_mb, round(DATA_FREE/DATA_LENGTH*100,2) free_ratio from information_schema.TABLES where  TABLE_SCHEMA= 'test' and TABLE_NAME= 'user';\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n| table_schema | table_name | ENGINE | total_mb | TABLE_ROWS | data_mb | index_mb | free_mb | free_ratio |\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n| test         | user      | InnoDB |        5 |      50000 |       5 |        0 |       2 |      44.29 |\n+--------------+------------+--------+----------+------------+---------+----------+---------+------------+\n1 row in set (0.00 sec)\n\n\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n</ul>\n<h2><a name=\"t10\"></a><a name=\"t10\"></a><a id=\"deleteSQL_260\"></a>delete对SQL的影响</h2>\n<h3><a name=\"t11\"></a><a name=\"t11\"></a><a id=\"SQL_262\"></a>未删除前的SQL执行情况</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#插入100W数据\nmysql&gt; call insert_user_data(1000000);\nQuery OK, 0 rows affected (35.99 sec)\n\n#添加相关索引\nmysql&gt; alter table user add index idx_name(name), add index idx_phone(phone);\nQuery OK, 0 rows affected (6.00 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\n#表上索引统计信息\nmysql&gt; show index from user;\n+-------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+\n| Table | Non_unique | Key_name  | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |\n+-------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+\n| user  |          0 | PRIMARY   |            1 | id          | A         |      996757 |     NULL | NULL   |      | BTREE      |         |               |\n| user  |          1 | idx_name  |            1 | name        | A         |      996757 |     NULL | NULL   |      | BTREE      |         |               |\n| user  |          1 | idx_phone |            1 | phone       | A         |           2 |     NULL | NULL   |      | BTREE      |         |               |\n+-------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+\n3 rows in set (0.00 sec)\n\n#重置状态变量计数\nmysql&gt; flush status;\nQuery OK, 0 rows affected (0.00 sec)\n\n#执行SQL语句\nmysql&gt; select id, age ,phone from user where name like 'lyn12%';\n+--------+-----+-------------+\n| id     | age | phone       |\n+--------+-----+-------------+\n|    124 |   3 | 15240540354 |\n|   1231 |  30 | 15240540354 |\n|  12301 |  60 | 15240540354 |\n.............................\n| 129998 |  37 | 15240540354 |\n| 129999 |  38 | 15240540354 |\n| 130000 |  39 | 15240540354 |\n+--------+-----+-------------+\n11111 rows in set (0.03 sec)\n\nmysql&gt; explain select id, age ,phone from user where name like 'lyn12%';\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n| id | select_type | table | type  | possible_keys | key      | key_len | ref  | rows  | Extra                 |\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n|  1 | SIMPLE      | user  | range | idx_name      | idx_name | 82      | NULL | 22226 | Using index condition |\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n1 row in set (0.00 sec)\n\n#查看相关状态呢变量\nmysql&gt; select * from information_schema.session_status where variable_name in('Last_query_cost','Handler_read_next','Innodb_pages_read','Innodb_data_reads','Innodb_pages_read');\n+-------------------+----------------+\n| VARIABLE_NAME     | VARIABLE_VALUE |\n+-------------------+----------------+\n| HANDLER_READ_NEXT | 11111          |    #请求读的行数\n| INNODB_DATA_READS | 7868409        |    #数据物理读的总数\n| INNODB_PAGES_READ | 7855239        |    #逻辑读的总数\n| LAST_QUERY_COST   | 10.499000      |    #SQL语句的成本COST，主要包括IO_COST和CPU_COST。\n+-------------------+----------------+\n4 rows in set (0.00 sec)\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n<li>31</li>\n<li>32</li>\n<li>33</li>\n<li>34</li>\n<li>35</li>\n<li>36</li>\n<li>37</li>\n<li>38</li>\n<li>39</li>\n<li>40</li>\n<li>41</li>\n<li>42</li>\n<li>43</li>\n<li>44</li>\n<li>45</li>\n<li>46</li>\n<li>47</li>\n<li>48</li>\n<li>49</li>\n<li>50</li>\n<li>51</li>\n<li>52</li>\n<li>53</li>\n<li>54</li>\n<li>55</li>\n<li>56</li>\n<li>57</li>\n<li>58</li>\n</ul>\n<h3><a name=\"t12\"></a><a name=\"t12\"></a><a id=\"SQL_325\"></a>删除后的SQL执行情况</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#删除50w数据\nmysql&gt; delete from user limit 500000;\nQuery OK, 500000 rows affected (3.70 sec)\n\n#分析表统计信息\nmysql&gt; analyze table user;\n+-----------+---------+----------+----------+\n| Table     | Op      | Msg_type | Msg_text |\n+-----------+---------+----------+----------+\n| test.user | analyze | status   | OK       |\n+-----------+---------+----------+----------+\n1 row in set (0.01 sec)\n\n#重置状态变量计数\nmysql&gt; flush status;\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql&gt; select id, age ,phone from user where name like 'lyn12%';\nEmpty set (0.05 sec)\n\nmysql&gt; explain select id, age ,phone from user where name like 'lyn12%';\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n| id | select_type | table | type  | possible_keys | key      | key_len | ref  | rows  | Extra                 |\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n|  1 | SIMPLE      | user  | range | idx_name      | idx_name | 82      | NULL | 22226 | Using index condition |\n+----+-------------+-------+-------+---------------+----------+---------+------+-------+-----------------------+\n1 row in set (0.00 sec)\n\nmysql&gt; select * from information_schema.session_status where variable_name in('Last_query_cost','Handler_read_next','Innodb_pages_read','Innodb_data_reads','Innodb_pages_read');\n+-------------------+----------------+\n| VARIABLE_NAME     | VARIABLE_VALUE |\n+-------------------+----------------+\n| HANDLER_READ_NEXT | 0              |\n| INNODB_DATA_READS | 7868409        |\n| INNODB_PAGES_READ | 7855239        |\n| LAST_QUERY_COST   | 10.499000      |\n+-------------------+----------------+\n4 rows in set (0.00 sec)\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n<li>31</li>\n<li>32</li>\n<li>33</li>\n<li>34</li>\n<li>35</li>\n<li>36</li>\n<li>37</li>\n<li>38</li>\n</ul>\n<h3><a name=\"t13\"></a><a name=\"t13\"></a><a id=\"_368\"></a>结果统计分析</h3>\n<div class=\"table-box\">\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>COST</th>\n<th>物理读次数</th>\n<th>逻辑读次数</th>\n<th>扫描行数</th>\n<th>返回行数</th>\n<th>执行时间</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>初始化插入100W</td>\n<td>10.499000</td>\n<td>7868409</td>\n<td>7855239</td>\n<td>22226</td>\n<td>11111</td>\n<td>30ms</td>\n</tr>\n<tr>\n<td>100W随机删除50W</td>\n<td>10.499000</td>\n<td>7868409</td>\n<td>7855239</td>\n<td>22226</td>\n<td>0</td>\n<td>50ms</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>这也说明对普通的大表，想要通过delete数据来对表进行瘦身是不现实的，所以在任何时候不要用delete去删除数据，应该使用优雅的标记删除。</p>\n<h2><a name=\"t14\"></a><a name=\"t14\"></a><a id=\"delete_377\"></a>delete优化建议</h2>\n<h3><a name=\"t15\"></a><a name=\"t15\"></a><a id=\"_379\"></a>控制业务账号权限</h3>\n<p>对于一个大的系统来说，需要根据业务特点去拆分子系统，每个子系统可以看做是一个service，例如美团APP，上面有很多服务，核心的服务有用户服务user-service，搜索服务search-service，商品product-service，位置服务location-service，价格服务price-service等。每个服务对应一个数据库，为该数据库创建单独账号，同时只授予DML权限且没有delete权限，同时禁止跨库访问。</p>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#创建用户数据库并授权\ncreate database mt_user charset utf8mb4;\ngrant USAGE, SELECT, INSERT, UPDATE ON mt_user.*  to 'w_user'@'%' identified by 't$W*g@gaHTGi123456';\nflush privileges;\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n</ul>\n<h3><a name=\"t16\"></a><a name=\"t16\"></a><a id=\"delete_390\"></a>delete改为标记删除</h3>\n<p>在MySQL数据库建模规范中有4个公共字段，基本上每个表必须有的，同时在create_time列要创建索引，有两方面的好处：</p>\n<ol>\n<li>一些查询业务场景都会有一个默认的时间段，比如7天或者一个月，都是通过create_time去过滤，走索引扫描更快。</li>\n<li>一些核心的业务表需要以T +1的方式抽取数据仓库中，比如每天晚上00:30抽取前一天的数据，都是通过create_time过滤的。</li>\n</ol>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">`id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键id',\n`is_deleted` tinyint(4) NOT NULL DEFAULT '0' COMMENT '是否逻辑删除：0：未删除，1：已删除',\n`create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n`update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间'\n\n#有了删除标记，业务接口的delete操作就可以转换为update\nupdate user set is_deleted = 1 where user_id = 1213;\n\n#查询的时候需要带上is_deleted过滤\nselect id, age ,phone from user where is_deleted = 0 and name like 'lyn12%';\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n</ul>\n<h2><a name=\"t17\"></a><a name=\"t17\"></a><a id=\"_410\"></a>数据归档方式</h2>\n<h3><a name=\"t18\"></a><a name=\"t18\"></a><a id=\"_412\"></a>通用数据归档方法</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#1. 创建归档表，一般在原表名后面添加_bak。\nCREATE TABLE `ota_order_bak` (\n  `id` bigint(11) NOT NULL AUTO_INCREMENT COMMENT '主键',\n  `order_id` varchar(255) DEFAULT NULL COMMENT '订单id',\n  `ota_id` varchar(255) DEFAULT NULL COMMENT 'ota',\n  `check_in_date` varchar(255) DEFAULT NULL COMMENT '入住日期',\n  `check_out_date` varchar(255) DEFAULT NULL COMMENT '离店日期',\n  `hotel_id` varchar(255) DEFAULT NULL COMMENT '酒店ID',\n  `guest_name` varchar(255) DEFAULT NULL COMMENT '顾客',\n  `purcharse_time` timestamp NULL DEFAULT NULL COMMENT '购买时间',\n  `create_time` datetime DEFAULT NULL,\n  `update_time` datetime DEFAULT NULL,\n  `create_user` varchar(255) DEFAULT NULL,\n  `update_user` varchar(255) DEFAULT NULL,\n  `status` int(4) DEFAULT '1' COMMENT '状态 ： 1 正常 ， 0 删除',\n  `hotel_name` varchar(255) DEFAULT NULL,\n  `price` decimal(10,0) DEFAULT NULL,\n  `remark` longtext,\n  PRIMARY KEY (`id`),\n  KEY `IDX_order_id` (`order_id`) USING BTREE,\n  KEY `hotel_name` (`hotel_name`) USING BTREE,\n  KEY `ota_id` (`ota_id`) USING BTREE,\n  KEY `IDX_purcharse_time` (`purcharse_time`) USING BTREE,\n  KEY `IDX_create_time` (`create_time`) USING BTREE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8\nPARTITION BY RANGE (to_days(create_time)) ( \nPARTITION p201808 VALUES LESS THAN (to_days('2018-09-01')), \nPARTITION p201809 VALUES LESS THAN (to_days('2018-10-01')), \nPARTITION p201810 VALUES LESS THAN (to_days('2018-11-01')), \nPARTITION p201811 VALUES LESS THAN (to_days('2018-12-01')), \nPARTITION p201812 VALUES LESS THAN (to_days('2019-01-01')), \nPARTITION p201901 VALUES LESS THAN (to_days('2019-02-01')), \nPARTITION p201902 VALUES LESS THAN (to_days('2019-03-01')), \nPARTITION p201903 VALUES LESS THAN (to_days('2019-04-01')), \nPARTITION p201904 VALUES LESS THAN (to_days('2019-05-01')), \nPARTITION p201905 VALUES LESS THAN (to_days('2019-06-01')), \nPARTITION p201906 VALUES LESS THAN (to_days('2019-07-01')), \nPARTITION p201907 VALUES LESS THAN (to_days('2019-08-01')), \nPARTITION p201908 VALUES LESS THAN (to_days('2019-09-01')), \nPARTITION p201909 VALUES LESS THAN (to_days('2019-10-01')), \nPARTITION p201910 VALUES LESS THAN (to_days('2019-11-01')), \nPARTITION p201911 VALUES LESS THAN (to_days('2019-12-01')), \nPARTITION p201912 VALUES LESS THAN (to_days('2020-01-01')));\n\n#2. 插入原表中无效的数据（需要跟开发同学确认数据保留范围）\ncreate table tbl_p201808 as select * from ota_order where create_time between '2018-08-01 00:00:00' and '2018-08-31 23:59:59';\n\n#3. 跟归档表分区做分区交换\nalter table ota_order_bak exchange partition p201808 with table tbl_p201808; \n\n#4. 删除原表中已经规范的数据\ndelete from ota_order where create_time between '2018-08-01 00:00:00' and '2018-08-31 23:59:59' limit 3000;\n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n<li>31</li>\n<li>32</li>\n<li>33</li>\n<li>34</li>\n<li>35</li>\n<li>36</li>\n<li>37</li>\n<li>38</li>\n<li>39</li>\n<li>40</li>\n<li>41</li>\n<li>42</li>\n<li>43</li>\n<li>44</li>\n<li>45</li>\n<li>46</li>\n<li>47</li>\n<li>48</li>\n<li>49</li>\n<li>50</li>\n<li>51</li>\n<li>52</li>\n</ul>\n<h3><a name=\"t19\"></a><a name=\"t19\"></a><a id=\"_469\"></a>优化后的归档方式</h3>\n<pre class=\"prettyprint\"><code class=\"prism language-mysql has-numbering\">#1. 创建中间表\nCREATE TABLE `ota_order_2020` (........) ENGINE=InnoDB DEFAULT CHARSET=utf8\nPARTITION BY RANGE (to_days(create_time)) ( \nPARTITION p201808 VALUES LESS THAN (to_days('2018-09-01')), \nPARTITION p201809 VALUES LESS THAN (to_days('2018-10-01')), \nPARTITION p201810 VALUES LESS THAN (to_days('2018-11-01')), \nPARTITION p201811 VALUES LESS THAN (to_days('2018-12-01')), \nPARTITION p201812 VALUES LESS THAN (to_days('2019-01-01')), \nPARTITION p201901 VALUES LESS THAN (to_days('2019-02-01')), \nPARTITION p201902 VALUES LESS THAN (to_days('2019-03-01')), \nPARTITION p201903 VALUES LESS THAN (to_days('2019-04-01')), \nPARTITION p201904 VALUES LESS THAN (to_days('2019-05-01')), \nPARTITION p201905 VALUES LESS THAN (to_days('2019-06-01')), \nPARTITION p201906 VALUES LESS THAN (to_days('2019-07-01')), \nPARTITION p201907 VALUES LESS THAN (to_days('2019-08-01')), \nPARTITION p201908 VALUES LESS THAN (to_days('2019-09-01')), \nPARTITION p201909 VALUES LESS THAN (to_days('2019-10-01')), \nPARTITION p201910 VALUES LESS THAN (to_days('2019-11-01')), \nPARTITION p201911 VALUES LESS THAN (to_days('2019-12-01')), \nPARTITION p201912 VALUES LESS THAN (to_days('2020-01-01')));\n\n#2. 插入原表中有效的数据，如果数据量在100W左右可以在业务低峰期直接插入，如果比较大，建议采用dataX来做，可以控制频率和大小，之前我这边用Go封装了dataX可以实现自动生成json文件，自定义大小去执行。\ninsert into ota_order_2020 select * from ota_order where create_time between '2020-08-01 00:00:00' and '2020-08-31 23:59:59';\n\n#3. 表重命名\nalter table ota_order rename to ota_order_bak;  \nalter table ota_order_2020 rename to ota_order;\n#4. 插入差异数据\ninsert into ota_order select * from ota_order_bak a where not exists (select 1 from ota_order b where a.id = b.id);\n#5. ota_order_bak改造成分区表，如果表比较大不建议直接改造，可以先创建好分区表，通过dataX把导入进去即可。\n\n#6. 后续的归档方法\n#创建中间普遍表\ncreate table ota_order_mid like ota_order;\n#交换原表无效数据分区到普通表\nalter table ota_order exchange partition p201808 with table ota_order_mid; \n##交换普通表数据到归档表的相应分区\nalter table ota_order_bak exchange partition p201808 with table ota_order_mid; \n</code></pre>\n<ul class=\"pre-numbering\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n<li>6</li>\n<li>7</li>\n<li>8</li>\n<li>9</li>\n<li>10</li>\n<li>11</li>\n<li>12</li>\n<li>13</li>\n<li>14</li>\n<li>15</li>\n<li>16</li>\n<li>17</li>\n<li>18</li>\n<li>19</li>\n<li>20</li>\n<li>21</li>\n<li>22</li>\n<li>23</li>\n<li>24</li>\n<li>25</li>\n<li>26</li>\n<li>27</li>\n<li>28</li>\n<li>29</li>\n<li>30</li>\n<li>31</li>\n<li>32</li>\n<li>33</li>\n<li>34</li>\n<li>35</li>\n<li>36</li>\n<li>37</li>\n<li>38</li>\n</ul>\n<p>这样原表和归档表都是按月的分区表，只需要创建一个中间普通表，在业务低峰期做两次分区交换，既可以删除无效数据，又能回收空，而且没有空间碎片，不会影响表上的索引及SQL的执行计划。</p>\n<h2><a name=\"t20\"></a><a name=\"t20\"></a><a id=\"_514\"></a>总结</h2>\n<p>通过从InnoDB存储空间分布，delete对性能的影响可以看到，delete物理删除既不能释放磁盘空间，而且会产生大量的碎片，导致索引频繁分裂，影响SQL执行计划的稳定性；</p>\n<p>同时在碎片回收时，会耗用大量的CPU，磁盘空间，影响表上正常的DML操作。</p>\n<p>在业务代码层面，应该做逻辑标记删除，避免物理删除；为了实现数据归档需求，可以用采用MySQL分区表特性来实现，都是DDL操作，没有碎片产生。</p>\n<p>另外一个比较好的方案采用Clickhouse，对有生命周期的数据表可以使用Clickhouse存储，利用其TTL特性实现无效数据自动清理。</p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1330877080455553024","blogRead":0,"blogRemark":"MySQL","blogTitle":"面试官不讲武德问我：为什么MySQL不建议使用delete删除数据？","blogType":1,"createdTime":1606111996000,"version":3},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:58:00.909 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:58:09.966 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:58:09.967 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /BlAdmin/info(String), [](String), 1(Integer), null, GET(String), 2(Long), {"code":20000,"data":{"name":"田起凯","password":"","signature":"hold on","username":"admin"},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:58:10.054 DEBUG [http-nio-8899-exec-2]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:58:10.334 DEBUG [http-nio-8899-exec-4]com.tqk.blog.mapper.BlTypeMapper.selectByExample.debug:159 -==>  Preparing: SELECT type_id,type_name,type_blog_count,enable,deleted FROM bl_type WHERE ( enable = ? and deleted = ? ) 
2020-12-24 23:58:10.335 DEBUG [http-nio-8899-exec-4]com.tqk.blog.mapper.BlTypeMapper.selectByExample.debug:159 -==> Parameters: 1(Integer), 0(Integer)
2020-12-24 23:58:10.366 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -==>  Preparing: select blog_id, blog_title, blog_image, blog_goods, blog_read, blog_collection, blog_remark, blog_comment, blog_source, created_time, update_time,type_name from bl_blog as b inner join bl_type as t on type_id = blog_type where t.deleted = 0 and b.deleted = 0 limit ?, ? 
2020-12-24 23:58:10.367 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -==> Parameters: 0(Integer), 10(Integer)
2020-12-24 23:58:10.372 DEBUG [http-nio-8899-exec-4]com.tqk.blog.mapper.BlTypeMapper.selectByExample.debug:159 -<==      Total: 7
2020-12-24 23:58:10.404 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -<==      Total: 3
2020-12-24 23:58:10.405 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -==>  Preparing: select count(*) from bl_blog as b inner join bl_type as t on type_id = blog_type where t.deleted = 0 and b.deleted = 0 
2020-12-24 23:58:10.405 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -==> Parameters: 
2020-12-24 23:58:10.408 DEBUG [http-nio-8899-exec-4]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:58:10.409 DEBUG [http-nio-8899-exec-4]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /type/getList(String), [](String), 1(Integer), null, GET(String), 79(Long), {"code":20000,"data":[{"deleted":0,"enable":1,"typeBlogCount":105,"typeId":1,"typeName":"Java"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"Python"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":6,"typeName":"going"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":7,"typeName":"Spring"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"nginx"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Redis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":10,"typeName":"Docker"}],"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:58:10.440 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -<==      Total: 1
2020-12-24 23:58:10.496 DEBUG [http-nio-8899-exec-4]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:58:10.555 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:58:10.555 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/getByPage(String), [Page(currentPage=1, pageSize=10, totalPage=0, totalCount=0, list=[], params={}, sortColumn=null, sortMethod=asc)](String), 1(Integer), null, POST(String), 221(Long), {"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1324038097171820544","blogImage":"Java","blogRead":0,"blogRemark":"BeanUtils它提供了对java反射和自省API的包装。它里面还有很多工具类，这里我们介绍一下copyProperties。","blogSource":"百度","blogTitle":"BeanUtils.copyProperties的用法","createdTime":"2020-11-04 17:17:33","typeName":"Java","updateTime":"2020-11-22 13:04:15"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1330877080455553024","blogRead":0,"blogRemark":"MySQL","blogTitle":"面试官不讲武德问我：为什么MySQL不建议使用delete删除数据？","createdTime":"2020-11-23 14:13:16","typeName":"Java","updateTime":"2020-11-23 14:23:06"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1330879440221315072","blogRead":0,"blogRemark":"面试必备","blogTitle":"Java岗四面字节跳动成功之前，我都刷了那些面试题以及做了那些准备！","createdTime":"2020-11-23 14:22:39","typeName":"Java","updateTime":"2020-11-23 14:22:39"}],"pageSize":10,"params":{},"sortMethod":"asc","totalCount":3,"totalPage":1},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:58:10.634 DEBUG [http-nio-8899-exec-5]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:58:13.019 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==>  Preparing: select blog_id, blog_title, blog_content, blog_goods, blog_image, blog_read, blog_collection, blog_type, blog_remark, blog_comment, blog_source, created_time, version from bl_blog where blog_id = ? and deleted = 0 
2020-12-24 23:58:13.020 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==> Parameters: 1324038097171820544(String)
2020-12-24 23:58:13.056 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -<==      Total: 1
2020-12-24 23:58:13.107 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:58:13.107 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/get/1324038097171820544(String), [1324038097171820544](String), 1(Integer), org.springframework.dao.DataIntegrityViolationException: 
### Error updating database.  Cause: java.sql.SQLIntegrityConstraintViolationException: Column 'blog_content' cannot be null
### The error may involve com.tqk.blog.mapper.BlBlogMapper.save-Inline
### Cause: java.sql.SQLIntegrityConstraintViolationException: Column 'blog_content' cannot be null
; Column 'blog_content' cannot be null; nested exception is java.sql.SQLIntegrityConstraintViolationException: Column 'blog_content' cannot be null
	at com.tqk.blog.service.impl.BlogServiceImpl.save(BlogServiceImpl.java:52)
	at com.tqk.blog.service.impl.BlogServiceImpl$$FastClassBySpringCGLIB$$c89e2edd.invoke(<generated>)
	at com.tqk.blog.service.impl.BlogServiceImpl$$EnhancerBySpringCGLIB$$e40d0c11.save(<generated>)
	at com.tqk.blog.service.impl.BlogServiceImpl$$FastClassBySpringCGLIB$$c89e2edd.invoke(<generated>)
	at com.tqk.blog.service.impl.BlogServiceImpl$$EnhancerBySpringCGLIB$$7c340e8d.save(<generated>)
	at com.tqk.blog.controller.BlogController.save(BlogController.java:39)
	at com.tqk.blog.controller.BlogController$$FastClassBySpringCGLIB$$a4fc5e31.invoke(<generated>)
	at com.tqk.blog.aspect.RequestAspect.doAround(RequestAspect.java:65)
	at com.tqk.blog.controller.BlogController$$EnhancerBySpringCGLIB$$7e46265a.save(<generated>)
Caused by: java.sql.SQLIntegrityConstraintViolationException: Column 'blog_content' cannot be null
(String), GET(String), 81(Long), {"code":20000,"data":{"blogCollection":0,"blogComment":0,"blogContent":"BeanUtils.copyProperties(a, b);b中的存在的属性，a中一定要有，但是a中可以有多余的属性；a中与b中相同的属性都会被替换，不管是否有值；a、 b中的属性要名字相同，才能被赋值，不然的话需要手动赋值；Spring的BeanUtils的CopyProperties方法需要对应的属性有getter和setter方法；如果存在属性完全相同的内部类，但是不是同一个内部类，即分别属于各自的内部类，则spring会认为属性不同，不会copy；spring和apache的copy属性的方法源和目的参数的位置正好相反，所以导包和调用的时候都要注意一下。","blogGoods":0,"blogId":"1324038097171820544","blogImage":"Java","blogRead":0,"blogRemark":"BeanUtils它提供了对java反射和自省API的包装。它里面还有很多工具类，这里我们介绍一下copyProperties。","blogSource":"百度","blogTitle":"BeanUtils.copyProperties的用法","blogType":1,"createdTime":1604481453000,"version":2},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:58:13.185 DEBUG [http-nio-8899-exec-6]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:59:31.413 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:59:31.414 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /BlAdmin/info(String), [](String), 1(Integer), null, GET(String), 1(Long), {"code":20000,"data":{"name":"田起凯","password":"","signature":"hold on","username":"admin"},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:59:31.494 DEBUG [http-nio-8899-exec-7]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:59:31.757 DEBUG [http-nio-8899-exec-8]com.tqk.blog.mapper.BlTypeMapper.selectByExample.debug:159 -==>  Preparing: SELECT type_id,type_name,type_blog_count,enable,deleted FROM bl_type WHERE ( enable = ? and deleted = ? ) 
2020-12-24 23:59:31.758 DEBUG [http-nio-8899-exec-8]com.tqk.blog.mapper.BlTypeMapper.selectByExample.debug:159 -==> Parameters: 1(Integer), 0(Integer)
2020-12-24 23:59:31.794 DEBUG [http-nio-8899-exec-8]com.tqk.blog.mapper.BlTypeMapper.selectByExample.debug:159 -<==      Total: 7
2020-12-24 23:59:31.834 DEBUG [http-nio-8899-exec-8]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:59:31.835 DEBUG [http-nio-8899-exec-8]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /type/getList(String), [](String), 1(Integer), null, GET(String), 78(Long), {"code":20000,"data":[{"deleted":0,"enable":1,"typeBlogCount":105,"typeId":1,"typeName":"Java"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"Python"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":6,"typeName":"going"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":7,"typeName":"Spring"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"nginx"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Redis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":10,"typeName":"Docker"}],"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:59:31.918 DEBUG [http-nio-8899-exec-8]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:59:32.094 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -==>  Preparing: select blog_id, blog_title, blog_image, blog_goods, blog_read, blog_collection, blog_remark, blog_comment, blog_source, created_time, update_time,type_name from bl_blog as b inner join bl_type as t on type_id = blog_type where t.deleted = 0 and b.deleted = 0 limit ?, ? 
2020-12-24 23:59:32.095 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -==> Parameters: 0(Integer), 10(Integer)
2020-12-24 23:59:32.133 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -<==      Total: 3
2020-12-24 23:59:32.135 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -==>  Preparing: select count(*) from bl_blog as b inner join bl_type as t on type_id = blog_type where t.deleted = 0 and b.deleted = 0 
2020-12-24 23:59:32.136 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -==> Parameters: 
2020-12-24 23:59:32.172 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -<==      Total: 1
2020-12-24 23:59:32.280 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:59:32.281 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/getByPage(String), [Page(currentPage=1, pageSize=10, totalPage=0, totalCount=0, list=[], params={}, sortColumn=null, sortMethod=asc)](String), 1(Integer), null, POST(String), 219(Long), {"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1324038097171820544","blogImage":"Java","blogRead":0,"blogRemark":"BeanUtils它提供了对java反射和自省API的包装。它里面还有很多工具类，这里我们介绍一下copyProperties。","blogSource":"百度","blogTitle":"BeanUtils.copyProperties的用法","createdTime":"2020-11-04 17:17:33","typeName":"Java","updateTime":"2020-11-22 13:04:15"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1330877080455553024","blogRead":0,"blogRemark":"MySQL","blogTitle":"面试官不讲武德问我：为什么MySQL不建议使用delete删除数据？","createdTime":"2020-11-23 14:13:16","typeName":"Java","updateTime":"2020-11-23 14:23:06"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1330879440221315072","blogRead":0,"blogRemark":"面试必备","blogTitle":"Java岗四面字节跳动成功之前，我都刷了那些面试题以及做了那些准备！","createdTime":"2020-11-23 14:22:39","typeName":"Java","updateTime":"2020-11-23 14:22:39"}],"pageSize":10,"params":{},"sortMethod":"asc","totalCount":3,"totalPage":1},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:59:32.377 DEBUG [http-nio-8899-exec-9]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:59:34.086 DEBUG [http-nio-8899-exec-10]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==>  Preparing: select blog_id, blog_title, blog_content, blog_goods, blog_image, blog_read, blog_collection, blog_type, blog_remark, blog_comment, blog_source, created_time, version from bl_blog where blog_id = ? and deleted = 0 
2020-12-24 23:59:34.087 DEBUG [http-nio-8899-exec-10]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==> Parameters: 1324038097171820544(String)
2020-12-24 23:59:34.122 DEBUG [http-nio-8899-exec-10]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -<==      Total: 1
2020-12-24 23:59:34.163 DEBUG [http-nio-8899-exec-10]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:59:34.164 DEBUG [http-nio-8899-exec-10]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/get/1324038097171820544(String), [1324038097171820544](String), 1(Integer), null, GET(String), 78(Long), {"code":20000,"data":{"blogCollection":0,"blogComment":0,"blogContent":"BeanUtils.copyProperties(a, b);b中的存在的属性，a中一定要有，但是a中可以有多余的属性；a中与b中相同的属性都会被替换，不管是否有值；a、 b中的属性要名字相同，才能被赋值，不然的话需要手动赋值；Spring的BeanUtils的CopyProperties方法需要对应的属性有getter和setter方法；如果存在属性完全相同的内部类，但是不是同一个内部类，即分别属于各自的内部类，则spring会认为属性不同，不会copy；spring和apache的copy属性的方法源和目的参数的位置正好相反，所以导包和调用的时候都要注意一下。","blogGoods":0,"blogId":"1324038097171820544","blogImage":"Java","blogRead":0,"blogRemark":"BeanUtils它提供了对java反射和自省API的包装。它里面还有很多工具类，这里我们介绍一下copyProperties。","blogSource":"百度","blogTitle":"BeanUtils.copyProperties的用法","blogType":1,"createdTime":1604481453000,"version":2},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:59:34.247 DEBUG [http-nio-8899-exec-10]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:59:50.878 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -==>  Preparing: select blog_id, blog_title, blog_image, blog_goods, blog_read, blog_collection, blog_remark, blog_comment, blog_source, created_time, update_time,type_name from bl_blog as b inner join bl_type as t on type_id = blog_type where t.deleted = 0 and b.deleted = 0 limit ?, ? 
2020-12-24 23:59:50.878 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -==> Parameters: 0(Integer), 10(Integer)
2020-12-24 23:59:50.913 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlBlogMapper.getByPage.debug:159 -<==      Total: 3
2020-12-24 23:59:50.914 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -==>  Preparing: select count(*) from bl_blog as b inner join bl_type as t on type_id = blog_type where t.deleted = 0 and b.deleted = 0 
2020-12-24 23:59:50.915 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -==> Parameters: 
2020-12-24 23:59:50.950 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlBlogMapper.getCountByPage.debug:159 -<==      Total: 1
2020-12-24 23:59:51.057 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:59:51.058 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/getByPage(String), [Page(currentPage=1, pageSize=10, totalPage=1, totalCount=3, list=[BlogVo(blogId=1324038097171820544, blogTitle=BeanUtils.copyProperties的用法, blogImage=Java, blogContent=null, blogGoods=0, blogRead=0, blogCollection=0, typeName=Java, blogSource=百度, blogRemark=BeanUtils它提供了对java反射和自省API的包装。它里面还有很多工具类，这里我们介绍一下copyProperties。, blogComment=0, blogMonth=null, createdTime=2020-11-04 17:17:33, updateTime=2020-11-22 13:04:15), BlogVo(blogId=1330877080455553024, blogTitle=面试官不讲武德问我：为什么MySQL不建议使用delete删除数据？, blogImage=null, blogContent=null, blogGoods=0, blogRead=0, blogCollection=0, typeName=Java, blogSource=null, blogRemark=MySQL, blogComment=0, blogMonth=null, createdTime=2020-11-23 14:13:16, updateTime=2020-11-23 14:23:06), BlogVo(blogId=1330879440221315072, blogTitle=Java岗四面字节跳动成功之前，我都刷了那些面试题以及做了那些准备！, blogImage=null, blogContent=null, blogGoods=0, blogRead=0, blogCollection=0, typeName=Java, blogSource=null, blogRemark=面试必备, blogComment=0, blogMonth=null, createdTime=2020-11-23 14:22:39, updateTime=2020-11-23 14:22:39)], params={}, sortColumn=null, sortMethod=asc)](String), 1(Integer), null, POST(String), 212(Long), {"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1324038097171820544","blogImage":"Java","blogRead":0,"blogRemark":"BeanUtils它提供了对java反射和自省API的包装。它里面还有很多工具类，这里我们介绍一下copyProperties。","blogSource":"百度","blogTitle":"BeanUtils.copyProperties的用法","createdTime":"2020-11-04 17:17:33","typeName":"Java","updateTime":"2020-11-22 13:04:15"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1330877080455553024","blogRead":0,"blogRemark":"MySQL","blogTitle":"面试官不讲武德问我：为什么MySQL不建议使用delete删除数据？","createdTime":"2020-11-23 14:13:16","typeName":"Java","updateTime":"2020-11-23 14:23:06"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1330879440221315072","blogRead":0,"blogRemark":"面试必备","blogTitle":"Java岗四面字节跳动成功之前，我都刷了那些面试题以及做了那些准备！","createdTime":"2020-11-23 14:22:39","typeName":"Java","updateTime":"2020-11-23 14:22:39"}],"pageSize":10,"params":{},"sortMethod":"asc","totalCount":3,"totalPage":1},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:59:51.145 DEBUG [http-nio-8899-exec-1]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
2020-12-24 23:59:57.911 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==>  Preparing: select blog_id, blog_title, blog_content, blog_goods, blog_image, blog_read, blog_collection, blog_type, blog_remark, blog_comment, blog_source, created_time, version from bl_blog where blog_id = ? and deleted = 0 
2020-12-24 23:59:57.912 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -==> Parameters: 1324038097171820544(String)
2020-12-24 23:59:57.948 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlBlogMapper.getById.debug:159 -<==      Total: 1
2020-12-24 23:59:57.991 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==>  Preparing: insert into bl_log( log_url, log_params, log_status, log_message, log_method, log_time, log_result, log_ip ) values ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2020-12-24 23:59:57.992 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -==> Parameters: /blog/get/1324038097171820544(String), [1324038097171820544](String), 1(Integer), null, GET(String), 80(Long), {"code":20000,"data":{"blogCollection":0,"blogComment":0,"blogContent":"BeanUtils.copyProperties(a, b);b中的存在的属性，a中一定要有，但是a中可以有多余的属性；a中与b中相同的属性都会被替换，不管是否有值；a、 b中的属性要名字相同，才能被赋值，不然的话需要手动赋值；Spring的BeanUtils的CopyProperties方法需要对应的属性有getter和setter方法；如果存在属性完全相同的内部类，但是不是同一个内部类，即分别属于各自的内部类，则spring会认为属性不同，不会copy；spring和apache的copy属性的方法源和目的参数的位置正好相反，所以导包和调用的时候都要注意一下。","blogGoods":0,"blogId":"1324038097171820544","blogImage":"Java","blogRead":0,"blogRemark":"BeanUtils它提供了对java反射和自省API的包装。它里面还有很多工具类，这里我们介绍一下copyProperties。","blogSource":"百度","blogTitle":"BeanUtils.copyProperties的用法","blogType":1,"createdTime":1604481453000,"version":2},"msg":"操作成功！"}(String), 192.168.101.29(String)
2020-12-24 23:59:58.081 DEBUG [http-nio-8899-exec-3]com.tqk.blog.mapper.BlLogMapper.save.debug:159 -<==    Updates: 1
